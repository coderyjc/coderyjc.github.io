<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="笔记 | MySQL索引优化" />
    <meta name="hexo-theme-A4" content="v1.9.6" />
    <link rel="alternate icon" type="image/webp" href="/img/avatar.png">
    <title>Jingcun Yan</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/avatar.png" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jingcun Yan</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    笔记 | MySQL索引优化
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                
                    
                     <span>字数总计：11.1k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：43分钟</span>
                
                
            </div>
    

    <div class="post-md">
        
        <div class=".article-gallery"><h2 id="MySQLMySQL架构介绍"><a href="#MySQLMySQL架构介绍" class="headerlink" title="MySQLMySQL架构介绍"></a>MySQLMySQL架构介绍</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。 </p>
<p>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>MySQL是开源的，所以你不需要支付额外的费用。</p>
<p>MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。 </p>
<p>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</p>
<p>MySQL使用标准的SQL数据语言形式。</p>
<p>MySQL可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</p>
<p>MySQL支持大型数据库，支持5000万条记录的数据仓库（分库），单表最大容量大约为500万条数据（分表），32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</p>
<h3 id="MySQL用户与权限管理"><a href="#MySQL用户与权限管理" class="headerlink" title="MySQL用户与权限管理"></a>MySQL用户与权限管理</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><ul>
<li><p>创建用户<code> create user zhang3 identified by &#39;123123&#39;;</code></p>
<ul>
<li>表示创建名称为zhang3的用户，密码设为123123；</li>
</ul>
</li>
<li><p>修改当前用户的密码:</p>
<ul>
<li><code>set password =password(&#39;123456&#39;); flush privileges; </code></li>
</ul>
</li>
<li><p>修改某个用户的密码: </p>
<ul>
<li><code>update mysql.user set password=password(&#39;123456&#39;) where user=&#39;li4&#39;; flush privileges; </code></li>
</ul>
</li>
<li><p>修改用户名：</p>
<ul>
<li><code>update mysql.user set user=&#39;li4&#39; where user=&#39;wang5&#39;; flush privileges;</code></li>
</ul>
</li>
<li><p>删除用户：</p>
<ul>
<li><code>drop user li4 ;</code> （不要通过delete from  user u where user&#x3D;’li4’ 进行删除，系统会有残留信息保留。 ）</li>
</ul>
</li>
<li><p><span style = "color:red">flush privileges;   所有通过user表的修改，必须用该命令才能生效。</span></p>
</li>
</ul>
<p><strong>user表：</strong></p>
<p>查看用户<br><code>select host,user,authentication_string,select_priv,insert_priv,drop_priv from mysql.user;</code></p>
<p><a href="/img/showuser.png" title="查看用户" class="gallery-item" style="box-shadow: none;"> <img src="/img/showuser.png" alt="查看用户"></a></p>
<p> <strong>host</strong>    表示连接类型</p>
<p>% 表示所有远程通过 TCP方式的连接</p>
<p>IP 地址 如 (192.168.1.2,127.0.0.1) 通过制定ip地址进行的TCP方式的连接</p>
<p>机器名   通过制定i网络中的机器名进行的TCP方式的连接</p>
<p>::1   IPv6的本地ip地址  等同于IPv4的 127.0.0.1</p>
<p>localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p 123xxx 方式的连接。</p>
<p><strong>User</strong>   表示用户名</p>
<p>同一用户通过不同方式链接的权限是不一样的。</p>
<p><strong>password</strong>   密码</p>
<p>所有密码串通过 password(明文字符串) 生成的密文字符串。加密算法为MYSQLSHA1 ，不可逆 。</p>
<p>mysql 5.7 的密码保存到 authentication_string 字段中，不再使用password 字段。</p>
<p><strong>select_priv , insert_priv</strong>  等为该用户所拥有的权限。</p>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>授予权限：</p>
<p>授权命令： grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’; 该权限如果发现没有该用户，则会直接新建一个用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">delete</span>,<span class="keyword">drop</span> <span class="keyword">on</span> atguigudb.<span class="operator">*</span> <span class="keyword">to</span> li4<span class="variable">@localhost</span>  ;</span><br><span class="line"></span><br><span class="line"> #给li4用户用本地命令行方式下，授予atguigudb这个库下的所有表的插删改查的权限。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> joe@<span class="string">&#x27;%&#x27;</span>  identified <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span>; </span><br><span class="line">#授予通过网络方式登录的的joe用户 </span><br></pre></td></tr></table></figure>
<p>对所有库所有表的全部权限，密码设为123.</p>
<p>收回权限：</p>
<p>查看当前用户权限 show grants;</p>
<p>收回权限命令：<br>revoke  权限1,权限2,…权限n on 数据库名称.表名称  from  用户名@用户地址 ;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mysql.<span class="operator">*</span> <span class="keyword">FROM</span> joe<span class="variable">@localhost</span>;</span><br><span class="line">#收回全库全表的所有权限</span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">ON</span> mysql.<span class="operator">*</span> <span class="keyword">FROM</span> joe<span class="variable">@localhost</span>;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br></pre></td></tr></table></figure>

<p><span style="color:red"> 必须用户重新登录后才能生效</span></p>
<p>查看权限：</p>
<p>查看当前用户权限<br><code>show grants;</code></p>
<p>查看某用户的全局权限<br><code>select  * from user ;</code></p>
<p>查看某用户的某个表的权限<br><code>select * from tables_priv;</code></p>
<h3 id="sql-mode的配置"><a href="#sql-mode的配置" class="headerlink" title="sql_mode的配置"></a>sql_mode的配置</h3><p>MySQL的sql_mode合理设置</p>
<p>sql_mode是个很容易被忽视的变量，默认值是空值，在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题。</p>
<p>show  variables like ‘sql_mode’;</p>
<p>在my.ini文件中，有个sql_mode属性</p>
<p>sql_mode常用值如下：<br>set sql_mode&#x3D;’ONLY_FULL_GROUP_BY’;</p>
<p>ONLY_FULL_GROUP_BY：<br>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</p>
<p>NO_AUTO_VALUE_ON_ZERO：<br>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</p>
<p>STRICT_TRANS_TABLES：<br>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</p>
<p>NO_ZERO_IN_DATE：<br>在严格模式下，不允许日期和月份为零</p>
<p>NO_ZERO_DATE：<br>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p>
<p>ERROR_FOR_DIVISION_BY_ZERO：<br>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL</p>
<p>NO_AUTO_CREATE_USER：<br>禁止GRANT创建密码为空的用户</p>
<p>NO_ENGINE_SUBSTITUTION：<br>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</p>
<p>PIPES_AS_CONCAT：<br>将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</p>
<p>ANSI_QUOTES：<br>启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</p>
<p>ORACLE：<br>  设置等同：PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.</p>
<h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><h4 id="总体概览"><a href="#总体概览" class="headerlink" title="总体概览"></a>总体概览</h4><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p>1.连接层<br> 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2.服务层</p>
<p>2.1  Management Serveices &amp; Utilities： 系统管理和控制工具<br>2.2  SQL Interface: SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface<br>2.3 Parser: 解析器。SQL命令传递到解析器的时候会被解析器验证和解析。<br>2.4 Optimizer: 查询优化器。<br>    SQL语句在查询之前会使用查询优化器对查询进行优化。<br>    用一个例子就可以理解： select uid,name from user where  gender&#x3D;1;<br>    优化器来决定先投影还是先过滤。</p>
<p>2.5 Cache和Buffer： 查询缓存。<br>    如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。<br>    这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
<p>3.引擎层。存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p>
<p>4.存储层。数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
<h4 id="查看sql的执行周期"><a href="#查看sql的执行周期" class="headerlink" title="查看sql的执行周期"></a>查看sql的执行周期</h4><p> 修改配置文件&#x2F;etc&#x2F;my.cnf<br>新增一行：query_cache_type&#x3D;1<br>重启mysql </p>
<p>先开启 show variables  like ‘%profiling%’;<br>set profiling&#x3D;1;</p>
<p>select * from xxx ;</p>
<p><code>show profiles;     #显示最近的几次查询</code></p>
<p><a href="/img/latestquery.png" title="查询" class="gallery-item" style="box-shadow: none;"> <img src="/img/latestquery.png" alt="查询"></a></p>
<p><code>show profile cpu,block io for query 编号  #查看程序的执行步骤</code></p>
<p><a href="/img/procedure.png" title="step" class="gallery-item" style="box-shadow: none;"> <img src="/img/procedure.png" alt="step"></a></p>
<h4 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h4><p>首先，mysql的查询流程大致是：</p>
<ul>
<li><p>mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</p>
</li>
<li><p>语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。mysql解析器将使用mysql语法规则验证和解析查询；预处理器则根据一些mysql规则进一步检查解析数是否合法。</p>
</li>
<li><p>查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</p>
</li>
<li><p>然后，mysql默认使用的BTREE索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</p>
</li>
</ul>
<p>手写SQL执行顺序：</p>
<p><a href="/img/handsql.png" title="hand_sql" class="gallery-item" style="box-shadow: none;"> <img src="/img/handsql.png" alt="hand_sql"></a></p>
<p>机读SQL执行顺序</p>
<p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。</p>
<p>下面是经常出现的查询顺序：<br><a href="/img/machinesql.png" title="hand_sql" class="gallery-item" style="box-shadow: none;"> <img src="/img/machinesql.png" alt="hand_sql"></a></p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><p>如何用命令查看<br>你的mysql现在已提供什么存储引擎:<br>  mysql&gt; show engines;</p>
<p><a href="/img/showengine.png" title="engin" class="gallery-item" style="box-shadow: none;"> <img src="/img/showengine.png" alt="engin"></a></p>
<p><code>  #看你的mysql当前默认的存储引擎:</code><br><code>  mysql&gt; show variables like &#39;%storage_engine%&#39;;</code></p>
<p><a href="/img/defaultengine.png" title="dengin" class="gallery-item" style="box-shadow: none;"> <img src="/img/defaultengine.png" alt="dengin"></a></p>
<h4 id="各种简介"><a href="#各种简介" class="headerlink" title="各种简介"></a>各种简介</h4><p>1、InnoDB存储引擎</p>
<p>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</p>
<p>2、MyISAM存储引擎</p>
<p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
<p>3、Archive引擎</p>
<p>Archive档案存储引擎<strong>只支持INSERT和SELECT操作，不支持UPDATE和DELETE</strong>在MySQL5.1之前不支持索引。<br>Archive表适合日志和数据采集类应用。<br>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</p>
<p>4、Blackhole引擎</p>
<p>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </p>
<p>5、CSV引擎 </p>
<p>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。<br>CSV引擎可以作为一种数据交换的机制，非常有用。<br>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</p>
<p>6、Memory引擎</p>
<p>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。</p>
<p>7、Federated引擎</p>
<p>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</p>
<h4 id="MyISAM-InnoDB"><a href="#MyISAM-InnoDB" class="headerlink" title="MyISAM&#x2F;InnoDB"></a>MyISAM&#x2F;InnoDB</h4><p>主要区别是前四点，重要！！！</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>关注点</td>
<td>节省资源、消耗少、简单业务</td>
<td>并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<p>系统自带的表用MyISAM，不用高并发，但是节省资源</p>
<h4 id="阿里用哪个"><a href="#阿里用哪个" class="headerlink" title="阿里用哪个"></a>阿里用哪个</h4><p><a href="/img/alitb.png" title="alitb" class="gallery-item" style="box-shadow: none;"> <img src="/img/alitb.png" alt="alitb"></a></p>
<ul>
<li><p>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有着很显著的提升。该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</p>
</li>
<li><p>该公司新建了一款存储引擎叫xtradb完全可以替代innodb,并且在性能和并发上做得更好,</p>
</li>
<li><p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p>
</li>
<li><p>AliSql+AliRedis</p>
</li>
</ul>
<h2 id="索引优化分析"><a href="#索引优化分析" class="headerlink" title="索引优化分析"></a>索引优化分析</h2><h3 id="性能下降分析"><a href="#性能下降分析" class="headerlink" title="性能下降分析"></a>性能下降分析</h3><ul>
<li><p>数据过多 -&gt; 分库分表</p>
</li>
<li><p>关联了太多的表，太多的join -&gt; SQL优化</p>
</li>
<li><p>没有充分利用到索引 -&gt; 索引建立</p>
</li>
<li><p>服务器调优及各个参数设置 -&gt; 调整my.cnf&#x2F;my.ini</p>
</li>
</ul>
<h3 id="常见的join查询"><a href="#常见的join查询" class="headerlink" title="常见的join查询"></a>常见的join查询</h3><p>“在我的日常工作中很少用到右外连接，一般都是用左外连接”</p>
<p>MySQL没有全连接（第三行第一个）</p>
<p><a href="/img/join.png" title="join" class="gallery-item" style="box-shadow: none;"> <img src="/img/join.png" alt="join"></a></p>
<h3 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p>索引的本质：数据结构。</p>
<p>索引的目的在于提高查询效率</p>
<p>举例：</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，<br>这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种<strong>可能的</strong>索引方式示例：</p>
<p><a href="/img/index.png" title="index" class="gallery-item" style="box-shadow: none;"> <img src="/img/index.png" alt="index"></a></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址，为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>
<h4 id="优势-劣势"><a href="#优势-劣势" class="headerlink" title="优势&#x2F;劣势"></a>优势&#x2F;劣势</h4><p>优势</p>
<ul>
<li><p>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</p>
</li>
<li><p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</p>
</li>
</ul>
<p>劣势</p>
<ul>
<li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</p>
</li>
<li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</p>
</li>
</ul>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>MySQL 用的<strong>B+Tree</strong></p>
<p>BTree确实效率更高，但是每个节点都有一个指针，占用的内存大了。</p>
<p><strong>BTree</strong></p>
<p><a href="/img/essencial.png" title="BTree" class="gallery-item" style="box-shadow: none;"> <img src="/img/essencial.png" alt="BTree"></a></p>
<p>【初始化介绍】</p>
<p>一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p>
<p>非叶子节点不存储真实的数据，只存储<strong>指引搜索方向</strong>的数据项，如17、35并不真实存在于数据表中。</p>
<p>【查找过程】</p>
<p>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p>
<p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p><strong>B+Tree</strong></p>
<p><a href="/img/essencial1.png" title="BTree" class="gallery-item" style="box-shadow: none;"> <img src="/img/essencial1.png" alt="BTree"></a></p>
<p><strong>B+Tree与B-Tree 的区别</strong></p>
<p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</p>
<p>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。 </p>
<p>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p>
<ol>
<li><p>B+树的磁盘读写代价更低<br>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 </p>
</li>
<li><p>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
<p><strong>时间复杂度</strong></p>
<p><a href="/img/timecplx1.png" title="time1" class="gallery-item" style="box-shadow: none;"> <img src="/img/timecplx1.png" alt="time1"></a></p>
<p><a href="/img/timecplx2.png" title="time2" class="gallery-item" style="box-shadow: none;"> <img src="/img/timecplx2.png" alt="time2"></a></p>
<p><strong>聚簇索引与非聚簇索引</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。</p>
<p>如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。</p>
<p><a href="/img/cluster.png" title="聚簇" class="gallery-item" style="box-shadow: none;"> <img src="/img/cluster.png" alt="聚簇"></a></p>
<p>聚簇索引的好处：</p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的io操作。</p>
<p>聚簇索引的限制：</p>
<p>对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。</p>
<p>由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。</p>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p><strong>基本语法</strong></p>
<p>创建  CREATE INDEX [indexName] ON table_name(column))</p>
<p>删除  DROP INDEX [indexName] ON mytable; </p>
<p>查看  SHOW INDEX FROM table_name;</p>
<p>使用ALTER命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有四种方式来添加数据表的索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (column_list): </span><br><span class="line">该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="keyword">NULL</span>。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name (column_list):</span><br><span class="line">这条语句创建索引的值必须是唯一的（除了<span class="keyword">NULL</span>外，<span class="keyword">NULL</span>可能会出现多次）。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX index_name (column_list): </span><br><span class="line">添加普通索引，索引值可出现多次。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> FULLTEXT index_name (column_list):</span><br><span class="line">该语句指定了索引为 FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure>

<p><strong>单值索引</strong></p>
<p>即一个索引只包含单个列，一个表可以有多个单列索引</p>
<p>CREATE INDEX [indexName] ON table_name(column))</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name)</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line">单独建单值索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_customer_name <span class="keyword">ON</span> customer(customer_name); </span><br><span class="line"> </span><br><span class="line">删除索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_name  <span class="keyword">on</span> customer;</span><br></pre></td></tr></table></figure>

<p><strong>唯一索引</strong></p>
<p>索引列的值必须唯一，但允许有空值</p>
<p>CREATE  UNIQUE  INDEX [indexName] ON table_name(column))</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">单独建唯一索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_customer_no <span class="keyword">ON</span> customer(customer_no); </span><br><span class="line"> </span><br><span class="line">删除索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_customer_no <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure>

<p><strong>主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">随表一起建索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id) </span><br><span class="line">);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer2 (id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED   ,customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id) </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> 单独建主键索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer </span><br><span class="line"> <span class="keyword">add</span> <span class="keyword">PRIMARY</span> KEY customer(customer_no);  </span><br><span class="line"> </span><br><span class="line">删除建主键索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer </span><br><span class="line"> <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;  </span><br><span class="line"> </span><br><span class="line">修改建主键索引：</span><br><span class="line"></span><br><span class="line">必须先删除掉(<span class="keyword">drop</span>)原索引，再新建(<span class="keyword">add</span>)索引</span><br></pre></td></tr></table></figure>


<p><strong>复合索引</strong></p>
<p>即一个索引包含多个列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 随表一起建索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED  AUTO_INCREMENT ,customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">  KEY (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_name),</span><br><span class="line">  KEY (customer_no,customer_name)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">单独建索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_no_name <span class="keyword">ON</span> customer(customer_no,customer_name); </span><br><span class="line"> </span><br><span class="line">删除索引：</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_no_name  <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure>

<h4 id="创建索引的情况"><a href="#创建索引的情况" class="headerlink" title="创建索引的情况"></a>创建索引的情况</h4><p>哪些情况需要创建索引</p>
<ul>
<li><p>主键自动建立唯一索引</p>
</li>
<li><p>频繁作为查询条件的字段应该创建索引</p>
</li>
<li><p>查询中与其它表关联的字段，外键关系建立索引</p>
</li>
<li><p>单键&#x2F;组合索引的选择问题， 组合索引性价比更高</p>
</li>
<li><p>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>
</li>
<li><p>查询中统计或者分组字段</p>
</li>
</ul>
<p>哪些情况不要创建索引</p>
<ul>
<li><p>表记录太少</p>
</li>
<li><p>经常增删改的表或者字段</p>
<ul>
<li>Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</li>
</ul>
</li>
<li><p>Where条件里用不到的字段不创建索引</p>
</li>
<li><p>过滤性不好的不适合建索引</p>
</li>
</ul>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>查看执行计划</p>
<p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是<br>如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<h4 id="能干啥"><a href="#能干啥" class="headerlink" title="能干啥"></a>能干啥</h4><ul>
<li><p>表的读取顺序</p>
</li>
<li><p>哪些索引可以使用</p>
</li>
<li><p>数据读取操作的操作类型</p>
</li>
<li><p><span style = "color:red">哪些索引被实际使用</span></p>
</li>
<li><p>表之间的引用</p>
</li>
<li><p><span style = "color:red">每张表有多少行被物理查询</span></p>
</li>
</ul>
<h4 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h4><p>EXPLAIN 加上要查看的完整语句的执行计划</p>
<h4 id="字段的解释"><a href="#字段的解释" class="headerlink" title="字段的解释"></a>字段的解释</h4><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<p>三种情况</p>
<ul>
<li>id相同，执行顺序由上至下</li>
</ul>
<p><a href="/img/idsanme.png" title="ids" class="gallery-item" style="box-shadow: none;"> <img src="/img/idsanme.png" alt="ids"></a></p>
<ul>
<li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
</ul>
<p><a href="/img/idunsame.png" title="ids" class="gallery-item" style="box-shadow: none;"> <img src="/img/idunsame.png" alt="ids"></a></p>
<ul>
<li>id相同不同，同时存在。id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行（衍生 &#x3D; DERIVED）</li>
</ul>
<p><a href="/img/idmix.png" title="ids" class="gallery-item" style="box-shadow: none;"> <img src="/img/idmix.png" alt="ids"></a></p>
<p><strong>关注点</strong>：</p>
<ul>
<li>id号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</li>
</ul>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p><a href="/img/selecttype.png" title="selecttype" class="gallery-item" style="box-shadow: none;"> <img src="/img/selecttype.png" alt="selecttype"></a></p>
<p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p>
<p>SIMPLE</p>
<ul>
<li>简单的 select 查询,查询中不包含子查询或者UNION</li>
</ul>
<p><a href="/img/simple.png" title="simple" class="gallery-item" style="box-shadow: none;"> <img src="/img/simple.png" alt="simple"></a></p>
<p>PRIMARY</p>
<ul>
<li>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li>
</ul>
<p><a href="/img/primary.png" title="primary" class="gallery-item" style="box-shadow: none;"> <img src="/img/primary.png" alt="primary"></a></p>
<p>DERIVED</p>
<ul>
<li>在FROM列表中包含的子查询被标记为DERIVED(衍生) MySQL会递归执行这些子查询, 把结果放在临时表里。</li>
</ul>
<p><a href="/img/derived.png" title="derived" class="gallery-item" style="box-shadow: none;"> <img src="/img/derived.png" alt="derived"></a></p>
<p>SUBQUERY</p>
<ul>
<li>在SELECT或WHERE列表中包含了子查询</li>
</ul>
<p><a href="/img/subquery.png" title="subquery" class="gallery-item" style="box-shadow: none;"> <img src="/img/subquery.png" alt="subquery"></a></p>
<p>DEPENDENT SUBQUERY</p>
<ul>
<li>依赖子查询，在SELECT或WHERE列表中包含了子查询,子查询基于外层（in）</li>
</ul>
<p><a href="/img/depsub.png" title="depsub" class="gallery-item" style="box-shadow: none;"> <img src="/img/depsub.png" alt="depsub"></a></p>
<p>UNCACHEABLE SUBQUREY  </p>
<ul>
<li>不可用缓存的子查询（SQL肯定不一样的）</li>
</ul>
<p><a href="/img/uncacheable.png" title="uncacheable" class="gallery-item" style="box-shadow: none;"> <img src="/img/uncacheable.png" alt="uncacheable"></a></p>
<p>SHOW VARIABLES LIKE ‘%lower_case_table_names%’;</p>
<p>SELECT @@lower_case_table_names FROM DUAL;</p>
<p>出现@@，为MySQL的系统变量<br>出现@ 为</p>
<p>UNION</p>
<ul>
<li>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li>
</ul>
<p><a href="/img/unoin.png" title="union" class="gallery-item" style="box-shadow: none;"> <img src="/img/unoin.png" alt="union"></a></p>
<p>UNION RESULT</p>
<ul>
<li>从UNION表获取结果的SELECT</li>
</ul>
<p><a href="/img/usort.png" title="usort" class="gallery-item" style="box-shadow: none;"> <img src="/img/usort.png" alt="usort"></a></p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><ul>
<li>代表分区表中的命中情况，非分区表，该项为null</li>
</ul>
<h5 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h5><ul>
<li>显示这一行的数据是关于哪张表的</li>
</ul>
<h5 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h5><p>避免出现全表扫描</p>
<p>类型：all, index, range, ref, eq_ref, const, system, null</p>
<p>type显示的是访问类型，是较为重要的一个指标，结果值从<span style="color:red">最好到最坏</span>依次是： </p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <span style="color:yellow">range</span> &gt; <span style="color:orange">index</span> &gt; <span style="color:red">ALL</span></p>
<p>简而言之：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p>system</p>
<ul>
<li>表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li>
</ul>
<p>const</p>
<ul>
<li>表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快 如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>
</ul>
<p><a href="/img/const.png" title="const" class="gallery-item" style="box-shadow: none;"> <img src="/img/const.png" alt="const"></a></p>
<p>eq_ref</p>
<ul>
<li>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
</ul>
<p>疑问：为啥t1是all的？</p>
<p><a href="/img/eq_ref.png" title="eq_ref" class="gallery-item" style="box-shadow: none;"> <img src="/img/eq_ref.png" alt="eq_ref"></a></p>
<p>ref</p>
<ul>
<li>非唯一性索引扫描，返回匹配某个单独值的所有行. 本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， 它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>
</ul>
<p><a href="/img/ref.png" title="ref" class="gallery-item" style="box-shadow: none;"> <img src="/img/ref.png" alt="ref"></a></p>
<p><span style="color:yellow">range</span></p>
<ul>
<li>只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引 一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询 这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>
</ul>
<p><a href="/img/range.png" title="ref" class="gallery-item" style="box-shadow: none;"> <img src="/img/range.png" alt="ref"></a></p>
<p><span style="color:orange">index</span></p>
<ul>
<li>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</li>
</ul>
<p><a href="/img/indextype.png" title="indextype" class="gallery-item" style="box-shadow: none;"> <img src="/img/indextype.png" alt="indextype"></a></p>
<p><span style="color:red">all</span></p>
<ul>
<li>Full Table Scan，将遍历全表以找到匹配的行</li>
</ul>
<p><a href="/img/all.png" title="indextype" class="gallery-item" style="box-shadow: none;"> <img src="/img/all.png" alt="indextype"></a></p>
<p>index_merge</p>
<ul>
<li>在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</li>
</ul>
<p><a href="/img/indexmerge.png" title="indexmerge" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexmerge.png" alt="indexmerge"></a></p>
<p>ref_or_null</p>
<ul>
<li>对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</li>
</ul>
<p><a href="/img/refornull.png" title="refornull" class="gallery-item" style="box-shadow: none;"> <img src="/img/refornull.png" alt="refornull"></a></p>
<p>index_subquery</p>
<ul>
<li>利用索引来关联子查询，不再全表扫描。</li>
</ul>
<p><a href="/img/indexsub.png" title="indexsub" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexsub.png" alt="indexsub"></a></p>
<p>unique_subquery </p>
<ul>
<li>该联接类型类似于index_subquery。 子查询中的唯一索引</li>
</ul>
<p><a href="/img/unique.png" title="indexsub" class="gallery-item" style="box-shadow: none;"> <img src="/img/unique.png" alt="indexsub"></a></p>
<p><span style="color:red">备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</span></p>
<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引，一个或多个。</p>
<p>查询涉及到的字段上若存在索引，则该索引将被列出，<span style="color:red">但不一定被查询实际使用</span></p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>实际使用的索引。如果为NULL，则没有使用索引</p>
<p>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p>
<p><a href="/img/key.png" title="key" class="gallery-item" style="box-shadow: none;"> <img src="/img/key.png" alt="key"></a></p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>理解：where 后面的筛选条件命中索引的长度，越大越好</p>
<p>key_len字段能够帮你检查是否充分的利用上了索引</p>
<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 </p>
<p>例如：</p>
<p>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age&#x3D;30 AND emp.name LIKE ‘ab%’;</p>
<p>67的（上面的）比较好</p>
<p><a href="/img/keylen1.png" title="keylen1" class="gallery-item" style="box-shadow: none;"> <img src="/img/keylen1.png" alt="keylen1"></a></p>
<p>如何计算<br>1、先看索引上字段的类型+长度比如 int&#x3D;4 ;  varchar(20) &#x3D;20 ; char(20) &#x3D;20<br>2、如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8  要乘 3,GBK要乘2，<br>3、varchar这种动态字符串要加2个字节<br>4、 允许为空的字段要加1个字节  </p>
<p><a href="/img/keylen2.png" title="keylen2" class="gallery-item" style="box-shadow: none;"> <img src="/img/keylen2.png" alt="keylen2"></a></p>
<p>第一组</p>
<p>key_len&#x3D;age的字节长度+name的字节长度&#x3D;4+1  + ( 20*3+2)&#x3D;5+62&#x3D;67</p>
<p>int本身长度为4（字节），如果可以为null，则+1 ， 所以是5</p>
<p>varchar的长度就是位数20，再看字符集，如果是gbk就 * 2，utf8就 * 3，如果长度可变，就再加 2 </p>
<p>所以是20*3+ 2</p>
<p>第二组</p>
<p>key_len&#x3D;age的字节长度&#x3D;4+1&#x3D;5</p>
<p><a href="/img/keylen3.png" title="keylen3" class="gallery-item" style="box-shadow: none;"> <img src="/img/keylen3.png" alt="keylen3"></a></p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
<p><a href="/img/ref-1666434653004-42.png" title="ref" class="gallery-item" style="box-shadow: none;"> <img src="/img/ref-1666434653004-42.png" alt="ref"></a></p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>rows列显示MySQL认为它执行查询时必须检查的行数。（整个SQL物理扫描的行数，<strong>越少越好</strong>）</p>
<p><a href="/img/rows.png" title="rows" class="gallery-item" style="box-shadow: none;"> <img src="/img/rows.png" alt="rows"></a></p>
<h5 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h5><p>这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<p><span style="color:red"><strong>Using filesort</strong>（要你命三千！)</span></p>
<p>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。 MySQL中无法利用索引完成的排序操作称为“文件排序”，说明order by 没有用上索引</p>
<p>出现了filesort的情况：</p>
<p><a href="/img/filesort1.png" title="filesort1" class="gallery-item" style="box-shadow: none;"> <img src="/img/filesort1.png" alt="filesort1"></a></p>
<p>优化后的情况</p>
<p><a href="/img/filesort2.png" title="filesort2" class="gallery-item" style="box-shadow: none;"> <img src="/img/filesort2.png" alt="filesort2"></a></p>
<ul>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li>
</ul>
<p><span style="color:red"><strong>Using temporary（要你命三万！！！！）</strong></span></p>
<p>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。（group by没有用上索引）常见于排序 order by 和分组查询 group by。（group by包含一个order by）</p>
<p>优化前存在 using  temporary 和 using  filesort</p>
<p><a href="/img/temp1.png" title="temp1" class="gallery-item" style="box-shadow: none;"> <img src="/img/temp1.png" alt="temp1"></a></p>
<p>优化前存在的 using  temporary 和 using  filesort 不在，性能发生明显变化：</p>
<p><a href="/img/temp2.png" title="temp2" class="gallery-item" style="box-shadow: none;"> <img src="/img/temp2.png" alt="temp2"></a></p>
<p><strong>USING index</strong></p>
<p>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现using where，表明索引被用来执行索引键值的查找; 如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。<br>利用索引进行了排序或分组</p>
<p><strong>Using where</strong></p>
<p>表明使用了where过滤</p>
<p><span style="color:red"><strong>using join buffer</strong></span></p>
<p>使用了连接缓存</p>
<p><a href="/img/joinbuffer.png" title="joinbuffer" class="gallery-item" style="box-shadow: none;"> <img src="/img/joinbuffer.png" alt="joinbuffer"></a></p>
<p><strong>impossible where</strong></p>
<p>where子句的值总是false，不能用来获取任何元组，说明SQL写错了。</p>
<p><a href="/img/where.png" title="joinbuffer" class="gallery-item" style="box-shadow: none;"> <img src="/img/where.png" alt="joinbuffer"></a></p>
<p><strong>select tables optimized away</strong></p>
<p>在没有GROUPBY子句的情况下，基于索引优化MIN&#x2F;MAX操作或者 对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。</p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h4><p><strong>【思考题】怎样往一张表中插入数据更快？</strong></p>
<ul>
<li><p>一个语句中插入多行数据</p>
</li>
<li><p>插入之前，删除除了主键索引之外的所有索引</p>
</li>
<li><p>关闭自动提交，使用事务机制</p>
</li>
</ul>
<p>MySQL默认不能自己编写函数，show variables like ‘log_bin_trust_function_creators’;<br>执行结果为 0，说明不允许</p>
<p>这时候我们要自己打开，set global log_bin_trust_function_creators&#x3D;1;</p>
<p>这样设置过后，如果MySQL重启参数就会消失，一劳永逸的方法：</p>
<p>windows下my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1 </p>
<p>linux下    &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1</p>
<p>直接修改配置文件</p>
<p><span style="color:red"> <strong>所有的有关于sql编程的相关知识都不用看，那是运维人员的事情，和我们无关。在面试的时候可以这样说“运维人员写的时候我看过一些，但是不太了解”</strong> </span></p>
<p><strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> ceo <span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line"> `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `empno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#创建名字的函数</span><br><span class="line"></span><br><span class="line">DELIMITER $$ #指定函数结束符为 $$，表示输入$$的时候函数结束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #函数名，参数，返回值</span><br><span class="line"><span class="keyword">BEGIN</span>    #函数开始</span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>; </span><br><span class="line">#声明一个变量，默认为引号中的字符</span><br><span class="line"> <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">#声明要返回的字符串</span><br><span class="line"> <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> WHILE i <span class="operator">&lt;</span> n DO  #开始循环，n是传入的参数，表示字符串的长度</span><br><span class="line"> <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">END</span> WHILE;</span><br><span class="line"> <span class="keyword">RETURN</span> return_str; #返回名字</span><br><span class="line"><span class="keyword">END</span> $$ #函数结束</span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_string;</span><br><span class="line"></span><br><span class="line">#<span class="comment">------------------------------------</span></span><br><span class="line"></span><br><span class="line">#用于随机产生多少到多少的编号的函数</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span>  rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>   </span><br><span class="line"> <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span>from_num<span class="operator">+</span><span class="number">1</span>));</span><br><span class="line"> #初始值到结束值之间随机生成一个数字</span><br><span class="line"><span class="keyword">RETURN</span> i;  </span><br><span class="line"> <span class="keyword">END</span>$$ </span><br><span class="line"> </span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_num;</span><br><span class="line"></span><br><span class="line">#<span class="comment">------------------------------------</span></span><br><span class="line"></span><br><span class="line">#向emp表中插入数据</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_emp(<span class="keyword">START</span> <span class="type">INT</span> ,  max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    #把autocommit设置成<span class="number">0</span>  </span><br><span class="line">REPEAT  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, NAME ,age ,deptid ) <span class="keyword">VALUES</span> ((<span class="keyword">START</span><span class="operator">+</span>i) ,rand_string(<span class="number">6</span>)   , rand_num(<span class="number">30</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">10000</span>));  </span><br><span class="line">UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"><span class="keyword">END</span> REPEAT;  </span><br><span class="line"><span class="keyword">COMMIT</span>;  </span><br><span class="line"><span class="keyword">END</span>$$ </span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line"># DELIMITER ;</span><br><span class="line"># <span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_emp;</span><br><span class="line"></span><br><span class="line">#<span class="comment">------------------------------------</span></span><br><span class="line"></span><br><span class="line">#执行存储过程，往dept表添加随机数据</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_dept`(  max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"> REPEAT  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept ( deptname,address,ceo ) <span class="keyword">VALUES</span> (rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num(<span class="number">1</span>,<span class="number">500000</span>));  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>;  </span><br><span class="line"> <span class="keyword">END</span>$$</span><br><span class="line"> </span><br><span class="line">#删除</span><br><span class="line"># DELIMITER ;</span><br><span class="line"># <span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_dept;</span><br><span class="line"></span><br><span class="line"> #执行存储过程，往dept表添加<span class="number">1</span>万条数据（<span class="number">3.5</span>秒左右）</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">10000</span>); </span><br><span class="line"></span><br><span class="line">#执行存储过程，往emp表添加<span class="number">50</span>万条数据（<span class="number">89</span>秒左右）</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100000</span>,<span class="number">500000</span>); </span><br><span class="line"></span><br><span class="line">#<span class="comment">------------------------------------</span></span><br><span class="line"></span><br><span class="line">#批量删除表上的所有索引</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>),tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="keyword">SELECT</span>   index_name   <span class="keyword">FROM</span> information_schema.STATISTICS   <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span>    index_name <span class="operator">&lt;&gt;</span><span class="string">&#x27;PRIMARY&#x27;</span>  ;</span><br><span class="line">       <span class="keyword">DECLARE</span>  CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done<span class="operator">=</span><span class="number">2</span> ;      </span><br><span class="line">        <span class="keyword">OPEN</span> _cur;</span><br><span class="line">        <span class="keyword">FETCH</span>   _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">        WHILE  _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO </span><br><span class="line">               <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename ); </span><br><span class="line">               <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span> ;</span><br><span class="line">               <span class="keyword">EXECUTE</span>  sql_str;</span><br><span class="line">               <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">               <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>; </span><br><span class="line">               <span class="keyword">FETCH</span>   _cur <span class="keyword">INTO</span> _index; </span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">   <span class="keyword">CLOSE</span> _cur;</span><br><span class="line">   <span class="keyword">END</span>$$</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>如何删除索引</strong></p>
<p>CREATE X</p>
<p>DROP INDEX idx_xxx ON emp</p>
<p>1 查出该表有哪些索引，索引名–&gt;集合</p>
<p>SHOW INDEX FROM t_emp<br>元数据：meta DATA  描述数据的数据</p>
<p>SELECT index_name  FROM information_schema.STATISTICS WHERE table_name&#x3D;’t_emp’ AND table_schema&#x3D;’mydb’<br> AND index_name &lt;&gt;’PRIMARY’ AND seq_in_index &#x3D; 1</p>
<p>2 如何循环集合<br> CURSOR 游标<br> FETCH xxx INTO xxx</p>
<p>3 如何让mysql执行一个字符串<br>PREPARE 预编译 XXX</p>
<p>EXECUTE</p>
<p>CALL proc_drop_index (‘mydb’,’t_emp’);</p>
<h4 id="单表索引及索引失效"><a href="#单表索引及索引失效" class="headerlink" title="单表索引及索引失效"></a>单表索引及索引失效</h4><p>在产品经理提出了一个几乎不可能实现的需求的时候，我们能做的是尽量把选择权交到产品经理手中。比如：</p>
<p>“在我们的项目中添加一个功能：能够显示或者查询不等于某个值的数据条目。”</p>
<p>“这个功能是可以实现的，但是在实现之后，在查询的时候会变慢，慢很多，这个是系统特性的问题，您说我们是做还是不做呢？”</p>
<p><a href="/img/singlemap.png" title="singlemap" class="gallery-item" style="box-shadow: none;"> <img src="/img/singlemap.png" alt="singlemap"></a></p>
<p><strong>单表索引的查询原理</strong></p>
<p><a href="/img/singletable.png" title="single" class="gallery-item" style="box-shadow: none;"> <img src="/img/singletable.png" alt="single"></a></p>
<p><strong>索引失效的案例</strong></p>
<p><strong>全值匹配我最爱–建立索引</strong></p>
<p> 系统中经常出现的sql语句如下： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">and</span> deptid<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>索引应该如何建立 ？</p>
<p><code>CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME)</code></p>
<p><a href="/img/allmach.png" title="allmach" class="gallery-item" style="box-shadow: none;"> <img src="/img/allmach.png" alt="allmach"></a></p>
<p><strong>最佳左前缀法则</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<p>如果系统经常出现的sql如下：</p>
<p><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30   AND emp.name = &#39;abcd&#39;</code></p>
<p>或者</p>
<p><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.deptid=1   AND emp.name = &#39;abcd&#39;</code></p>
<p>那原来的idx_age_deptid_name 还能否正常使用？</p>
<p>建立索引：<br><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30   AND emp.name = &#39;abcd&#39;</code></p>
<p>情况1：</p>
<p><a href="/img/indexnotwork1.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork1.png"></a></p>
<p>虽然可以正常使用，但是只有部分被使用到了。</p>
<p><a href="/img/indexnotwork2.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork2.png"></a></p>
<p>完全没有使用上索引。</p>
<p>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</p>
<p><strong>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</strong></p>
<p>在有索引的情况下这两条sql哪种写法更好</p>
<p><code>EXPLAIN  SELECT SQL_NO_CACHE * FROM emp WHERE   emp.name  LIKE &#39;abc%&#39; </code></p>
<p><code>EXPLAIN   SELECT SQL_NO_CACHE * FROM emp WHERE   LEFT(emp.name,3)  = &#39;abc&#39;</code></p>
<p>情况1：</p>
<p><a href="/img/indexnotwork3.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork3.png"></a></p>
<p>情况2：</p>
<p><a href="/img/indexnotwork4.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork4.png"></a></p>
<p>显然第一种更好</p>
<p><strong>存储引擎不能使用索引中范围条件（大于小于的筛选）右边的列</strong></p>
<p>如果系统经常出现的sql如下：</p>
<p><code>EXPLAIN SELECT  SQL_NO_CACHE * FROM emp WHERE emp.age=30 AND emp.deptId&gt;20 AND emp.name = &#39;abc&#39; ;</code></p>
<p>那么索引 idx_age_deptid_name这个索引还能正常使用么？</p>
<p><a href="/img/indexnotwork5.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork5.png"></a></p>
<p>如果这种sql 出现较多<br>应该建立： </p>
<p><code>create index idx_age_name_deptid on emp(age,name,deptid)</code></p>
<p>效果</p>
<p><a href="/img/indexnotwork6.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork6.png"></a></p>
<p><strong>mysql 在使用不等于(!&#x3D; 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</strong></p>
<p><code>CREATE INDEX idx_name ON emp(NAME)</code></p>
<p><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE   emp.name &lt;&gt;  &#39;abc&#39; </code></p>
<p><a href="/img/indexnotwork7.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork7.png"></a></p>
<p><strong>is not null 也无法使用索引,但是is null是可以使用索引的</strong></p>
<p><code>UPDATE emp SET age =NULL WHERE id=123456;</code></p>
<p>下列哪个sql语句可以用到索引</p>
<p><code>EXPLAIN SELECT * FROM emp WHERE age IS NULL</code></p>
<p><code>EXPLAIN SELECT * FROM emp WHERE age IS NOT NULL</code></p>
<p><a href="/img/indexnotwork8.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork8.png"></a></p>
<p><strong>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</strong></p>
<p><a href="/img/indexnotwork9.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork9.png"></a></p>
<p><strong>字符串不加单引号索引失效</strong></p>
<p><a href="/img/indexnotwork10.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/indexnotwork10.png"></a></p>
<p>小总结</p>
<p>假设<code>index(a,b,c)</code></p>
<table>
<thead>
<tr>
<th>where语句</th>
<th>索引是否被使用</th>
</tr>
</thead>
<tbody><tr>
<td>where a &#x3D; 3</td>
<td>Y,使用到a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5</td>
<td>Y,使用到a，b</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5 and c &#x3D; 4</td>
<td>Y,使用到a,b,c</td>
</tr>
<tr>
<td>where b &#x3D; 3 或者 where b &#x3D; 3 and c &#x3D; 4  或者 where c &#x3D; 4</td>
<td>N</td>
</tr>
<tr>
<td>where a &#x3D; 3 and c &#x3D; 5</td>
<td>使用到a， 但是c不可以，b中间断了</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &gt; 4 and c &#x3D; 5</td>
<td>使用到a和b， c不能用在范围之后，b断了</td>
</tr>
<tr>
<td>where a is null and b is not null</td>
<td>is null 支持索引 但是is not null 不支持,所以 a 可以使用索引,但是  b不可以使用</td>
</tr>
<tr>
<td>where a &lt;&gt; 3</td>
<td>不能使用索引</td>
</tr>
<tr>
<td>where   abs(a) &#x3D;3</td>
<td>不能使用 索引</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘kk%’ and c &#x3D; 4</td>
<td>Y,使用到a,b,c</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘%kk’ and c &#x3D; 4</td>
<td>Y,只用到a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘%kk%’ and c &#x3D; 4</td>
<td>Y,只用到a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘k%kk%’ and c &#x3D; 4</td>
<td>Y,使用到a,b,c（首字母都能用上）</td>
</tr>
</tbody></table>
<p><strong>一般性建议</strong></p>
<ul>
<li><p>对于单键索引，尽量选择针对当前query过滤性更好的索引</p>
</li>
<li><p>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p>
</li>
<li><p>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引（最好能用上所有的索引）</p>
</li>
<li><p>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</p>
</li>
<li><p>书写sql语句时，尽量避免造成索引失效的情况</p>
</li>
</ul>
<h4 id="关联-子查询查询优化"><a href="#关联-子查询查询优化" class="headerlink" title="关联&#x2F;子查询查询优化"></a>关联&#x2F;子查询查询优化</h4><p><a href="/img/double.png" title="single" class="gallery-item" style="box-shadow: none;"> <img src="/img/double.png" alt="single"></a></p>
<p><strong>关联查询优化</strong></p>
<p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `class` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `book` (</span><br><span class="line">`bookid` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>))); #<span class="number">20</span>个这句话</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));  #<span class="number">20</span>个这句话</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 下面开始explain分析</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card <span class="operator">=</span> book.card;</span><br><span class="line">#结论：type 有<span class="keyword">All</span></span><br><span class="line"> </span><br><span class="line"># 添加索引优化</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `book` <span class="keyword">ADD</span> INDEX Y ( `card`);</span><br><span class="line"> </span><br><span class="line">#换成<span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> class <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"># 第<span class="number">2</span>次explain</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card <span class="operator">=</span> book.card;</span><br><span class="line">#可以看到第二行的 type 变为了 <span class="keyword">ref</span>,<span class="keyword">rows</span> 也变成了优化比较明显。</span><br><span class="line">#这是由左连接特性决定的。<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 条件用于确定如何从右表搜索行,左边一定都有,</span><br><span class="line">#所以右边是我们的关键点,一定需要建立索引。</span><br><span class="line"> </span><br><span class="line"># 删除旧索引 <span class="operator">+</span> 新建 <span class="operator">+</span> 第<span class="number">3</span>次explain</span><br><span class="line"><span class="keyword">DROP</span> INDEX Y <span class="keyword">ON</span> book;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> class <span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure>

<p>建议</p>
<p>1、保证被驱动表的join字段已经被索引。</p>
<p>2、left join 时，选择小表作为驱动表，大表作为被驱动表。</p>
<p>3、inner join 时，mysql会自己帮你把小结果集的表选为驱动表。</p>
<p>4、子查询尽量不要放在被驱动表，有可能使用不到索引。</p>
<p>5、能够直接多表关联的尽量直接关联，不用子查询。</p>
<p><strong>子查询优化</strong></p>
<p>尽量不要使用 not in  或者 not exists</p>
<p>取所有不为掌门人的员工，按年龄分组 ，每个年龄段多少人</p>
<p><code> SELECT SQL_NO_CACHE age,count(*)  FROM emp a WHERE  id  NOT  IN(SELECT ceo FROM dept b2 WHERE ceo IS NOT NULL) group by age  having count(*)&lt;10000</code></p>
<p><a href="/img/subqueryup.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/subqueryup.png"></a></p>
<p>用left outer join  on  xxx is null 替代</p>
<p><code>  EXPLAIN SELECT SQL_NO_CACHE age,count(*) FROM  emp a LEFT OUTER JOIN dept b ON a.id =b.ceo  WHERE    b.ceo IS   NULL  group by age   having count(*)&lt;10000</code></p>
<p><a href="/img/subqueryup2.png" class="gallery-item" style="box-shadow: none;"> <img src="/img/subqueryup2.png"></a></p>
<p>inner join ， MySQL自己选择驱动表和被驱动表，优先将有索引的设置为被驱动表（比较好）</p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2020-09-20</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2020/10/03/Maven/'>笔记 | Maven</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2020/08/20/MySQL/">笔记 | MySQL</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
             

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>Change And Challenge</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>