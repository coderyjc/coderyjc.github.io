<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="笔记 | JavaSE" />
    <meta name="hexo-theme-A4" content="v1.9.6" />
    <link rel="alternate icon" type="image/webp" href="/img/avatar.png">
    <title>Jingcun Yan</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/avatar.png" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jingcun Yan</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    笔记 | JavaSE
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                
                    
                     <span>字数总计：89.1k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：361分钟</span>
                
                
            </div>
    

    <div class="post-md">
        
        <div class=".article-gallery"><h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a>Java开发环境</h2><h3 id="Java语言的特性"><a href="#Java语言的特性" class="headerlink" title="Java语言的特性"></a>Java语言的特性</h3><h4 id="1-简单性（相对于C-）"><a href="#1-简单性（相对于C-）" class="headerlink" title="1.简单性（相对于C++）"></a>1.简单性（相对于C++）</h4><p>在Java语言当中真正操作内存的是JVM（Java Virtual Machine）Java虚拟机</p>
<p>所有的java程序都是运行在Java虚拟机当中的, Java语言<strong>屏蔽了指针概念</strong>，程序员<em>不能直接操作指针</em>，或者说程序员不能直接操作内存。这种方式有优点也有缺点：</p>
<p>优点：不容易导致内存泄漏</p>
<p>缺点：效率问题(但是可以通过更换更强大的硬件来解决)</p>
<h4 id="2-完全面向对象"><a href="#2-完全面向对象" class="headerlink" title="2.完全面向对象"></a>2.完全面向对象</h4><p>面向对象三大特性: 封装，继承，多态</p>
<p>面向对象更容易让人理解，人类通常是以对象的方式认知世界的。</p>
<h4 id="3-健壮性"><a href="#3-健壮性" class="headerlink" title="3.健壮性"></a>3.健壮性</h4><p>Java中有一种机制：自动垃圾回收机制（GC机制 Garbage Collection）</p>
<p>Java 程序启动了一个单独的垃圾回收线程，时刻监测内存使用情况，在特定时机会回收&#x2F;释放垃圾数据，这样会让内存时刻处于最好的状态, 关于这个机制, 我们会在Java进阶篇中讲解.</p>
<p>相对于C语言来说，java语言是健壮的, 因为Java不容易导致内存的泄漏, C++或者C语言需要程序员自己分配内存, 在使用不当时很容易导致内存泄漏。</p>
<blockquote>
<p>内存泄漏: 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。(来自百度百科: <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/6181425">内存泄漏</a>)</p>
</blockquote>
<p><strong>JVM</strong>负责调度GC机制。程序员不需要干涉。</p>
<p>缺点：内存无法得到及时的清理, (但是我们可以手动调用清理机制)</p>
<h4 id="4-java完美支持多线程并发。"><a href="#4-java完美支持多线程并发。" class="headerlink" title="4.java完美支持多线程并发。"></a>4.java完美支持多线程并发。</h4><h4 id="5-可移植性-跨平台"><a href="#5-可移植性-跨平台" class="headerlink" title="5.可移植性&#x2F;跨平台"></a>5.可移植性&#x2F;跨平台</h4><p>java语言只要编写一次，可以做到到处运行。</p>
<p>例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linux操作系统上，同样也可以运行到MaC OS上面。</p>
<p>一次编写，到处运行。（平台改变了，程序不需要改。）</p>
<p>JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？</p>
<ul>
<li>优点：一次编写到处运行，可以<strong>跨平台</strong>。</li>
<li>缺点：麻烦。对于运行java程序来说必须先有一个JVM，也就是需要安装JRE。</li>
</ul>
<h3 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h3><ul>
<li><p>JDK（Java Development Kit）:Java开发工具箱</p>
</li>
<li><p>JRE（Java Runtime Environment，Java 运行环境）:java运行环境</p>
</li>
<li><p>JVM（Java Virtual Machine）:java虚拟机</p>
</li>
<li><p>JDK包括JRE，JRE包括JVM。</p>
</li>
</ul>
<p>JVM是不能独立安装的。JRE和JDK都可以独立安装。</p>
<p>安装JDK的时候，JRE就自动安装了，同时JRE内部的JVM也就自动安装了。安装JRE的时候，JVM也就自动安装了。</p>
<p>问题：假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？</p>
<ul>
<li>只是把项目跑起来的话，只需要安装JRE就行了。</li>
</ul>
<p>问题：为什么安装JDK的时候会自带一个JRE？</p>
<ul>
<li>因为开发完程序之后，要运行这个程序，让这个程序运行起来，需要JRE，所以JDK安装的时候内部自带一个JRE。</li>
</ul>
<p>Java体系的技术被划分为三大块：</p>
<ul>
<li>JavaSE：标准版</li>
<li>JavaEE：企业版</li>
<li>JavaME：微型版</li>
</ul>
<h3 id="对Java的加载与执行的理解"><a href="#对Java的加载与执行的理解" class="headerlink" title="对Java的加载与执行的理解"></a>对Java的加载与执行的理解</h3><p>java程序从编写到最终运行经历了哪些过程？</p>
<p>java程序非常重要的两个阶段：</p>
<ul>
<li>编译阶段</li>
<li>运行阶段</li>
</ul>
<p>注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。（不同的操作系统上编译生成的字节码也是一样的）</p>
<p>java代码这种普通文本被称为：java源代码。（你编写的代码是源代码）源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。</p>
<p>编译阶段和运行阶段可以在不同的操作系统上完成吗？</p>
<p>在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行<strong>完全可以</strong>，因为Java是跨平台的。可以做到一次编写到处运行。</p>
<p>java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？</p>
<p><strong>完全可以</strong>执行，因为<u>源代码不参与程序的执行过程</u>。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。</p>
<ul>
<li>放源代码的文件扩展名必须是：xxx.java</li>
<li>并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class</li>
<li>.java文件就是源文件，这个文件中编写源代码。</li>
<li>.class文件就是字节码文件，这个文件是编译源代码而得到的。</li>
<li>1个java源文件是可以编译生成多个class文件的。</li>
<li>最终运行的是class文件。</li>
</ul>
<p>问题：字节码文件是二进制文件吗？</p>
<p>字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。</p>
<p>java程序从开发到最终运行经历了什么？</p>
<ul>
<li>编译期：（可以在windows上）<ul>
<li>第一步：在硬盘的某个位置（随意），新建一个xxx.java文件</li>
<li>第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件</li>
<li>第三步：在xxx.java文件中编写“符合java语法规则的”源代码。</li>
<li>第四步：保存（一定要将xxx.java文件保存一下）</li>
<li>第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。</li>
<li>第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）</li>
</ul>
</li>
<li>运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）<ul>
<li>第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）</li>
<li>第八步：使用JDK自带的一个命令&#x2F;工具：java（负责运行的命令&#x2F;工具）执行字节码</li>
<li>第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）</li>
<li>第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和<br>  硬件进行交互。</li>
</ul>
</li>
</ul>
<p>注意：在以上的过程中，需要使用两个非常重要的命令？</p>
<ul>
<li>javac 命令，负责编译</li>
<li>java 命令，负责运行</li>
</ul>
<p>xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。</p>
<p>源文件中编写的代码叫做：源代码。</p>
<p>以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？</p>
<ul>
<li>新建java文件</li>
<li>打开java文件</li>
<li>写java源代码</li>
<li>保存</li>
<li>javac命令编译</li>
<li>java命令运行</li>
</ul>
<p>编写、编译、运行</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>第一步：安装文本编辑器</p>
<p>第二步：安装JDK（先下载JDK）安装JDK13，直接下一步就行。</p>
<p>JDK13安装的时候内置了一个JRE，独立于JDK之外的JRE并没有生成。对于java13来说，如果你希望生成一个独立于JDK之外的JRE的话需要执行特殊的命令。</p>
<p>注意：<br>JDK8安装的时候，不仅JDK内置了一个JRE，而且还会在JDK目录之外独立的生成一个单独的JRE。（以前低版本的时候，JRE实际上是有2个。）一个是JDK内置的，一个是独立于JDK之外的。</p>
<p>JDK的bin目录下有：</p>
<ul>
<li>javac.exe 负责编译</li>
<li>java.exe 负责运行</li>
</ul>
<p>第三步：写代码</p>
<p>第四步：编译</p>
<p>第五步：运行</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>怎么编译？使用什么命令？这个命令怎么用？</p>
<ul>
<li>需要使用的命令是：C:\Program Files\Java\jdk-13.0.2\bin\javac.exe</li>
<li>这个命令需要先测试一下，打开DOS命令窗口，看看javac命令是否可用。</li>
</ul>
<p>C:\Users\Administrator&gt;javac</p>
<p>‘javac’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</p>
<p>这说明：windows操作系统没有发现“javac.exe”命令在哪里。windows操作系统没有找到javac.exe文件在哪。</p>
<p>为什么ipconfig、ping等命令可以使用呢？为什么javac用不了？</p>
<ul>
<li>我们发现windows操作系统中有这样一个环境变量，名字叫做：<code>path</code>，并且发现<code>path</code>环境变量的值是：<br><code>C:\Windows\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\</code>我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe</li>
</ul>
<p>注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。</p>
<p>将path环境变量中的:C:\windows\system32; 删除之后再测试：:\Users\Administrator&gt;ipconfig<br>‘ipconfig’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</p>
<p>配置环境变量path的步骤：</p>
<ul>
<li>桌面计算机上右键–&gt;属性–&gt;高级系统设置–&gt;环境变量</li>
</ul>
<p>怎么修改path环境变量？</p>
<ul>
<li>找到path，鼠标双击！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。</li>
</ul>
<p>让javac.exe能用，我们配置哪个路径到path中？将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。</p>
<p>注意：</p>
<ul>
<li>环境变量包括“系统变量”和“用户变量”</li>
<li>系统变量：范围比较大，系统变量会让计算机所有用户都起作用。</li>
<li>用户变量：范围比较小，这个变量只是作用于当前用户。</li>
</ul>
<p>怎么查看编译器版本？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;&lt;u&gt;javac -version&lt;/u&gt;</span><br><span class="line">javac 13.0.2</span><br></pre></td></tr></table></figure>

<p>怎么查看java虚拟机的版本？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;&lt;u&gt;java -version&lt;/u&gt;</span><br><span class="line">java version <span class="string">&quot;13.0.2&quot;</span> 2020-01-14</span><br><span class="line">Java(TM) SE Runtime Environment (build 13.0.2+8)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<p><strong>问题1</strong>：path环境变量的作用是什么？</p>
<p>path环境变量的作用就是给windows操作系统指路的。<u>告诉windows操作系统去哪里找这个命令文件。</u>path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。</p>
<p>path&#x3D;A;B;C;D……path是环境变量的名字。A;B;C;D……是环境变量path的值。</p>
<p><strong>问题2</strong>：path环境变量是java中的机制，还是windows操作系统中的机制？path环境变量是隶属于java的吗？path环境变量和java有关系吗？</p>
<p>path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。</p>
<p>假设该文件的名字叫做：HelloWorld.class</p>
<p>那么HelloWorld被称为类名；如果文件名是Test.class，那么Test就是一个类名。</p>
<p>怎么运行，使用哪个命令？使用JDK的bin目录下的：java.exe命令来运行。</p>
<p>先在DOS命令窗口中测试java.exe这个命令是否可用！java -version</p>
<p>“java.exe”这个命令怎么用，语法格式是什么？java 类名</p>
<p>java HelloWorld.class 对不对？不对！正确的写法是：java HelloWorld</p>
<p>千万千万要注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”，因为java命令后面跟的不是文件，是一个“类名”。</p>
<p>对于这个类：Test.class ，应该：java Test</p>
<h4 id="java-HelloWorld”的执行过程以及原理"><a href="#java-HelloWorld”的执行过程以及原理" class="headerlink" title="java HelloWorld”的执行过程以及原理"></a>java HelloWorld”的执行过程以及原理</h4><p>D:\course\JavaProjects\02-JavaSE\chapter01&gt;java HelloWorld 敲完回车，都发生了什么？？？？？</p>
<p>第一步：</p>
<p>会先启动<strong>JVM</strong>（java虚拟机）</p>
<p>第二步：</p>
<p>JVM启动之后，JVM会去启动“类加载器classloader”</p>
<p>类加载器的作用：</p>
<ul>
<li>加载类的。本质上类加载器负责去硬盘上<strong>找“类”对应的“字节码”文件</strong>。</li>
<li>假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。</li>
<li>假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。<br>…….</li>
</ul>
<p>第三步：</p>
<p>类加载器如果在硬盘上找不到对应的字节码文件，会报错，报什么错？</p>
<ul>
<li>错误: 找不到或无法加载主类</li>
</ul>
<p>类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000…”这种二进制码，操作系统执行二进制码和硬件交互。</p>
<p>默认情况下，类加载器去硬盘上找“字节码”文件的时候，默认从哪找？</p>
<ul>
<li>默认情况下类加载器（classloader）会从当前路径下找。</li>
</ul>
<p>能不能给类加载器指定一个路径，让类加载器去指定的路径下加载字节码文件？</p>
<ul>
<li>答案：可以的。但是我们需要设置一个环境变量，叫做：classpath</li>
</ul>
<p>classpath是一个环境变量，是干啥的？</p>
<ul>
<li>答案：是给“类加载器”指路的。</li>
</ul>
<p>classpath环境变量<strong>不属于</strong>windows操作系统，classpath环境变量<strong>隶属于java</strong></p>
<p>classpath环境变量是java特有的。</p>
<p>classpath&#x3D;A路径;B路径;C路径…..</p>
<p>classpath是一个变量名，A路径;B路径;C路径…..是变量值</p>
<p>我们把classpath配置一下，这个环境变量在windows中没有，需要新建。</p>
<p><code>计算机--&gt;右键--&gt;属性--&gt;高级系统设置--&gt;环境变量--&gt;新建...</code></p>
<p>注意：变量名不能随意写：大小写无所谓，但必须叫做：classpath</p>
<p>我目前是随意配置的：（重启CMD）classpath&#x3D;D:\course</p>
<p>非常重要的一个特点，必须记住：配置了classpath&#x3D;D:\course之后，类加载器只会去D:\course目录下找“xxx.class”文件，不再从当前路径下找了。</p>
<p>到目前为止：classpath环境变量不需要配置。但你必须理解classpath环境变量是干什么的！</p>
<p>你一定要理解classpath环境变量的作用是什么？</p>
<ul>
<li>是给类加载器指路的。</li>
<li>在没有配置环境变量classpath的时候，默认从当前路径下加载。</li>
<li>如果配置了环境变量classpath的话，就只能从指定的路径下加载了。</li>
</ul>
<p>path java_home classpath，这3个环境变量path需要配置，后面两个暂时不配置。</p>
<p>在高版本的JDK当中，有这样的一个新特性，可以直接这样一步到位：</p>
<p>java x&#x2F;y&#x2F;z&#x2F;xxx.java</p>
<p>java后面直接加java源文件的路径。</p>
<p>这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。</p>
<h4 id="对于第一个程序的解释"><a href="#对于第一个程序的解释" class="headerlink" title="对于第一个程序的解释"></a>对于第一个程序的解释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123; <span class="comment">//类体开始</span></span><br><span class="line">    <span class="comment">//public：公开的</span></span><br><span class="line">    <span class="comment">//class：一个类</span></span><br><span class="line">    <span class="comment">//HelloWorld：类名</span></span><br><span class="line">    <span class="comment">//表示一个共有的类HelloWorld</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; <span class="comment">//方法体开始</span></span><br><span class="line">        <span class="comment">//整个这一块的代码被称为：main方法（程序的入口，sUN公司java语言规定的）</span></span><br><span class="line">        <span class="comment">//也就是说：JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序不能执行</span></span><br><span class="line">        <span class="comment">//main方法也可以叫做主方法。</span></span><br><span class="line">        <span class="comment">//注意：方法必须放到类体中，不能放到类体外面。</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello &quot;</span>); <span class="comment">//作用：向控制台输出一句话</span></span><br><span class="line">        <span class="comment">//如果println里面的事字符串，就应该用英文创引号括起来</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//方法体结束</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//类体结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下程序可以编译通过，但是无法运行，符合语法规则。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;java Test2</span></span><br><span class="line"><span class="comment">错误: 在类 Test2 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">   public static void main(String[] args)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">没有语法错误，没有入口，能够编译通过，但是不能运行，因为没有main方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">错误: 在类 Test3 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment">   public static void main(String[] args)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span>&#123;</span><br><span class="line">	<span class="comment">// 注意：args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] fdsafdsafdsafdsa)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下程序符合java语法规则吗？不符合！</span></span><br><span class="line"><span class="comment">// 不是不运行，是编译报错。编译过不去，运行肯定不行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类体当中应该是方法，而不是直接的java语句</span></span><br><span class="line">	<span class="comment">// 这里可以写吗？不可以！</span></span><br><span class="line">	System.out.println(<span class="string">&quot;hello1&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 主方法，入口</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里可以写吗？不可以！</span></span><br><span class="line">	System.out.println(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法中什么也不写行吗？可以！</span></span><br><span class="line"><span class="comment">// 以下程序编译和运行可以吗？可以！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span>&#123;</span><br><span class="line">	<span class="comment">// 入口</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个不加双引号行吗？ 可以，因为它是数字。</span></span><br><span class="line">		System.out.println(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 是数字，加双引号行吗？</span></span><br><span class="line">		System.out.println(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 以上性质一样吗？不一样：一个是字符串，一个是数字。</span></span><br><span class="line">		<span class="comment">// 但最终输出到控制台上一个样子，没啥区别。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里扩展一下：对于数字来说能进行加减乘除吗？</span></span><br><span class="line">		<span class="comment">// + - * / 能用吗 ？ 都可以！</span></span><br><span class="line">		System.out.println(<span class="number">100</span> + <span class="number">200</span>); <span class="comment">// 300</span></span><br><span class="line">		System.out.println(<span class="number">200</span> - <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">		System.out.println(<span class="number">200</span> * <span class="number">100</span>); <span class="comment">// 20000</span></span><br><span class="line">		System.out.println(<span class="number">200</span> / <span class="number">100</span>); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//编译成功并且生成了 四个类 A.class B.class C.class D.class</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1、这个内容没有为什么，只能经过测试，然后根据测试结果进行记忆。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	2、第一个结论？</span></span><br><span class="line"><span class="comment">		一个java源文件中可以定义多个class。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	3、第二个结论？</span></span><br><span class="line"><span class="comment">		public的类不是必须的。可以没有。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	4、第三个结论？</span></span><br><span class="line"><span class="comment">		在源文件中只要有一个class的定义，那么必然会对应生成一个class文件。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	5、第四个结论？</span></span><br><span class="line"><span class="comment">		public的类可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	6、第五个结论？</span></span><br><span class="line"><span class="comment">		public的类有也只能有1个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Test8.java:20: 错误: 类 B 是公共的, 应在名为 B.java 的文件中声明</span></span><br><span class="line"><span class="comment">	public class B&#123;</span></span><br><span class="line"><span class="comment">			 ^</span></span><br><span class="line"><span class="comment">	1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class B&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定义public的类你只能这样写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test8</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误: 类重复: Test8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class Test8&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过了</span></span><br><span class="line"><span class="comment">// 能执行吗？</span></span><br><span class="line"><span class="comment">// 想从哪个入口进去执行，你就加载哪个类就行了！</span></span><br><span class="line"><span class="comment">// 例如：java T1</span></span><br><span class="line"><span class="comment">// 例如：java T2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试不代表以后就这样写，一般一个软件的执行入口是一个。不会出现多个的。</span></span><br><span class="line"><span class="comment">// 以下只是一个测试罢了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span>&#123;</span><br><span class="line">	<span class="comment">// 想从这个入口进去执行怎么办？java T1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;T1.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span>&#123;</span><br><span class="line">	<span class="comment">// 想从这个入口进去执行怎么办？java T2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;T2.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>终止程序用System.exit()  方法</li>
<li>函数调用：object.method(parameters)</li>
</ul>
<h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>规则1：标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号（比如空格）。</p>
<p>规则2：标识符不能以数字开头</p>
<p>规则3：关键字不能做标识符。例如：public class static void 这些蓝色的字体都是关键字，关键字是不能做标识符的。</p>
<p>规则4：标识符是严格区分大小写的。大写A和小写a不一样。</p>
<p>规则5：标识符理论上是没有长度限制的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiaoShiFuTest</span>&#123;</span><br><span class="line">	<span class="comment">// main是一个方法的名称，属于标识符</span></span><br><span class="line">	<span class="comment">// 但是这个标识符不能修改，因为这个main是SUN固定死的。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//doSome是一个方法名，可以改成其他的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">// k是一个变量名</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="comment">// nianLing 是一个变量名</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">nianLing</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	class 123ABC&#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上代码编译报错，错误信息是：</p>
<ul>
<li><p>错误: 需要&lt;标识符&gt;</p>
</li>
<li><p>错误原因：编译器检测到class这个单词，那么编译器会从class这个单词后面找类名，而类名是标识符，编译器找了半天没有找到标识符，因为123ABC不是标识符，所以编译器提示的错误信息是：需要&lt;标识符&gt;</p>
</li>
</ul>
<p>解决办法：将123ABC修改为合法的标识符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y123ABC</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> World&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类名是标识符，标识符“中”不能有空格</p>
<p>编译器错误信息是：</p>
<ul>
<li>错误: 需要’{‘</li>
<li>编译器检测到class，然后找class后面的标识符，编译器找到了一个合法的标识符叫做“Hello”，然后编译器继续往后找“{”，结果没有找到“{”，所以报错了。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>办法1：是把World删除</li>
<li>办法2：把空格删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span>                   &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_$1Aa</span>你&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>题目：</p>
<p>创建一个java文件，起名 123.java可以吗？</p>
<p>可以，完全可以，在windows操作系统中文件名叫做：123.java 没毛病。</p>
<p>123其实并不是标识符。只是一个文件名。</p>
<p>只不过在123.java文件中无法定义public的类。</p>
</blockquote>
<p>标识符除了命名规则之外，还有命名规范：</p>
<p>1、命名规则和命名规范有什么区别？</p>
<ul>
<li><p>命名规则是语法，不遵守就会编译报错。</p>
</li>
<li><p>命名规范只是说，大家尽量按照统一的规范来进行命名，不符合规范也行，代码是可以编译通过的，但是你的代码风格和大家不一样，这个通常也是不允许的。</p>
</li>
</ul>
<p>规则类似于现实世界中的法律。规范类似于现实世界中的道德。</p>
<p>统一按照规范进行的话，代码的可读性很好。	代码很容易让其它开发人员理解。</p>
<p>2、具体的命名规范是哪些？</p>
<p>规范1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）</p>
<p>规范2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低…）驼峰有利于单词与单词之间很好的进行分隔,	BiaoShiFuTest，这个很好，一眼就能看出来是4个单词。</p>
<p>规范3：类名、接口名有特殊要求: 类名和接口名首字母大写，后面每个单词首字母大写。StudentTest、UserTest ，这是类名、接口名。</p>
<p>规范4：变量名、方法名有特殊要求。</p>
<ul>
<li>变量名和方法名首字母小写，后面每个单词首字母大写。nianLing（NianLing这样就不符合了。）mingZi（MingZi这样也不符合了。）</li>
</ul>
<p>规范5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。</p>
<ul>
<li><p>USER_AGE ：用户年龄</p>
</li>
<li><p>MATH_PI：固定不变的常量3.1415926…..</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentifierTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 主要看两个汉语拼音，可读性很强。</span></span><br><span class="line">		<span class="comment">// nianLing和mingZi都是黑色字体的标识符。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">nianLing</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">mingZi</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>什么是关键字？在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。</p>
<p>切记：java语言中的所有关键字都是全部小写。注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。</p>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><p>java 中整型的范围与运行代码的机器无关</p>
</li>
<li><p>从java7开始，加上前缀0b或者0B就可以写二进制数，比如0b10100</p>
</li>
<li><p>还可以为数字加上下划线，如1_0000_0000,等价于100000000</p>
</li>
<li><p>在C&#x2F;C++中，int和long等类型的大小与平台直接相关，int型在16位的平台上占用2字节的大小，在32位的平台上占用4字节的大小，在Java中，占用的大小是固定的，与平台无关。</p>
</li>
<li><p>Java中没有任何的无符号整型</p>
</li>
<li><p>Java无法精确打印出2.0-1.1的结果的原因（0.89999999而不是0.9）</p>
<ul>
<li>浮点数采用二进制数表示，但是二进制系统中无法精确的表示分数1&#x2F;10</li>
</ul>
</li>
<li><p>强烈建议不要使用char类型，除非确实需要处理UTF-16的代码单元</p>
</li>
<li><p>不提倡在一行中声明多个变量，逐一声明变量可以提高程序的可读性</p>
</li>
</ul>
<h2 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>字面量：字面量就是数据、数据就是字面量、是一个东西。在java语言中“数据”被称为“字面量”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 100 123 ：整型</span><br><span class="line">1.34 3.14 2.0：浮点型</span><br><span class="line">true false ：布尔型</span><br><span class="line">&#x27;a&#x27; &#x27;国&#x27;：字符型</span><br><span class="line">&quot;a&quot; &quot;abc&quot;  &quot;国&quot; &quot;中国&quot;：字符串型</span><br><span class="line">10：整数，是一个数字</span><br><span class="line">&quot;10&quot;：它不是数字，是一个字符串，或者说，它属于“文字类”的。性质完全不同，在计算机中的对应的二进制码也是完全不同的。</span><br></pre></td></tr></table></figure>

<p>其中字符型和字符串型都是描述了现实世界中的文字，需要注意的是：</p>
<ul>
<li><p>所有的字符型只能使用单引号括起来。</p>
</li>
<li><p>所有的字符串型只能使用双引号括起来。</p>
</li>
<li><p>字符型一定是单个字符才能成为“字符型”</p>
</li>
</ul>
<p>	</p>
<p>在语法级别上怎么区分字符型和字符串型？</p>
<ul>
<li><p>主要看是双引号还是单引号。</p>
</li>
<li><p>单引号的一定是字符型。</p>
</li>
<li><p>双引号的一定是字符串型。</p>
</li>
</ul>
<p>什么是变量？</p>
<p>变量就是一个存数据盒子。在内存中的最基本的存储单元。是存数据用的，而且这个数据是可变的，所以叫做变量。（盒子大小谁来决定？数据类型）</p>
<p>变量的使用</p>
<p>变量的三要素？</p>
<p>数据类型、变量名、值  （值就是数据，就是字面量。）<code>int i = 100;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. java中的变量必须先声明，再赋值才能访问（必须手动赋值。）</span></span><br><span class="line"><span class="type">int</span> k; </span><br><span class="line">System.out.println(k); <span class="comment">//这样是不行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可以在一行上声明多个变量：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// c变量赋值100，a,b变量只声明了没有赋值。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 也可以这样每个都赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明和赋值可以分开，也可以一起做！</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="number">100</span>; <span class="comment">// 先声明再赋值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">200</span>; <span class="comment">// 声明的同时赋值</span></span><br></pre></td></tr></table></figure>

<p>在“同一个域”当中，变量名不能重名！但可以重新赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//double i = 2.0; // 重名了编译器会报错，不允许。</span></span><br><span class="line">    i = <span class="number">300</span>; <span class="comment">// 可以重新赋值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么叫做同一个域？一个大括号代表一个域。</p>
<p>变量的分类</p>
<p>根据位置进行分类：记住就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法体当中声明的变量叫做局部变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//局部变量，方法执行结束之后内存释放。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在方法体外以及类体内声明的变量叫做成员变量。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的作用域</span></span><br><span class="line"><span class="comment">//出了大括号就不认识了。别的先别管。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在这里可以访问i</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在这里是无法访问i变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的作用域？</p>
<p>1、什么是作用域？变量的有效范围。</p>
<p>2、关于变量的作用域，可一句话：出了大括号就不认识了。（死记这句话。）</p>
<p>3、java中有一个很重要的原则：就近原则。（不仅java中是这样，其它编程语言都有这个原则。）哪个离我近，就访问哪个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarTest08</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 局部变量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 这个i的有效范围是main方法。</span></span><br><span class="line">		System.out.println(i); <span class="comment">// 这个i是多少？</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 同一个域当中，这是不允许的。</span></span><br><span class="line">		<span class="comment">//int i = 90;  </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)&#123; <span class="comment">// 这里声明的n变量只属于for域。for结束后n释放没了。</span></span><br><span class="line">			<span class="comment">// 这里没有编写代码。</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// for循环执行结束之后，在这里访问n变量可以吗？</span></span><br><span class="line">		<span class="comment">//System.out.println(n);  //错误: 找不到符号</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> k; <span class="comment">// 属于main域。</span></span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法怎么定义先不用管，后面会学习。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">// 在这个位置上能访问i吗？不能</span></span><br><span class="line">		<span class="comment">// 错误: 找不到符号</span></span><br><span class="line">		<span class="comment">// System.out.println(i); // i是无法访问的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可以定义一个变量起名i吗？</span></span><br><span class="line">		<span class="comment">// 这个i的有效范围是x方法。</span></span><br><span class="line">		<span class="comment">// 局部变量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>; <span class="comment">// 所以这个i和main方法中的i不在同一个域当中。不冲突。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型有什么用？</p>
<ul>
<li>数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。</li>
</ul>
<p>数据类型在java语言中包括两种：</p>
<ul>
<li>第一种：基本数据类型(8小种)基本数据类型又可以划分为4大类8小种：<ul>
<li>第一类：整数型 byte,short,int,long （没有小数的）</li>
<li>第二类：浮点型 float,double （带有小数的）</li>
<li>第三类：布尔型 boolean：只有两个值true和false，true表示真，false表示假</li>
<li>第四类：字符型 char：java中规定字符型字面量必须使用单引号括起来。属于文字。</li>
</ul>
</li>
<li>第二种：引用数据类型<ul>
<li>字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。</li>
</ul>
</li>
<li>java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。</li>
</ul>
<p>整数型：byte short int long有什么区别？</p>
<p>浮点型：float和double有什么区别？</p>
<p>区别：占用的空间大小不同。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数量(byte)</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>-2^63~2^63-1</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>-2^31~2^31-1</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>-2^63~2^63-1</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>true、false</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
</tbody></table>
<p>short和char实际上容量相同，不过char可以表示更大的数字。</p>
<p>因为char表示的是文字，文件没有正负之分，所以char可以表示更大的数字。</p>
<p>其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0;对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。</p>
<p>什么是字符编码？</p>
<p>字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。字符编码是人为规定的。</p>
<p>字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。</p>
<p>关于字符编码的发展过程？</p>
<ul>
<li>起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了战争而开发的，计算导弹的轨道….</li>
<li>后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文对应的字符编码方式是：ASCII码。</li>
</ul>
<p>在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。具体的实现包括：UTF-8 UTF-16 UTF-32….</p>
<p>ASCII（’a’是97 ‘A’是65 ‘0’是48…）</p>
<h4 id="字符型：char"><a href="#字符型：char" class="headerlink" title="字符型：char"></a>字符型：char</h4><p>1、char占用2个字节。</p>
<p>2、char的取值范围：[0-65535]</p>
<p>3、char采用unicode编码方式。</p>
<p>4、char类型的字面量使用单引号括起来。</p>
<p>5、char可以存储一个汉字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharTest01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// char可以存储1个汉字吗？</span></span><br><span class="line">		<span class="comment">// 可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">		System.out.println(c1);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		System.out.println(c2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 0如果加上单引号的话，0就不是数字0了，就是文字0，它是1个字符。</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		System.out.println(c3);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: String无法转换为char</span></span><br><span class="line">		<span class="comment">//char c4 = &quot;a&quot;;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 错误: 未结束的字符文字</span></span><br><span class="line">		<span class="comment">//char c5 = &#x27;ab&#x27;;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 错误: 未结束的字符文字</span></span><br><span class="line">		<span class="comment">//char c6 = &#x27;1.08&#x27;;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转义字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	关于java中的转义字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharTest02</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">		<span class="comment">// 编译报错。</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;&quot;&quot;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;\&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个可以输出吗？</span></span><br><span class="line">		<span class="comment">// 这个不需要专门进行转义。</span></span><br><span class="line">		<span class="comment">// 这个 &#x27; 在这里只是一个普通的字符，不具备特殊含义。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//以下都有问题</span></span><br><span class="line">		<span class="comment">//System.out.println(&#x27;&#x27;&#x27;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可以的。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;&#x27;这样呢&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 编译报错，因为：4e2d 是一个字符串</span></span><br><span class="line">		<span class="comment">// 错误: 未结束的字符文字</span></span><br><span class="line">		<span class="comment">//char x = &#x27;4e2d&#x27;;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 反斜杠u表示后面的是一个字符的unicode编码。</span></span><br><span class="line">		<span class="comment">// unicode编码是十六进制的。</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>;</span><br><span class="line">		System.out.println(x); <span class="comment">// &#x27;中&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1、整数能否直接赋值给char</span></span><br><span class="line"><span class="comment">	2、char x = 97;</span></span><br><span class="line"><span class="comment">		这个java语句是允许的，并且输出的结果是&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">		经过这个测试得出两个结论：</span></span><br><span class="line"><span class="comment">			第一个结论：当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			第二个结论：当一个整数没有超出byte short char的取值范围的时候，</span></span><br><span class="line"><span class="comment">			这个整数可以直接赋值给byte short char类型的变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharTest03</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		System.out.println(c1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里会做类型转换吗？</span></span><br><span class="line">		<span class="comment">// 97是int类型（这是java中规定，默认当做int处理）</span></span><br><span class="line">		<span class="comment">// c2是char类型</span></span><br><span class="line">		<span class="comment">//char c2 = (char)97; // 不需要这样做。</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">		System.out.println(c2); <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// char类型取值范围：[0~65535]</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="number">65535</span>; <span class="comment">// 实际上最终是一个“看不懂”的字符。</span></span><br><span class="line">		System.out.println(c3);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//错误: 不兼容的类型: 从int转换到char可能会有损失</span></span><br><span class="line">		<span class="comment">//char c4 = 65536;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么解决以上问题？</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> (<span class="type">char</span>)<span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整数型：byte-short-int-long"><a href="#整数型：byte-short-int-long" class="headerlink" title="整数型：byte short int long"></a>整数型：byte short int long</h4><p>byte b &#x3D; 127; &#x2F;&#x2F; 可以直接赋值short s &#x3D; 32767; &#x2F;&#x2F; 可以直接赋值</p>
<p>char &#x2F;&#x2F; 没有超出char的取值范围可以直接赋值给char变量吗?</p>
<p>浮点型：float double</p>
<p>布尔型：boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	开发的时候不用斤斤计较，直接选择使用int就行了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 二进制（JDK8的新特性，低版本不支持。）</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0b10</span>;</span><br><span class="line">		System.out.println(d); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="过大整数的问题"><a href="#过大整数的问题" class="headerlink" title="过大整数的问题"></a>过大整数的问题</h5><p>在java中有一条非常重要的结论，必须记住：</p>
<ul>
<li>在任何情况下，整数型的“字面量&#x2F;数据”默认被当做int类型处理。（记住就行）果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L&#x2F;l,	建议使用大写L，因为小写l和1分不清。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest02</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分析这个代码存在类型转换吗，以下代码什么意思？</span></span><br><span class="line">		<span class="comment">// 不存在类型转换</span></span><br><span class="line">		<span class="comment">// 100 这个字面量被当做int类型处理</span></span><br><span class="line">		<span class="comment">// a变量是int类型，所以不存在类型的转换。</span></span><br><span class="line">		<span class="comment">// int类型的字面量赋值给int类型的变量。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分析这个程序是否存在类型转换？</span></span><br><span class="line">		<span class="comment">// 分析：200这个字面量默认被当做int类型来处理</span></span><br><span class="line">		<span class="comment">// b变量是long类型，int类型占4个字节，long类型占8个字节</span></span><br><span class="line">		<span class="comment">// 小容量可以自动转换成大容量，这种操作被称为：自动类型转换。</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">		System.out.println(b);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分析这个是否存在类型转换？</span></span><br><span class="line">		<span class="comment">// 这个不存在类型转换。</span></span><br><span class="line">		<span class="comment">// 在整数型字面量300后面添加一个L之后，300L联合起来就是一个long类型的字面量</span></span><br><span class="line">		<span class="comment">// c变量是long类型，long类型赋值给long类型不存在类型转换。</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">300L</span>;</span><br><span class="line">		System.out.println(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 题目：</span></span><br><span class="line">		<span class="comment">// 可以吗？存在类型转换吗？</span></span><br><span class="line">		<span class="comment">// 2147483647默认被当做int来处理</span></span><br><span class="line">		<span class="comment">// d变量是long类型，小容量可以自动赋值给大容量，自动类型转换</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2147483647</span>; <span class="comment">// 2147483647是int最大值。</span></span><br><span class="line">		System.out.println(d);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 编译器会报错吗？为什么？</span></span><br><span class="line">		<span class="comment">// 在java中，整数型字面量一上来编译器就会将它看做int类型</span></span><br><span class="line">		<span class="comment">// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。</span></span><br><span class="line">		<span class="comment">// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648</span></span><br><span class="line">		<span class="comment">// 只不过2147483648本身已经超出了int范围。</span></span><br><span class="line">		<span class="comment">// 错误: 整数太大</span></span><br><span class="line">		<span class="comment">//long e = 2147483648;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么解决这个问题呢？</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">2147483648L</span>;</span><br><span class="line">		System.out.println(e);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="自动类型转换和强制类型转换"><a href="#自动类型转换和强制类型转换" class="headerlink" title="自动类型转换和强制类型转换"></a>自动类型转换和强制类型转换</h5><p>1、小容量可以直接赋值给大容量，称为自动类型转换。</p>
<p>2、大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。但需要注意的是：加强制类型转换符之后，虽然编译通过了，但是运行的时候可能会损失精度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest03</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 不存在类型转换</span></span><br><span class="line">		<span class="comment">// 100L是long类型字面量，x是long类型字面量。</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// x是long类型，占用8个字节，而y变量是int类型，占用4个字节</span></span><br><span class="line">		<span class="comment">// 在java语言中，大容量可以“直接”赋值给小容量吗？不允许，没有这种语法。</span></span><br><span class="line">		<span class="comment">// 编译错误信息：错误: 不兼容的类型: 从long转换到int可能会有损失</span></span><br><span class="line">		<span class="comment">// int y = x;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。</span></span><br><span class="line">		<span class="comment">// 底层是怎么进行强制类型转换的呢？</span></span><br><span class="line">		<span class="comment">// long类型100L：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100</span></span><br><span class="line">		<span class="comment">// 以上的long类型100L强转为int类型，会自动将“前面”的4个字节砍掉：00000000 00000000 00000000 01100100</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>)x; <span class="comment">// 这个(int)就是强制类型转换符，加上去就能编译通过。</span></span><br><span class="line">						<span class="comment">// 但是要记住：编译虽然过了，但是运行时可能损失精度。</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义变量a int类型，赋值100</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">// 将变量a中保存的值100复制一份给b变量。</span></span><br><span class="line">		System.out.println(b);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="强制类型转换的精度损失"><a href="#强制类型转换的精度损失" class="headerlink" title="强制类型转换的精度损失"></a>强制类型转换的精度损失</h5><p>java中有一个语法规则：</p>
<ul>
<li>当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量。short 同理。</li>
</ul>
<p>这种语法机制是为了方便写代码，而存在的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest04</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 分析：以下代码编译可以通过吗？</span></span><br><span class="line">		<span class="comment">// 300 被默认当做int类型</span></span><br><span class="line">		<span class="comment">// b变量是byte类型</span></span><br><span class="line">		<span class="comment">// 大容量转换成小容量，要想编译通过，必须使用强制类型转换符</span></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从int转换到byte可能会有损失</span></span><br><span class="line">		<span class="comment">//byte b = 300;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要想让以上的程序编译通过，必须加强制类型转换符</span></span><br><span class="line">		<span class="comment">// 虽然编译通过了，但是可能精度损失。</span></span><br><span class="line">		<span class="comment">// 300这个int类型对应的二进制：00000000 00000000 00000001 00101100</span></span><br><span class="line">		<span class="comment">// byte占用1个字节，砍掉前3个字节，结果是：00101100 (44)</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">300</span>;</span><br><span class="line">		System.out.println(b); <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个编译能通过吗？</span></span><br><span class="line">		<span class="comment">// 1是int类型，默认被当做int类型来看。</span></span><br><span class="line">		<span class="comment">// x是byte类型，1个字节，大容量无法直接转换成小容量。</span></span><br><span class="line">		<span class="comment">// 按说是编译报错的。</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从int转换到byte可能会有损失</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当整数型字面量没有超出short类型取值范围的时候，该字面量可以直接赋值给short</span></span><br><span class="line">		<span class="comment">// 类型的变量。</span></span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">32767</span>;</span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从int转换到short可能会有损失</span></span><br><span class="line">		<span class="comment">//short s2 = 32768;</span></span><br><span class="line">		System.out.println(s);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="byte-char-short-混合运算"><a href="#byte-char-short-混合运算" class="headerlink" title="byte, char, short 混合运算"></a>byte, char, short 混合运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	结论：byte、char、short做混合运算的时候，各自先转换成int再做运算。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest06</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注意：这里的&quot;+&quot;是负责求和的</span></span><br><span class="line">		System.out.println(c1 + b); <span class="comment">// 98</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从int转换到short可能会有损失</span></span><br><span class="line">		<span class="comment">//short s = c1 + b; // 编译器不知道这个加法最后的结果是多少。只知道是int类型。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这样修改行吗？</span></span><br><span class="line">		<span class="comment">//错误: 不兼容的类型: 从int转换到short可能会有损失</span></span><br><span class="line">		<span class="comment">//short s = (short)c1 + b;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>)(c1 + b);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//short k = 98;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//错误: 不兼容的类型: 从int转换到short可能会有损失</span></span><br><span class="line">		<span class="comment">// short x = 1; 可以</span></span><br><span class="line">		<span class="type">short</span> <span class="variable">x</span> <span class="operator">=</span> a; <span class="comment">// 不可以，编译器只知道a是int类型，不知道a中存储的是哪个值。</span></span><br><span class="line">		System.out.println(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多种类型混合运算"><a href="#多种类型混合运算" class="headerlink" title="多种类型混合运算"></a>多种类型混合运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	结论：多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	char+short+byte 这个除外。</span></span><br><span class="line"><span class="comment">	因为char + short + byte混合运算的时候，会各自先转换成int再做运算。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntTest07</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求和</span></span><br><span class="line">		System.out.println(a + c + s + i); <span class="comment">//237</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从long转换到int可能会有损失</span></span><br><span class="line">		<span class="comment">// 计算结果是long类型</span></span><br><span class="line">		<span class="comment">//int x = a + c + s + i;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)(a + c + s + i);</span><br><span class="line">		System.out.println(x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 以下程序执行结果是？</span></span><br><span class="line">		<span class="comment">// java中规定，int类型和int类型最终的结果还是int类型。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">3</span>; <span class="comment">// / 是除号。（最终取整）</span></span><br><span class="line">		System.out.println(temp); <span class="comment">// 3.33333吗？结果是：3</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在java中计算结果不一定是精确的。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">		System.out.println(temp2); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="浮点型数据"><a href="#浮点型数据" class="headerlink" title="浮点型数据"></a>浮点型数据</h4><p>关于java语言中的浮点型数据</p>
<p>浮点型包括：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4个字节</td>
<td>float是单精度</td>
</tr>
<tr>
<td>double</td>
<td>8个字节</td>
<td>double是双精度,更精确</td>
</tr>
</tbody></table>
<p>比如说：</p>
<ul>
<li><p>10.0 &#x2F; 3 如果采用float来存储的话结果可能是：3.33333</p>
</li>
<li><p>10.0 &#x2F; 3 如果采用double来存储的话结果可能是：3.3333333333333</p>
</li>
</ul>
<blockquote>
<p>但是需要注意的是，如果用在银行方面或者说使用在财务方面，double也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门使用在财务软件方面：java.math.BigDecimal （不是基本数据类型，属于引用数据类型。）</p>
</blockquote>
<p>float和double存储数据的时候都是存储的近似值。</p>
<ul>
<li>因为现实世界中有这种无限循环的数据，例如：3.3333333333333….数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源表示无限的数据，只能存储近似值。</li>
</ul>
<p>long类型占用8个字节。float类型占用4个字节。</p>
<p>哪个容量大？</p>
<ul>
<li>注意：任意一个浮点型都比整数型空间大。float容量 &gt; long容量。</li>
</ul>
<p>java中规定，任何一个浮点型数据默认被当做double来处理。如果想让这个浮点型字面量被当做float类型来处理，那么请在字面量后面添加F&#x2F;f。</p>
<p>1.0 那么1.0默认被当做double类型处理。		1.0F 这才是float类型。（1.0f）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloatTest01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个不存在类型转换</span></span><br><span class="line">		<span class="comment">// 3.1415926是double类型</span></span><br><span class="line">		<span class="comment">// pi是double类型</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">		System.out.println(pi);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个可以吗？</span></span><br><span class="line">		<span class="comment">//错误: 不兼容的类型: 从double转换到float可能会有损失</span></span><br><span class="line">		<span class="comment">//float f = 3.14;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么修改以上的代码呢？</span></span><br><span class="line">		<span class="comment">// 第一种方式:在字面量后面添加F/f</span></span><br><span class="line">		<span class="comment">//float f = 3.14f;</span></span><br><span class="line">		<span class="comment">//float f = 3.14F;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第二种方式：强制类型转换，但可能损失精度。谨慎使用。</span></span><br><span class="line">		<span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">3.14</span>;</span><br><span class="line">		System.out.println(f);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分析这个程序，可以编译通过吗？</span></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从double转换到int可能会有损失</span></span><br><span class="line">		<span class="comment">// 原理：先将5转换成double类型，然后再做运算，结果是double</span></span><br><span class="line">		<span class="comment">// 大容量无法直接赋值给小容量，需要强转。</span></span><br><span class="line">		<span class="comment">//int i = 10.0 / 5;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么修改</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10.0</span> / <span class="number">5</span>;</span><br><span class="line">		System.out.println(i); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可以这样修改吗？强转的时候只留下整数位。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">10.0</span> / <span class="number">5</span>);</span><br><span class="line">		System.out.println(x); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>1、在java语言中boolean类型只有两个值，没有其他值：true和false。不像C或者C++，C语言中1和0也可以表示布尔类型。</p>
<p>2、boolean类型在实际开发中使用在哪里呢？		使用在逻辑判断当中，通常放到条件的位置上（充当条件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BooleanTest01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//错误: 不兼容的类型: int无法转换为boolean</span></span><br><span class="line">		<span class="comment">//boolean xingBie = 1;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>在类型转换的时候需要遵循哪些规则？</p>
<ul>
<li><p>第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；</p>
</li>
<li><p>第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；</p>
</li>
<li><p>第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：byte &lt; short(char) &lt; int &lt; long &lt; float &lt; double，其中 short和 char都占用两个字节，但是char 可以表示更大的正整数；</p>
</li>
<li><p>第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；</p>
</li>
<li><p>第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；</p>
</li>
<li><p>第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；</p>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>算术运算符：+ - * &#x2F; % ++ –</p>
</li>
<li><p>关系运算符： &gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</p>
</li>
<li><p>逻辑运算符：&amp; | ! &amp;&amp; ||</p>
</li>
<li><p>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</p>
</li>
<li><p>三目运算符：布尔表达式 ? 表达式 1 : 表达式 2 </p>
</li>
<li><p>字符串连接运算符：+</p>
</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符：</p>
<ul>
<li>&amp;	逻辑与（可以翻译成并且）</li>
<li>|	逻辑或（可以翻译成或者）</li>
<li>!	逻辑非（取反）</li>
<li>&amp;&amp;	短路与</li>
<li>||	短路或</li>
<li><pre><code>用普通话描述的话：100 大于 99 并且 100 大于 98；用代码描述的话：100 &gt; 99 &amp; 100 &gt; 98 --&gt; true
</code></pre>
</li>
</ul>
<p>true &amp; true –&gt; true</p>
<p>非常重要：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。这是逻辑运算符的特点。	</p>
<ul>
<li><p>100 &amp; true 不行，语法错误。</p>
</li>
<li><p>100 &amp; 200 不行，没有这种语法。</p>
</li>
<li><p>true &amp; false 这样可以。</p>
</li>
</ul>
<p>100 &gt; 90 &amp; 100 &gt; 101 –&gt; false</p>
<ul>
<li><p>&amp; 两边都是true，结果才是true</p>
</li>
<li><p>| 有一边是true，结果就是true</p>
</li>
</ul>
<p>短路与&amp;&amp; 和 逻辑与 &amp;有什么区别？</p>
<ul>
<li>首先这两个运算符的运算结果没有任何区别，完全相同。只不过“短路与&amp;&amp;”会发生短路现象。</li>
</ul>
<p>什么是短路现象呢？</p>
<ul>
<li>右边表达式不执行，这种现象叫做短路现象。</li>
</ul>
<p>什么时候使用&amp;&amp;，什么时候使用&amp; ？</p>
<ul>
<li>从效率方面来说，&amp;&amp;比&amp;的效率高一些。因为逻辑与&amp;不管第一个表达式结果是什么，第二个表达式一定会执行。</li>
</ul>
<p>以后的开发中，短路与&amp;&amp;和逻辑与还是需要同时并存的。</p>
<ul>
<li>大部分情况下都建议使用短路与&amp;&amp;，只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&amp;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp; <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp;&amp; <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp;&amp; <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来需要理解一下什么是短路现象，什么时候会发生“短路”。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 逻辑与&amp;什么时候结果为true（两边都是true，结果才是true）</span></span><br><span class="line"><span class="comment">// 左边的 x&gt;y 表达式结果已经是false了，其实整个表达式的结</span></span><br><span class="line"><span class="comment">// 果已经确定是false了，按道理来说右边的表达式不应该执行。</span></span><br><span class="line">System.out.println(x &gt; y &amp; x &gt; y++); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个测试得出：x &gt; y++ 这个表达式执行了。</span></span><br><span class="line">System.out.println(y); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试短路与&amp;&amp;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 使用短路与&amp;&amp;的时候，当左边的表达式为false的时候，右边的表达式不执行</span></span><br><span class="line"><span class="comment">// 这种现象被称为短路。</span></span><br><span class="line">System.out.println(m &gt; n &amp;&amp; m &gt; n++);</span><br><span class="line">System.out.println(n); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>问题：什么时候发生短路或现象？|| 短路或</p>
<p>“或”的时候只要有一边是true，结果就是true。</p>
<p>所以，当左边的表达式结果是true的时候，右边的表达式不需要执行，此时会短路。</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>扩展的赋值运算符？</p>
<ul>
<li><p>+&#x3D;</p>
</li>
<li><p>-&#x3D;</p>
</li>
<li><p>*&#x3D;</p>
</li>
<li><p>&#x2F;&#x3D;</p>
</li>
<li><p>%&#x3D;</p>
</li>
</ul>
<p>使用扩展赋值运算符的时候，永远都不会改变运算结果类型。</p>
<p><code>byte x = 100;</code><br><code>x += 1;</code></p>
<p>x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。不管后面是多大的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorTest04</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 研究：</span></span><br><span class="line">		<span class="comment">// i += 10 和 i = i + 10 真的是完全一样吗？</span></span><br><span class="line">		<span class="comment">// 答案：不一样，只能说相似，其实本质上并不是完全相同。</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 100没有超出byte类型取值范围，可以直接赋值</span></span><br><span class="line">		System.out.println(x); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 分析：这个代码是否能够编译通过？</span></span><br><span class="line">		<span class="comment">// 错误: 不兼容的类型: 从int转换到byte可能会有损失</span></span><br><span class="line">		<span class="comment">//x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用扩展赋值运算符可以吗？</span></span><br><span class="line">		<span class="comment">// 可以的，所以得出结论：x += 1 和 x = x + 1不一样。</span></span><br><span class="line">		<span class="comment">// 其实 x += 1 等同于：x = (byte)(x + 1);</span></span><br><span class="line">		x += <span class="number">1</span>;</span><br><span class="line">		System.out.println(x); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 早就超出byte的取值范围了。</span></span><br><span class="line">		x += <span class="number">199</span>; <span class="comment">// x = (byte)(x + 199);</span></span><br><span class="line">		System.out.println(x); <span class="comment">// 44 （当然会自动损失精度了。）</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		y += <span class="number">100</span>;</span><br><span class="line">		System.out.println(y); <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">		y -= <span class="number">100</span>; <span class="comment">// x = x - 100;</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">		y *= <span class="number">10</span>; <span class="comment">// x = x * 10;</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">		y /= <span class="number">30</span>; <span class="comment">// x = x / 30;</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 33</span></span><br><span class="line"></span><br><span class="line">		y %= <span class="number">10</span>; <span class="comment">// x = x % 10;</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 3</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个特例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大家讨论最多的一个问题。</span></span><br><span class="line"><span class="comment">// 如果只是针对于面试题的话，建议死记硬背。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		i = i++;</span><br><span class="line">		<span class="comment">// 大部分同学都会认为这个i一定是11</span></span><br><span class="line">		<span class="comment">// 这个i变量最终的结果是10（惊讶）</span></span><br><span class="line">		<span class="comment">// 首先，第一点：这种代码以后不会有人写。</span></span><br><span class="line">		<span class="comment">// 其次：第二点：没必要讨论这个问题，因为在C++中运行结果确实是11.</span></span><br><span class="line">		<span class="comment">// java中运行结果是10</span></span><br><span class="line">		<span class="comment">// c++中运行结果是11</span></span><br><span class="line">		<span class="comment">// 为什么？因为java和c++的编译器是不同的人开发的。原理不同。</span></span><br><span class="line">		System.out.println(i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 在java语言中i++，这种表达式在执行的时候，会提前先将i变量找一个临时</span></span><br><span class="line">		<span class="comment">// 变量存储一下。(C++中并没有这样做。)</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		int k = 10;</span></span><br><span class="line"><span class="comment">		k = k++;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// k = k++;对应的是下面三行代码</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> k;</span><br><span class="line">		k++;</span><br><span class="line">		k = temp;</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字符串链接运算符"><a href="#字符串链接运算符" class="headerlink" title="字符串链接运算符"></a>字符串链接运算符</h4><ul>
<li>运算符：</li>
</ul>
<p>1、+ 运算符在java语言中有两个作用。</p>
<ul>
<li><pre><code>作用1：求和
</code></pre>
</li>
<li><pre><code>作用2：字符串拼接
</code></pre>
</li>
</ul>
<p>2、什么时候求和？什么时候进行字符串的拼接呢？</p>
<ul>
<li><p>当 + 运算符两边都是数字类型的时候，求和。</p>
</li>
<li><p>当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。</p>
</li>
</ul>
<p>3、一定要记住：字符串拼接完之后的结果还是一个字符串。</p>
<h4 id="接收用户键盘输入"><a href="#接收用户键盘输入" class="headerlink" title="接收用户键盘输入"></a>接收用户键盘输入</h4><p>输出信息到控制台：<code>System.out.println(...);</code></p>
<p>2、在java中怎么接收键盘的输入呢？</p>
<p><code>java.util.Scanner s = new java.util.Scanner(System.in); </code></p>
<p>接收一个整数		<code>int num = s.nextInt();</code></p>
<p>接收一个字符串		<code>String str = s.next();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyInput</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个键盘扫描器对象</span></span><br><span class="line">		<span class="comment">// s 变量名，可以修改。其它不能改。 </span></span><br><span class="line">		java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(System.in); <span class="comment">//这行代码写一次就行了。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 接收用户的输入，从键盘上接收一个int类型的数据</span></span><br><span class="line">		<span class="comment">// 解释这行代码，尽量让大家明白：代码执行到这里的时候，会暂停下来</span></span><br><span class="line">		<span class="comment">// 等待用户的输入，用户可以从键盘上输入一个整数，然后回车，回车之后</span></span><br><span class="line">		<span class="comment">// i变量就有值了。并且i变量中保存的这个值是用户输入的数字。</span></span><br><span class="line">		<span class="comment">// i变量就是接收键盘数据的。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.nextInt(); <span class="comment">// i是变量名，s是上面的变量名</span></span><br><span class="line">		System.out.println(<span class="string">&quot;您输入的数字是：&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 代码执行到此处又会停下来，等待用户的输入。</span></span><br><span class="line">		<span class="comment">// 敲完回车，s.nextInt();代码执行结束。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;您输入的数字是：&quot;</span> + j);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果输入的不是数字，那么会出异常：InputMismatchException</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;您输入的数字是：&quot;</span> + m);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 我怎么从键盘上接收一个字符串呢？</span></span><br><span class="line">		<span class="comment">// 程序执行到此处会停下来，等待用户的输入，用户可以输入字符串。</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.next();</span><br><span class="line">		System.out.println(<span class="string">&quot;您输入了：&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 完整的。</span></span><br><span class="line">		System.out.print(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.next();</span><br><span class="line">		System.out.println(<span class="string">&quot;欢迎&quot;</span>+name+<span class="string">&quot;回来&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><p>在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层的变量，这样可能会导致程序设计的错误，所以在Java中不能这样做。</p>
</li>
<li><p>Java的引用相当于C++的指针而不是引用，因为：</p>
<ul>
<li><p>C++中没有空引用</p>
</li>
<li><p>引用不能被赋值</p>
</li>
</ul>
</li>
<li><p>java中的null引用相当与C++中的NULL指针</p>
</li>
</ul>
<h2 id="控制语句和方法"><a href="#控制语句和方法" class="headerlink" title="控制语句和方法"></a>控制语句和方法</h2><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li>选择语句<ul>
<li>if</li>
<li>switch<ul>
<li>switch语句本质上是只支持int和String，但是byte,short,char也可以使用在switch语句当中，因为byte short char可以进行<strong>自动类型转换</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>循环语句<ul>
<li>for</li>
<li>while</li>
<li>do…while</li>
</ul>
</li>
<li>转向语句<ul>
<li>break</li>
<li>continue</li>
<li>return</li>
</ul>
</li>
</ul>
<p><strong>记住 ：Java的 int 和 boolean 不能转换 ！！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">怎么用break;语句终止指定的循环呢？</span></span><br><span class="line"><span class="comment">	第一步：你需要给循环起一个名字，例如：</span></span><br><span class="line"><span class="comment">		a: for()&#123;</span></span><br><span class="line"><span class="comment">			b:for()&#123;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	第二步：终止：break a;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakTest01</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这种语法很少用，了解一下即可。</span></span><br><span class="line">		a:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)&#123; </span><br><span class="line">			b:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">					<span class="keyword">break</span> a; <span class="comment">// 终止指定的循环。</span></span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;i ===&gt; &quot;</span> + i); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;呵呵&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// continue 也可以这样终止，但是开发中也很少用</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法定义的先后顺序没有关系。都可以。</p>
<p>方法怎么定义，语法机制是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">	方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>[] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。</p>
</li>
<li><p>方法体由Java语句构成。</p>
</li>
<li><p>方法定义之后需要去调用，不调用是不会执行的。</p>
</li>
</ul>
<p>关于修饰符列表：</p>
<ul>
<li>修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static</li>
</ul>
<p>关于返回值类型：</p>
<ul>
<li><p>第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String……</p>
</li>
<li><p>第二：方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。</p>
</li>
<li><p>第三：当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。</p>
</li>
<li><p>第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用”return 值;”这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。</p>
</li>
<li><p>第五：只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。</p>
</li>
<li><p>第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。</p>
</li>
<li><p>第七：除了void之外，剩下的都必须有“return 值;”这样的语句。</p>
</li>
</ul>
<p>形式参数列表</p>
<ul>
<li><p>简称：形参</p>
</li>
<li><p>注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。</p>
</li>
<li><p>形参的个数是：0~N个。</p>
</li>
<li><p>public static void sumInt(){}</p>
</li>
<li><p>public static void sumInt(int x){}</p>
</li>
<li><p>形参有多个的话使用“逗号,”隔开。逗号是英文的。形参的数据类型起决定性作用，形参对应的变量名是随意的。</p>
</li>
</ul>
<p>方法体：</p>
<ul>
<li><p>由Java语句构成。java语句以“;”结尾。方法体当中编写的是代码，完成某个特定功能。</p>
</li>
<li><p>在方法体中的代码遵循自上而下的顺序依次逐行执行。</p>
</li>
<li><p>在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。</p>
</li>
</ul>
<p>怎么调用呢</p>
<ul>
<li><p>类名.方法名(实际参数列表);	</p>
</li>
<li><p>实参和形参的类型必须一一对应，个数也要一一对应。</p>
</li>
</ul>
<p>你定义了一个&#x2F;抽取了一个方法出来，而这个方法确无法完成某个功能，那么你抽取的这个方法毫无意义。般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。</p>
<p>“类名.”是可以省略</p>
<ul>
<li>a()方法调用b()方法的时候，a和b方法都在同一个类中，“类名.”可以省略。如果不在同一个类中“类名.”不能省略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同一个域当中，&quot;return语句&quot;下面不能再编写其它代码。编写之后编译报错。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//错误: 无法访问的语句</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;hello1&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这行代码和上面的代码hello1的区别是：不在同一个域当中。</span></span><br><span class="line">	<span class="comment">//System.out.println(&quot;hello2&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 错误: 无法访问的语句</span></span><br><span class="line">	<span class="comment">//System.out.println(&quot;hello3&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>注意：如果功能不相似，坚决要让方法名不一致。</p>
<p>重载条件</p>
<ul>
<li>条件1：在同一个类当中</li>
<li>条件2：方法名相同</li>
<li>条件3：形式参数列表不同（类型、个数、顺序）</li>
</ul>
<p>注意：方法重载和返回值类型无关，和修饰符列表无关。</p>
<p>在java语言中，是怎么进行方法区分的？</p>
<ul>
<li>首先java编译器会通过<strong>方法名</strong>进行区分。</li>
<li>但是在java语言中允许方法名相同的情况出现。</li>
<li>如果方法名相同的情况下，编译器会通过<strong>方法的参数类型</strong>进行方法的区分。</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ul>
<li><p>方法自身调用自身。</p>
</li>
<li><p>使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。</p>
</li>
<li><p>StackOverflowError  原因：一直压栈，没有弹栈，栈内存不够用。</p>
</li>
<li><p>能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。JVM发生错误之后只有一个结果，就是退出JVM。当然，只有极少数情况下，只能用递归，其它代码解决不了问题。</p>
</li>
<li><p>当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？<br>也不一定。可能递归的太深了。栈内存不够了。因为一直在压栈。</p>
</li>
<li><p>在实际的开发中，不建议轻易的选择递归，能用for循环while循环代替的，尽量使用循环来做。因为循环的效率高，耗费的内存少。递归耗费的内存比较大，另外递归的使用不当，会导致JVM死掉。(但在极少数的情况下，不用递归，这个程序没法实现。)所以：递归我们还是要认真学习的。</p>
</li>
</ul>
<blockquote>
<ul>
<li>在实际的开发中，假设有一天你真正的遇到了：StackOverflowError 你怎么解决这个问题，可以谈一下你的思路吗？</li>
<li>我来谈一下我的个人思路：<ul>
<li>第一步：先检查递归的结束条件对不对。如果递归结束条件不对，必须对条件进一步修改，直到正确为止。</li>
<li>第二步：假设递归条件没问题，怎么办？这个时候需要手动的调整JVM的栈内存初始化大小。可以将栈内存的空间调大点。（可以调整大一些。）				</li>
<li>第三步：调整了大小，如果运行时还是出现这个错误，没办法，只能继续扩大栈的内存大小。</li>
</ul>
</li>
</ul>
</blockquote>
<p>(java -X)这个可以查看调整堆栈大小的参数</p>
<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向过程有什么缺点？（耦合度高，扩展力差。）</p>
<ul>
<li>面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果关系结合在一起，假设其中任何一个因果关系出现问题（错误），此时整个系统的运转都会出现问题。（代码和代码之间的耦合度太高，扩展力太差。）</li>
</ul>
<p>面向过程有什么优点？（快速开发）</p>
<ul>
<li>对于小型项目（功能），采用面向过程的方式进行开发，效率较高。不需要前期进行对象的提取，模型的建立，采用面向过程方式可以直接开始干活。一上来直接写代码，编写因果关系，从而实现功能。</li>
</ul>
<p>什么是面向对象的开发方式？</p>
<ul>
<li><p>采用面向对象的方式进行开发，更符合人类的思维方式。（面向对象成为主流的原因）人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。</p>
</li>
<li><p>面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后给一个环境驱动一下，让各个对象之间协作起来形成一个系统。</p>
</li>
<li><p>采用面向对象的方式进行开发：耦合度低，扩展力强。</p>
</li>
<li><p>面向对象当中最主要“一词”是：对象。</p>
</li>
</ul>
<p>什么是类？</p>
<ul>
<li><p>实际上在现实世界当中是不存在的，是一个抽象的概念。是一个模板。是我们人类大脑进行“思考、总结、抽象”的一个结果。(主要是因为人类的大脑不一般才有了类的概念。)</p>
</li>
<li><p>类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。</p>
</li>
</ul>
<p>什么是对象？对象是实际存在的个体。（真实存在的个体）</p>
<p>这几个术语你需要自己能够阐述出来：</p>
<ul>
<li><p>类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）</p>
</li>
<li><p>对象：实际存在的个体。</p>
</li>
<li><p>实例：对象还有另一个名字叫做实例。</p>
</li>
<li><p>实例化：通过类这个模板创建对象的过程，叫做：实例化。</p>
</li>
<li><p>抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。</p>
</li>
</ul>
<p>类 –【实例化】–&gt; 对象(实例)</p>
<p>对象 –【抽象】–&gt; 类</p>
<p>类是一个模板，是描述共同特征的一个模板，那么共同特征包括什么呢？</p>
<p>类 &#x3D; 属性 + 方法</p>
<p>属性来源于：状态</p>
<p>方法来源于：动作</p>
<p>思考：“java软件工程师”在开发中起到的一个作用是什么？</p>
<p>我们为什么要做软件开发？说的大一些是为了人民服务。解决现实生活当中的问题。软件开发既然是为了解决现实世界当中的问题，那么首先java软件必须能够模拟现实世界。其实软件是一个虚拟的世界。这个虚拟的世界需要和现实世界一一对应，这才叫模拟。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">    <span class="comment">// 类体 = 属性 + 方法</span></span><br><span class="line">    <span class="comment">// 属性在代码上以“变量”的形式体现</span></span><br><span class="line">    <span class="comment">//方法描述动作、行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XueSheng</span>&#123; <span class="comment">// 这个程序编译之后，会生成XueSheng.class字节码文件。</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 学号（成员变量）</span></span><br><span class="line">    <span class="type">int</span> xueHao;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    String xingMing;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="type">int</span> nianLing;</span><br><span class="line">    <span class="comment">// 性别</span></span><br><span class="line">    <span class="type">boolean</span> xingBie;</span><br><span class="line">    <span class="comment">// 住址</span></span><br><span class="line">    String zhuZhi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：修饰符列表可以省略。</p>
<p>为什么属性是“以”变量的形式存在的？是因为属性对应的是“数据”，数据在程序中只能放到变量中。结论：属性其实就是变量。</p>
<p>变量根据出现位置进行划分：</p>
<ul>
<li><p>方法体当中声明的变量：局部变量。</p>
</li>
<li><p>方法体外声明的变量：成员变量。（这里的成员变量就是“属性”）</p>
</li>
</ul>
<p>关于编译的过程</p>
<ul>
<li><p>按说应该先编译XueSheng.java，然后再编译XueShengTest.java</p>
</li>
<li><p>但是对于编译器来说，编译XueShengTest.java文件的时候，会自动找XueSheng.class，如果没有，会自动编译XueSheng.java文件，生成XueSheng.class文件。</p>
</li>
</ul>
<p>编译方法：</p>
<p>第一种方式：</p>
<ul>
<li><p>javac XueSheng.java</p>
</li>
<li><p>javac XueShengTest.java</p>
</li>
</ul>
<p>第二种方式：</p>
<ul>
<li>javac XueShengTest.java</li>
</ul>
<p>第三种方式：</p>
<ul>
<li>javac *.java</li>
</ul>
<p>在语法级别上是怎么完成对象创建的呢？</p>
<ul>
<li>类名 变量名 &#x3D; new 类名();</li>
</ul>
<p>什么是实例变量？</p>
<ul>
<li>对象又被称为实例。</li>
<li>实例变量实际上就是：对象级别的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 明星类&#123;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>身高这个属性所有的明星对象都有，但是每一个对象都有“自己的身高值”。</p>
</li>
<li><p>假设创建10个明星对象，height变量应该有10份。</p>
</li>
<li><p>所以这种变量被称为对象级别的变量。属于实例变量。</p>
</li>
</ul>
<p>实例变量在访问的时候，是不是必须先创建对象？是</p>
<p>对象和引用的区别？</p>
<ul>
<li><p>对象是通过new出来的，在堆内存中存储。</p>
</li>
<li><p>引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。</p>
</li>
</ul>
<p>成员变量的默认值</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>flase</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h3><p>1、画内存图注意事项：</p>
<ul>
<li><p>第一：大家在内存图上不要体现出代码。内存上应该主要体现“数据”。</p>
</li>
<li><p>第二：大家画图的时候，图上的图形应该有先后顺序，先画什么，再画什么，必须是有顺序的，而不是想起来这个画这个，想起来那个画那个。程序代码是有执行顺序的，程序执行到哪里你就画哪里就行了。</p>
</li>
</ul>
<p>2、为什么要画内存图（非常重要）？</p>
<ul>
<li><p>第一：有了内存图，程序不运行，我也知道结果。（可以推算出结果）</p>
</li>
<li><p>第二：有了内存图，有助于你调试程序。画内存图是对Java运行机制的一种理解。不知道运行机制，以后复杂的程序出现错误之后你是不会调试的。</p>
</li>
</ul>
<p>所有的实例变量（属性）都是通过“引用.”来访问的。</p>
<p>引用和对象怎么区分？</p>
<ul>
<li><p>“引用”是是存储对象内存地址的一个变量。</p>
</li>
<li><p>“对象”是堆里new出来的。</p>
</li>
</ul>
<p>通俗一点：</p>
<ul>
<li>只要这个变量中保存的是一个对象的内存地址，那么这个变量就叫做“引用”。</li>
</ul>
<p>思考：</p>
<ul>
<li>引用一定是局部变量吗？不一定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 家庭住址对象</span></span><br><span class="line">        <span class="type">Address</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        a.city = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line">        a.street = <span class="string">&quot;大兴区&quot;</span>;</span><br><span class="line">        a.zipcode = <span class="string">&quot;121221&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        System.out.println(u.id); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(u.username); <span class="comment">// null</span></span><br><span class="line">        System.out.println(u.addr); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        u.id = <span class="number">11111</span>;</span><br><span class="line">        u.username = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        u.addr = a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 实例变量</span></span><br><span class="line">    String username; <span class="comment">// 实例变量</span></span><br><span class="line">    Address addr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 住址类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个家庭住址有3个属性。</span></span><br><span class="line">    <span class="comment">// 城市</span></span><br><span class="line">    String city; <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="comment">// 街道</span></span><br><span class="line">    String street;</span><br><span class="line">    <span class="comment">// 邮编</span></span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>空指针异常。（NullPointerException）</p>
<p>关于垃圾回收器：GC</p>
<ul>
<li>在java语言中，垃圾回收器主要针对的是堆内存。当一个java对象没有任何引用指向该对象的时候，GC会考虑将该垃圾数据释放回收掉。</li>
</ul>
<p>出现空指针异常的前提条件是？”空引用”访问实例【对象相关】相关的数据时，都会出现空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建客户对象</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        <span class="comment">// 访问这个客户的id</span></span><br><span class="line">        System.out.println(c.id); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新给id赋值</span></span><br><span class="line">        c.id = <span class="number">9521</span>; <span class="comment">// 终身代号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户的id是=&quot;</span> + c.id);</span><br><span class="line">        <span class="comment">//c = null;</span></span><br><span class="line">        <span class="comment">// NullPointerException</span></span><br><span class="line">        <span class="comment">// 编译器没问题，因为编译器只检查语法，编译器发现c是Customer类型，</span></span><br><span class="line">        <span class="comment">// Customer类型中有id属性，所以可以：c.id。语法过了。</span></span><br><span class="line">        <span class="comment">// 但是运行的时候需要对象的存在，但是对象没了，尴尬了，就只能出现一个异常。</span></span><br><span class="line">        System.out.println(c.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="comment">// 客户id</span></span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 成员变量中的实例变量，应该先创建对象，然后通过“引用.”的方式访问。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法在调用的时候参数是如何传递的？</p>
<ul>
<li>实际上，在java语言中，方法调用时参数传递，和类型无关，都是将变量中保存的那个“值”传过去，这个“值”可能是一个数字100，也可能是一个java对象的内存地址：0x1234记住这句话：不管是哪一种数据类型的传递，都是将“变量中保存的那个值复制一份传递过去。”</li>
</ul>
<p>java中关于方法调用时参数传递实际上只有一个规则：</p>
<ul>
<li>不管你是基本数据类型，还是引用数据类型，实际上在传递的时候都是将变量中保存的那个“值”复制一份，传过去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 把x中保存1复制一份传给y</span></span><br><span class="line"><span class="comment">// x和y都是两个局部变量。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0x1234</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1; 把p1中保存的<span class="number">0x1234</span>复制一份传给p2</span><br><span class="line"><span class="comment">// p1和p2都是两个局部变量。</span></span><br></pre></td></tr></table></figure>

<p>你和你媳妇，都有你家大门上的钥匙，钥匙是两把。<br>但是都可以打开你家的大门。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        add(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;main---&gt;&quot;</span> + p.age); <span class="comment">//11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法的参数可以是基本数据类型，也可以是引用数据类型，只要是合法的数据类型就行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Person p)</span>&#123; <span class="comment">// p是add方法的局部变量。</span></span><br><span class="line">        p.age++;</span><br><span class="line">        System.out.println(<span class="string">&quot;add---&gt;&quot;</span> + p.age); <span class="comment">//11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">// 年龄属性，成员变量中的实例变量。</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参数的构造方法叫做缺省构造器。</p>
<p>当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。</p>
<p>建议将无参数构造方法手动的写出来，这样一定不会出问题。</p>
<p>无参数构造方法和有参数的构造方法都可以调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>构造方法支持方法重载吗？</p>
<ul>
<li><p>构造方法是支持方法重载的。</p>
</li>
<li><p>在一个类当中构造方法可以有多个。</p>
</li>
<li><p>并且所有的构造方法名字都是一样的。</p>
</li>
<li><p>特点：在同一个类中，方法名相同，参数列表不同。</p>
</li>
</ul>
<p>对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。</p>
<p>构造方法需要掌握的知识点：</p>
<ol>
<li><p>构造方法有什么作用？</p>
</li>
<li><p>构造方法怎么定义，语法是什么？</p>
</li>
<li><p>构造方法怎么调用，使用哪个运算符？</p>
</li>
<li><p>什么是缺省构造器？</p>
</li>
<li><p>怎么防止缺省构造器丢失？</p>
</li>
<li><p>实例变量在类加载是初始化吗？实例变量在什么时候初始化？</p>
</li>
</ol>
<p>构造方法</p>
<p>1、什么是构造方法，有什么用？</p>
<ul>
<li>构造方法是用来创建对象，并且同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统会赋默认值。）</li>
</ul>
<p>2、当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法。（而这个构造方法被称为缺省构造器。）</p>
<p>3、调用构造方法怎么调用呢？使用哪个运算符呢？使用new运算符来调用构造方法。<code>new 构造方法名(实际参数列表);</code></p>
<p>4、构造方法的语法结构是？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形式参数列表)&#123;</span><br><span class="line">    构造方法体;</span><br><span class="line">    通常在构造方法体当中给属性赋值，完成属性的初始化。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>修饰符列表目前统一写：public。千万不要写public static。</p>
</li>
<li><p>构造方法名和类名必须一致。</p>
</li>
<li><p>构造方法不需要指定返回值类型，也不能写void，写上void表示普通方法，就不是构造方法了。</p>
</li>
</ol>
<p>普通方法的语法结构是？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、构造方法对应的英语单词：Constructor【构造器】</p>
<p>2、构造方法作用：</p>
<ul>
<li>创建对象，并且创建对象的过程中给属性赋值（初始化。）</li>
</ul>
<p>以后开发的时候最好自己写出来一个默认无参构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Student类的无参数构造方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用普通方法</span></span><br><span class="line">        ConstructorTest01.doSome();</span><br><span class="line">        doSome();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Student类型的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出“引用”</span></span><br><span class="line">        <span class="comment">//只要输出结果不是null，说明这个对象一定是创建完成了。</span></span><br><span class="line">        <span class="comment">// 此处的输出结果大家目前是看不懂的，后期再说。</span></span><br><span class="line">        System.out.println(s1); <span class="comment">//Student@54bedef2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是调用另一个有参数的构造方法。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s3); <span class="comment">//Student@5caf905d</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do some!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装、this和static"><a href="#封装、this和static" class="headerlink" title="封装、this和static"></a>封装、this和static</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>有了封装，才有继承，有了继承，才能说多态。</p>
<p>封装的作用有两个：</p>
<ul>
<li><p>第一个作用：保证内部结构的安全。</p>
</li>
<li><p>第二个作用：屏蔽复杂，暴露简单。</p>
</li>
</ul>
<p>在代码级别上，封装有什么用？</p>
<ul>
<li><p>一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。</p>
</li>
<li><p>类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。</p>
</li>
</ul>
<p>怎么进行封装</p>
<ul>
<li><p>第一步：属性私有化（使用private关键字进行修饰。）</p>
</li>
<li><p>第二步：对外提供简单的操作入口。</p>
</li>
</ul>
<p>第一步：属性私有化</p>
<p>第二步：1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。</p>
<p>在强调一下：</p>
<ul>
<li><p>set和get方法都是实例方法，<strong>不能带static</strong>。</p>
</li>
<li><p>不带static的方法称为实例方法，实例方法的调用必须先new对象。</p>
</li>
</ul>
<h4 id="封装过程"><a href="#封装过程" class="headerlink" title="封装过程"></a>封装过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">// private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。</span></span><br><span class="line">    <span class="comment">// 出了这个类，age属性就无法访问了。私有的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 每一个人年龄值不同，对象级别的属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法专门来完成读。(get)</span></span><br><span class="line">    <span class="comment">// 写一个方法专门来完成写。(set)</span></span><br><span class="line">    <span class="comment">// get和set方法应该带有static，还是不应该有static,get和set方法应该定义为实例方法吗？</span></span><br><span class="line">    <span class="comment">// get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）</span></span><br><span class="line">    <span class="comment">// 封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [修饰符列表] 返回值类型 方法名(形式参数列表)&#123;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">            java开发规范中有要求，set方法和get方法要满足以下格式。</span></span><br><span class="line"><span class="comment">                get方法的要求：</span></span><br><span class="line"><span class="comment">                    public 返回值类型 get+属性名首字母大写(无参)&#123;</span></span><br><span class="line"><span class="comment">                        return xxx;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                set方法的要求：</span></span><br><span class="line"><span class="comment">                    public void set+属性名首字母大写(有1个参数)&#123;</span></span><br><span class="line"><span class="comment">                        xxx = 参数;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            大家尽量按照java规范中要求的格式提供set和get方法。</span></span><br><span class="line"><span class="comment">            如果不按照这个规范格式来，那么你的程序将不是一个通用的程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// get方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> nianLing)</span>&#123;</span><br><span class="line">        <span class="comment">// 能不能在这个位置上设置关卡！！！！</span></span><br><span class="line">        <span class="keyword">if</span>(nianLing &lt; <span class="number">0</span> || nianLing &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，年龄值不合法，请重新赋值！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//直接终止程序的执行。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//程序能够执行到这里，说明年龄一定是合法的。</span></span><br><span class="line">        age = nianLing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="static方法调用方式"><a href="#static方法调用方式" class="headerlink" title="static方法调用方式"></a>static方法调用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有static的方法</span></span><br><span class="line"><span class="comment">//没有static的方法</span></span><br><span class="line"><span class="comment">//分别怎么调用？</span></span><br><span class="line">    <span class="comment">//带有static的方法怎么调用？通过“类名.”的方式访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象被称为实例。</span></span><br><span class="line"><span class="comment">//实例相关的有：实例变量、实例方法。</span></span><br><span class="line"><span class="comment">//实例变量是对象变量。实例方法是对象方法。</span></span><br><span class="line"><span class="comment">//实例相关的都需要先new对象，通过“引用.”的方式去访问。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public MethodTest()&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        MethodTest.doSome();</span><br><span class="line">        <span class="comment">//类名. 可以省略（在同一个类中。）</span></span><br><span class="line">        doSome();</span><br><span class="line">        <span class="comment">// 尝试使用“类名.”的方式访问“实例方法”</span></span><br><span class="line">        <span class="comment">// 错误的</span></span><br><span class="line">        <span class="comment">//MethodTest.doOther();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MethodTest</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodTest</span>();</span><br><span class="line">        <span class="comment">// 通过&quot;引用.&quot;的方式访问实例方法。</span></span><br><span class="line">        mt.doOther();</span><br><span class="line"></span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有static</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do some!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法没有static，这样的方法被称为：实例方法。（对象方法，对象级别的方法）</span></span><br><span class="line">    <span class="comment">//这个没法解释，大家目前死记硬背。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do other....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再探空指针异常"><a href="#再探空指针异常" class="headerlink" title="再探空指针异常"></a>再探空指针异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空指针异常导致的最本质的原因是？</span></span><br><span class="line"><span class="comment">    空引用访问“实例相关的数据”，会出现空指针异常。</span></span><br><span class="line"><span class="comment">    实例相关的包括：实例变量 + 实例方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        System.out.println(u.id); <span class="comment">// 0</span></span><br><span class="line">        u.doSome();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用变成空null</span></span><br><span class="line">        u = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// id的访问，需要对象的存在。</span></span><br><span class="line">        <span class="comment">//System.out.println(u.id); // 空指针异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个实例方法的调用也必须有对象的存在。</span></span><br><span class="line">        <span class="comment">//u.doSome(); // 空指针异常。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 = 属性 + 方法</span></span><br><span class="line"><span class="comment">// 属性描述状态</span></span><br><span class="line"><span class="comment">// 方法描述行为动作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法（对象相关的方法，对象级别的方法，应该是一个对象级别的行为。）</span></span><br><span class="line">    <span class="comment">// 方法模拟的是对象的行为动作。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do some!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考试的行为，由于每一个人考试之后的分数不一样，所以考试行为应该必须有对象的参与。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。</p>
<p>当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。</p>
<h4 id="实例和静态"><a href="#实例和静态" class="headerlink" title="实例和静态"></a>实例和静态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    static:</span></span><br><span class="line"><span class="comment">        1、static翻译为“静态”</span></span><br><span class="line"><span class="comment">        2、所有static关键字修饰的都是类相关的，类级别的。</span></span><br><span class="line"><span class="comment">        3、所有static修饰的，都是采用“类名.”的方式访问。</span></span><br><span class="line"><span class="comment">        4、static修饰的变量：静态变量</span></span><br><span class="line"><span class="comment">        5、static修饰的方法：静态方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    变量的分类：</span></span><br><span class="line"><span class="comment">        变量根据声明的位置进行划分：</span></span><br><span class="line"><span class="comment">            在方法体当中声明的变量叫做：局部变量。</span></span><br><span class="line"><span class="comment">            在方法体外声明的变量叫做：成员变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        成员变量又可以分为：</span></span><br><span class="line"><span class="comment">            实例变量</span></span><br><span class="line"><span class="comment">            静态变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下实例的，都是对象相关的，访问时采用“引用.”的方式访问。需要先new对象。</span></span><br><span class="line">    <span class="comment">// 实例相关的，必须先有对象，才能访问，可能会出现空指针异常。</span></span><br><span class="line">    <span class="comment">// 成员变量中的实例变量</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下静态的，都是类相关的，访问时采用“类名.”的方式访问。不需要new对象。</span></span><br><span class="line">    <span class="comment">// 不需要对象的参与即可访问。没有空指针异常的发生。</span></span><br><span class="line">    <span class="comment">// 成员变量中的静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么时候变量声明为实例的，什么时候声明为静态的？</span></span><br><span class="line"><span class="comment">        如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议定义为类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一个对象一份的是实例变量。</span></span><br><span class="line"><span class="comment">    所有对象一份的是静态变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类：中国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 身份证号</span></span><br><span class="line">    <span class="comment">// 每一个人的身份证号不同，所以身份证号应该是实例变量，一个对象一份。</span></span><br><span class="line">    String idCard; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="comment">// 姓名也是一个人一个姓名，姓名也应该是实例变量。</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 国籍</span></span><br><span class="line">    <span class="comment">// 重点重点五颗星：加static的变量叫做静态变量</span></span><br><span class="line">    <span class="comment">// 静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。</span></span><br><span class="line">    <span class="comment">// 静态变量存储在方法区。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">        idCard = s1;</span><br><span class="line">        name = s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实例的：一定需要使用“引用.”来访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    静态的：</span></span><br><span class="line"><span class="comment">        建议使用“类名.”来访问，但使用“引用.”也行（不建议使用&quot;引用.&quot;）。</span></span><br><span class="line"><span class="comment">        静态的如果使用“引用.”来访问会让程序员产生困惑：程序员以为是实例的呢。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    结论：</span></span><br><span class="line"><span class="comment">        空指针异常只有在什么情况下才会发生呢?只有在“空引用”访问“实例”相关的，都会出现空指针异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于方法来说，什么时候定义为实例方法？什么时候定义为静态方法？</span></span><br><span class="line"><span class="comment">        有没有参考标准。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        此方法一般都是描述了一个行为，如果说该行为必须由对象去触发。</span></span><br><span class="line"><span class="comment">        那么该方法定义为实例方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        参考标准：</span></span><br><span class="line"><span class="comment">            当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            我们以后开发中，大部分情况下，如果是工具类的话，工具类当中的方法</span></span><br><span class="line"><span class="comment">            一般都是静态的。(静态方法有一个优点，是不需要new对象，直接采用类名</span></span><br><span class="line"><span class="comment">            调用，极其方便。工具类就是为了方便，所以工具类中的方法一般都是static的。)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            什么是工具类？？？？？</span></span><br><span class="line"><span class="comment">                以后讲。（工具类就是为了方便编程而开发的一些类。）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    类 = 属性 + 方法</span></span><br><span class="line"><span class="comment">        属性描述的是：状态</span></span><br><span class="line"><span class="comment">        方法描述的是：行为动作</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    一个方法代表了一个动作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、使用static关键字可以定义：静态代码块</span></span><br><span class="line"><span class="comment">    2、什么是静态代码块，语法是什么？</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment">            java语句;</span></span><br><span class="line"><span class="comment">            java语句;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    3、static静态代码块在什么时候执行呢？</span></span><br><span class="line"><span class="comment">        类加载时执行。并且只执行一次。</span></span><br><span class="line"><span class="comment">        静态代码块有这样的特征/特点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    5、静态代码块一般是按照自上而下的顺序执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    6、静态代码块有啥作用，有什么用？</span></span><br><span class="line"><span class="comment">        第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）</span></span><br><span class="line"><span class="comment">        第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。这个时机叫做：类加载时机。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    具体的业务：</span></span><br><span class="line"><span class="comment">        项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。</span></span><br><span class="line"><span class="comment">    思考：这些记录日志的代码写到哪里呢？</span></span><br><span class="line"><span class="comment">        写到静态代码块当中。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest06</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块（特殊的时机：类加载时机。）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类当中可以编写多个静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">Hello World!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈：方法只要执行，会压栈。（局部变量）</span></span><br><span class="line"><span class="comment">    堆：new出来的对象都在堆中。垃圾回收器主要针对。（实例变量）</span></span><br><span class="line"><span class="comment">    方法区：类的信息，字节码信息，代码片段。（静态变量）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    方法的代码片段放在方法区，但是方法执行过程当中需要的内存在栈中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest07</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态变量在什么时候初始化？类加载时初始化。</span></span><br><span class="line">    <span class="comment">// 静态变量存储在哪里？方法区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块什么时候执行？类加载时执行。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问i吗？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">111</span>; <span class="comment">// k变量是实例变量，在构造方法执行时内存空间才会开辟。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//k变量可以访问吗？</span></span><br><span class="line">        <span class="comment">// static静态代码块在类加载时执行，并且只执行一次。</span></span><br><span class="line">        <span class="comment">// 类加载时，k变量空间还没有开辟出来呢。</span></span><br><span class="line">        <span class="comment">//错误: 无法从静态上下文中引用非静态 变量 k</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;k = &quot; + k);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以访问name吗？</span></span><br><span class="line">        <span class="comment">//错误: 非法前向引用</span></span><br><span class="line">        <span class="comment">// 静态代码块和静态变量都在类加载的时候执行，时间相同，只能靠代码的顺序来决定谁先谁后。</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;name = &quot; + name);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量在静态代码块下面。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入口(main方法执行之前实际上执行了很多代码)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">    到目前为止，你遇到的所有java程序，有顺序要求的是哪些？</span></span><br><span class="line"><span class="comment">        第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。</span></span><br><span class="line"><span class="comment">        第二：静态代码块1和静态代码块2是有先后顺序的。</span></span><br><span class="line"><span class="comment">        第三：静态代码块和静态变量是有先后顺序的。(代码的顺序)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="实例语句块"><a href="#实例语句块" class="headerlink" title="实例语句块"></a>实例语句块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、除了静态代码块之外，还有一种语句块叫做：实例语句块</span></span><br><span class="line"><span class="comment">2、实例语句在类加载是并没有执行。</span></span><br><span class="line"><span class="comment">3、实例语句语法？</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        java语句;</span></span><br><span class="line"><span class="comment">        java语句;</span></span><br><span class="line"><span class="comment">        java语句;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">4、实例语句块在什么时候执行？</span></span><br><span class="line"><span class="comment">    只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。</span></span><br><span class="line"><span class="comment">    实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCode</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstanceCode</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstanceCode</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例语句块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例语句块执行！&quot;</span>);	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InstanceCode</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InstanceCode</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断以下程序的执行顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeOrder</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="comment">// A X Y C B Z</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeOrder</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例语句块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>this是一个关键字，是一个引用，保存内存地址指向自身。</li>
<li>this可以使用在实例方法中，也可以使用在构造方法中。</li>
<li>this出现在实例方法中其实代表的是当前对象。</li>
<li>this不能使用在静态方法中。</li>
<li>this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。</li>
<li>this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    this：</span></span><br><span class="line"><span class="comment">        1、this是一个关键字，全部小写。</span></span><br><span class="line"><span class="comment">        2、this是什么，在内存方面是怎样的？</span></span><br><span class="line"><span class="comment">            一个对象一个this。</span></span><br><span class="line"><span class="comment">            this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。</span></span><br><span class="line"><span class="comment">            所以，严格意义上来说，this代表的就是“当前对象”</span></span><br><span class="line"><span class="comment">            this存储在堆内存当中对象的内部。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、this只能使用在实例方法中。谁调用这个实例方法，this就是谁。所以this代表的是：当前对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、“this.”大部分情况下是可以省略的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        5、为什么this不能使用在静态方法中？this代表当前对象，静态方法中不存在当前对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顾客类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 实例变量（必须采用“引用.”的方式访问）</span></span><br><span class="line">    String name;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顾客购物的方法</span></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 这里的this是谁？this是当前对象。</span></span><br><span class="line">        <span class="comment">// c1调用shopping(),this是c1</span></span><br><span class="line">        <span class="comment">// c2调用shopping(),this是c2</span></span><br><span class="line">        <span class="comment">//System.out.println(this.name + &quot;正在购物!&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// this. 是可以省略的。</span></span><br><span class="line">        <span class="comment">// this. 省略的话，还是默认访问“当前对象”的name。</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在购物!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// this代表的是当前对象，而静态方法的调用不需要对象。矛盾了。</span></span><br><span class="line">        <span class="comment">// 错误: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">        <span class="comment">//System.out.println(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量，怎么访问？必须先new对象，通过“引用.”来访问。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// this代表的是当前对象。</span></span><br><span class="line">        <span class="comment">//System.out.println(this.name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除非你这样</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(s.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么set和get方法是实例方法？this不能出现在静态方法中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 又回到上午的问题了？什么时候方法定义为实例方法，什么时候定义为静态方法？</span></span><br><span class="line">    <span class="comment">// 如果方法中直接访问了实例变量，该方法必须是实例方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592899792382.png" title="1592899792382" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592899792382.png" alt="1592899792382"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 分析：i变量在main方法中能不能访问？？？？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisTest02</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 这个i变量是不是必须先new对象才能访问。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 错误: 无法从静态上下文中引用非静态 变量 i</span></span><br><span class="line">        <span class="comment">// System.out.println(i);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 怎么样访问i</span></span><br><span class="line">        <span class="type">ThisTest02</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThisTest02</span>();</span><br><span class="line">        System.out.println(tt.i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态变量用“类名.”访问。</span></span><br><span class="line">        System.out.println(ThisTest02.k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类名. 能不能省略？</span></span><br><span class="line">        <span class="comment">// 可以</span></span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this什么时候可以省略？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、this可以使用在实例方法中，不能使用在静态方法中。</span></span><br><span class="line"><span class="comment">2、this关键字大部分情况下可以省略，什么时候不能省略呢？</span></span><br><span class="line"><span class="comment">    在实例方法中，或者构造方法中，为了区分局部变量和实例变量，</span></span><br><span class="line"><span class="comment">    这种情况下：this. 是不能省略的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisTest03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setNo(<span class="number">111</span>);</span><br><span class="line">        s.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;学号：&quot;</span> + s.getNo());</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析一下：以下代码哪里写的不好。</span></span><br><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void setNo(int i)&#123;</span></span><br><span class="line"><span class="comment">        no = i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void setNo(int no)&#123; // 就近原则。</span></span><br><span class="line"><span class="comment">        no = no; //这两个no都是局部变量no，和实例变量no没关系。</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span>&#123; </span><br><span class="line">        <span class="comment">//no是局部变量</span></span><br><span class="line">        <span class="comment">//this.no 是指的实例变量。</span></span><br><span class="line">        <span class="built_in">this</span>.no = no; <span class="comment">// this. 的作用是：区分局部变量和实例变量。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="comment">// getName实际上获取的是“当前对象”的名字。</span></span><br><span class="line">        <span class="comment">//return this.name; // 严格来说，这里是有一个 this. 的。只不过这个 this. 是可以省略的。</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this()的使用时机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、this除了可以使用在实例方法中，还可以用在构造方法中。</span></span><br><span class="line"><span class="comment">    2、新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：</span></span><br><span class="line"><span class="comment">        this(实际参数列表);</span></span><br><span class="line"><span class="comment">            通过一个构造方法1去调用构造方法2，可以做到代码复用。</span></span><br><span class="line"><span class="comment">            但需要注意的是：“构造方法1”和“构造方法2” 都是在同一个类当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3、this() 这个语法作用是什么？</span></span><br><span class="line"><span class="comment">        代码复用。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    4、死记硬背：</span></span><br><span class="line"><span class="comment">        对于this()的调用只能出现在构造方法的第一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisTest04</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用无参数构造方法</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        d1.detail();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用有参数构造方法</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        d2.detail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：</span></span><br><span class="line"><span class="comment">    1、定义一个日期类，可以表示年月日信息。</span></span><br><span class="line"><span class="comment">    2、需求中要求：</span></span><br><span class="line"><span class="comment">        如果调用无参数构造方法，默认创建的日期为：1970年1月1日。</span></span><br><span class="line"><span class="comment">        当然，除了调用无参数构造方法之外，也可以调用有参数的构造方法来创建日期对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123; <span class="comment">// 以后写代码都要封装，属性私有化，对外提供setter and getter</span></span><br><span class="line">    <span class="comment">//年</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="comment">//月</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="comment">//日</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法无参</span></span><br><span class="line">    <span class="comment">// 调用无参数构造方法，初始化的日期是固定值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//错误: 对this的调用必须是构造器中的第一个语句</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法有参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this 复习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Review</span>&#123; <span class="comment">// 类</span></span><br><span class="line">    <span class="comment">// 类加载机制中，是这样的：在程序执行之前，凡是需要加载的类全部加载到JVM当中。</span></span><br><span class="line">    <span class="comment">// 先完成加载才会执行main方法。</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Review类加载时执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 完成一个对象的一连串动作。</span></span><br><span class="line">        <span class="comment">// 一个学生在教室先学习，学习完成之后去餐厅吃饭。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 先学习，所有调用学习这个实例方法。</span></span><br><span class="line">        s1.study();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的作用：<br>基本作用：子类继承父类，代码可以得到复用。（这个不是重要的作用，是基本作用。）<br>主要(重要)作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用继承机制来解决代码复用问题。</span></span><br><span class="line"><span class="comment">// 继承也是存在缺点的：耦合度高，父类修改，子类受牵连。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行账户类</span></span><br><span class="line"><span class="comment">// 账户的属性：账号、余额</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123; <span class="comment">// 父类</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String actno;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String actno, <span class="type">double</span> balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setActno</span><span class="params">(String actno)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getActno</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它类型的账户：信用卡账户</span></span><br><span class="line"><span class="comment">// 账号、余额、信誉度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditAccount</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123; <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> credit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreditAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//错误: actno 在 Account 中是 private 访问控制</span></span><br><span class="line">        <span class="comment">//System.out.println(actno);</span></span><br><span class="line">        <span class="comment">// 间接访问</span></span><br><span class="line">        <span class="comment">//System.out.println(this.getActno());</span></span><br><span class="line">        System.out.println(getActno());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCredit</span><span class="params">(<span class="type">double</span> credit)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.credit = credit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCredit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> credit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h3><ol>
<li><p>①B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。<br>class A{}<br>class B extends A{}<br>我们平时聊天说的比较多的是：父类和子类。superclass 父类, subclass 子类</p>
</li>
<li><p>java 中的继承只支持单继承，<strong>不支持多继承</strong>，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：class B extends A,C{ } 这是错误的。</p>
</li>
<li><p>虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。</p>
</li>
<li><p>java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)</p>
</li>
<li><p>java 中的类没有显示的继承任何类，则<strong>默认继承 Object类</strong>，Object类是java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有Object类型中所有的特征。</p>
</li>
<li><p>继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CeditAccount 类</p>
</li>
</ol>
<p>子类继承父类之后，能使用子类对象调用父类方法吗？可以，因为子类继承了父类之后，这个方法就属于子类了。当然可以使用子类对象来调用。</p>
<p>在实际开发中，满足什么条件的时候，我可以使用继承呢？<br>凡是采用“is a”能描述的，都可以继承。<br>例如：<br>Cat is a Animal：猫是一个动物<br>Dog is a Animal：狗是一个动物<br>CreditAccount is a Account：信用卡账户是一个银行账户<br>….</p>
<p>假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，<br>那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够<br>使用is a来描述。</p>
<p>我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()的，我们进行了测试，发现：System.out.println(引用); 当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后输出toString()方法的执行结果。</p>
<h2 id="方法覆盖和多态"><a href="#方法覆盖和多态" class="headerlink" title="方法覆盖和多态"></a>方法覆盖和多态</h2><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><ul>
<li>父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。</li>
</ul>
<p>什么条件满足的时候构成方法覆盖？</p>
<ul>
<li>第一：有继承关系的两个类</li>
<li>第二：具有相同方法名、返回值类型、形式参数列表</li>
<li>第三：访问权限不能更低。</li>
<li>第四：抛出异常不能更多。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    回顾一下方法重载！！！！</span></span><br><span class="line"><span class="comment">        什么时候考虑使用方法重载overload？</span></span><br><span class="line"><span class="comment">            当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样</span></span><br><span class="line"><span class="comment">            代码美观，并且方便编程。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        什么条件满足之后能够构成方法重载overload？</span></span><br><span class="line"><span class="comment">            条件一：在同一个类当中</span></span><br><span class="line"><span class="comment">            条件二：方法名相同</span></span><br><span class="line"><span class="comment">            条件三：参数列表不同（个数、顺序、类型）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    什么时候我们会考虑使用“方法覆盖”呢？</span></span><br><span class="line"><span class="comment">        子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时，</span></span><br><span class="line"><span class="comment">        子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    方法覆盖又叫做：方法重写（重新编写），英语单词叫做：Override、Overwrite，都可以。</span></span><br><span class="line"><span class="comment">    比较常见的：方法覆盖、方法重写、override</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    重要结论：</span></span><br><span class="line"><span class="comment">        当子类对父类继承过来的方法进行“方法覆盖”之后，</span></span><br><span class="line"><span class="comment">        子类对象调用该方法的时候，一定执行覆盖之后的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？</span></span><br><span class="line"><span class="comment">        条件一：两个类必须要有继承关系。</span></span><br><span class="line"><span class="comment">        条件二：重写之后的方法和之前的方法具有：</span></span><br><span class="line"><span class="comment">                    相同的返回值类型、</span></span><br><span class="line"><span class="comment">                    相同的方法名、</span></span><br><span class="line"><span class="comment">                    相同的形式参数列表。</span></span><br><span class="line"><span class="comment">        条件三：访问权限不能更低，可以更高。（这个先记住。）</span></span><br><span class="line"><span class="comment">        条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。（这个先记住）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）</span></span><br><span class="line"><span class="comment">        注意1：方法覆盖只是针对于方法，和属性无关。</span></span><br><span class="line"><span class="comment">        注意2：私有方法无法覆盖。</span></span><br><span class="line"><span class="comment">        注意3：构造方法不能被继承，所以构造方法也不能被覆盖。</span></span><br><span class="line"><span class="comment">        注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        b.move();</span><br><span class="line">        b.sing(<span class="number">1000</span>); <span class="comment">//Animal sing....</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sing....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对move方法进行方法覆盖，方法重写，override</span></span><br><span class="line">    <span class="comment">// 最好将父类中的方法原封不动的复制过来。（不建议手动编写）</span></span><br><span class="line">    <span class="comment">// 方法覆盖，就是将继承过来的那个方法给覆盖掉了。继承过来的方法没了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//protected表示受保护的。没有public开放。</span></span><br><span class="line">    <span class="comment">// 错误：正在尝试分配更低的访问权限; 以前为public</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    protected void move()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;鸟儿在飞翔！！！&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误：被覆盖的方法未抛出Exception</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void move() throws Exception&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;鸟儿在飞翔！！！&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析：这个sing()和父类中的sing(int i)有没有构成方法覆盖呢？</span></span><br><span class="line">    <span class="comment">// 没有，原因是，这两个方法根本就是两个完全不同的方法。</span></span><br><span class="line">    <span class="comment">// 可以说这两个方法构成了方法重载吗？可以。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird sing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="关于Object类中toString-方法的覆盖"><a href="#关于Object类中toString-方法的覆盖" class="headerlink" title="关于Object类中toString()方法的覆盖"></a>关于Object类中toString()方法的覆盖</h4><p>toString()方法存在的作用就是：将java对象转换成字符串形式。大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()方法输出的是一个java对象的内存地址。</p>
<p>至于toString()方法具体怎么进行覆盖？格式可以自己定义，或者听需求的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于Object类中的toString()方法</span></span><br><span class="line"><span class="comment">        1、toString()方法的作用是什么？</span></span><br><span class="line"><span class="comment">            作用：将“java对象”转换成“字符串的形式”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、Object类中toString()方法的默认实现是什么？</span></span><br><span class="line"><span class="comment">            public String toString() &#123;</span></span><br><span class="line"><span class="comment">                return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            toString: 方法名的意思是转换成String</span></span><br><span class="line"><span class="comment">            含义：调用一个java对象的toString()方法就可以将该java对象转换成字符串的表示形式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、那么toString()方法给的默认实现够用吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest04</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个日期对象</span></span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大家是否还记得：当输出一个引用的时候，println方法会自动调用引用的toString方法。</span></span><br><span class="line">        System.out.println(t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1111</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">// 重写toString()方法之前</span></span><br><span class="line">        <span class="comment">//System.out.println(s); //Student@87aac27</span></span><br><span class="line">        <span class="comment">// 重写toString()方法之后</span></span><br><span class="line">        <span class="comment">// 输出一个学生对象的时候，可能更愿意看到学生的信息，不愿意看到对象的内存地址。</span></span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">        System.out.println(s);<span class="comment">//自动调用toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// setters and getters </span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Object类中继承过来的那个toString()方法已经无法满足我业务需求了。</span></span><br><span class="line">    <span class="comment">// 我在子类MyDate中有必要对父类的toString()方法进行覆盖/重写。</span></span><br><span class="line">    <span class="comment">// 我的业务要求是：调用toString()方法进行字符串转换的时候，</span></span><br><span class="line">    <span class="comment">// 希望转换的结果是：xxxx年xx月xx日，这种格式。</span></span><br><span class="line">    <span class="comment">// 重写一定要复制粘贴，不要手动编写，会错的。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> no, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写  方法覆盖</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;学号：&quot;</span> + no + <span class="string">&quot;，姓名：&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法重载和方法覆盖的区别"><a href="#方法重载和方法覆盖的区别" class="headerlink" title="方法重载和方法覆盖的区别"></a>方法重载和方法覆盖的区别</h4><p>方法重载发生在同一个类当中。<br>方法覆盖是发生在具有继承关系的父子类之间。<br>方法重载是一个类中，方法名相同，参数列表不同。<br>方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：方法名一致、参数列表一致、返回值类型一致。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基础语法"><a href="#多态的基础语法" class="headerlink" title="多态的基础语法"></a>多态的基础语法</h4><p>向上转型和向下转型的概念</p>
<p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592956803661.png" title="1592956803661" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592956803661.png" alt="1592956803661"></a></p>
<p>向上转型：子—&gt;父 (upcasting)<br>又被称为自动类型转换：Animal a &#x3D; new Cat();</p>
<p>向下转型：父—&gt;子 (downcasting)<br>又被称为强制类型转换：Cat c &#x3D; (Cat)a; 需要添加强制类型转换符。</p>
<p>什么时候需要向下转型？</p>
<ul>
<li>需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。</li>
</ul>
<p>向下转型有风险吗？</p>
<ul>
<li>容易出现ClassCastException（类型转换异常）</li>
</ul>
<p>怎么避免这个风险？</p>
<ul>
<li>instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象<br>是否为某一种类型。</li>
</ul>
<p>-&gt; 养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。</p>
<p>不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多态的基础语法：</span></span><br><span class="line"><span class="comment">        1、学习多态基础语法之前，我们需要普及两个概念：</span></span><br><span class="line"><span class="comment">            第一个：向上转型</span></span><br><span class="line"><span class="comment">                子 ---&gt; 父（自动类型转换）</span></span><br><span class="line"><span class="comment">            第二个：向下转型</span></span><br><span class="line"><span class="comment">                父 ---&gt; 子（强制类型转换，需要加强制类型转换符）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            注意：</span></span><br><span class="line"><span class="comment">                java中允许向上转型，也允许向下转型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                *****（五颗星）无论是向上转型，还是向下转型，两种类型之间必须有继承关系，没有继承关系编译器报错。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                以后在工作过程中，和别人聊天的时候，要专业一些，说向上转型和向下转型，不要说自动类型转换，也不要说强制类型转换，因为自动类型转换和强制类型转换是使用在基本数据类型方面的，在引用类型转换这里只有向上和向下转型。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        2、多态指的是：</span></span><br><span class="line"><span class="comment">            父类型引用指向子类型对象。</span></span><br><span class="line"><span class="comment">            包括编译阶段和运行阶段。</span></span><br><span class="line"><span class="comment">            编译阶段：绑定父类的方法。</span></span><br><span class="line"><span class="comment">            运行阶段：动态绑定子类型对象的方法。</span></span><br><span class="line"><span class="comment">            多种形态。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        3、什么时候必须使用“向下转型”？</span></span><br><span class="line"><span class="comment">            不要随便做强制类型转换。当你需要访问的是子类对象中“特有”的方法。此时必须进行向下转型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        a1.move(); <span class="comment">//动物在移动！</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c1.move(); <span class="comment">//cat走猫步！</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        b1.move(); <span class="comment">//鸟儿在飞翔！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码可以这样写吗？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1、Animal和Cat之间有继承关系吗？有的。</span></span><br><span class="line"><span class="comment">            2、Animal是父类，Cat是子类。</span></span><br><span class="line"><span class="comment">            3、Cat is a Animal，这句话能不能说通？能。</span></span><br><span class="line"><span class="comment">            4、经过测试得知java中支持这样的一个语法：</span></span><br><span class="line"><span class="comment">                父类型的引用允许指向子类型的对象。</span></span><br><span class="line"><span class="comment">                Animal a2 = new Cat();</span></span><br><span class="line"><span class="comment">                a2就是父类型的引用。new Cat()是一个子类型的对象。允许a2这个父类型引用指向子类型的对象。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有继承关系的两个类型之间存在转型吗？</span></span><br><span class="line">        <span class="comment">// 错误: 不兼容的类型: Dog无法转换为Animal</span></span><br><span class="line">        <span class="comment">// Animal a4 = new Dog();（Dog没有继承Animal）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用a2的move()方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            什么是多态？</span></span><br><span class="line"><span class="comment">                多种形态，多种状态。</span></span><br><span class="line"><span class="comment">            分析：a2.move();</span></span><br><span class="line"><span class="comment">                java程序分为编译阶段和运行阶段。</span></span><br><span class="line"><span class="comment">                先来分析编译阶段：</span></span><br><span class="line"><span class="comment">                    对于编译器来说，编译器只知道a2的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()方法，找到了，绑定上move()方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）</span></span><br><span class="line"><span class="comment">                再来分析运行阶段：</span></span><br><span class="line"><span class="comment">                    运行阶段的时候，实际上在堆内存中创建的java对象是Cat对象，所以move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行Cat对象的move()方法。这个过程属于运行阶段绑定。（运行阶段绑定属于动态绑定。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            多态表示多种形态：</span></span><br><span class="line"><span class="comment">                编译的时候一种形态。</span></span><br><span class="line"><span class="comment">                运行的时候另一种形态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        a2.move(); <span class="comment">//cat走猫步！</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用a3的move()方法</span></span><br><span class="line">        a3.move(); <span class="comment">//鸟儿在飞翔！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ======================================================================</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// 底层对象是一只猫。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析这个程序能否编译和运行呢？</span></span><br><span class="line">        <span class="comment">// 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。</span></span><br><span class="line">        <span class="comment">// 只有编译通过的代码才能运行。没有编译，根本轮不到运行。</span></span><br><span class="line">        <span class="comment">// 错误: 找不到符号</span></span><br><span class="line">        <span class="comment">// why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法</span></span><br><span class="line">        <span class="comment">// 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）</span></span><br><span class="line">        <span class="comment">//a5.catchMouse(); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 假设代码写到了这里，我非要调用catchMouse()方法怎么办？</span></span><br><span class="line">        <span class="comment">// 这个时候就必须使用“向下转型”了。（强制类型转换）</span></span><br><span class="line">        <span class="comment">// 以下这行代码为啥没报错？？？？</span></span><br><span class="line">        <span class="comment">// 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">x</span> <span class="operator">=</span> (Cat)a5;</span><br><span class="line">        x.catchMouse(); <span class="comment">//猫正在抓老鼠！！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型有风险吗？</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">//表面上a6是一个Animal，运行的时候实际上是一只鸟儿。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            分析以下程序，编译报错还是运行报错？？？</span></span><br><span class="line"><span class="comment">                编译器检测到a6这个引用是Animal类型，</span></span><br><span class="line"><span class="comment">                而Animal和Cat之间存在继承关系，所以可以向下转型。</span></span><br><span class="line"><span class="comment">                编译没毛病。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                运行阶段，堆内存实际创建的对象是：Bird对象。</span></span><br><span class="line"><span class="comment">                在实际运行过程中，拿着Bird对象转换成Cat对象就不行了。因为Bird和Cat之间没有继承关系。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：</span></span><br><span class="line"><span class="comment">                java.lang.ClassCastException：类型转换异常。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            java.lang.NullPointerException：空指针异常。这个也非常重要。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//Cat y = (Cat)a6;</span></span><br><span class="line">        <span class="comment">//y.catchMouse();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 怎么避免ClassCastException异常的发生？？？</span></span><br><span class="line">        <span class="comment">/*	</span></span><br><span class="line"><span class="comment">            新的内容，运算符：</span></span><br><span class="line"><span class="comment">                instanceof （运行阶段动态判断）</span></span><br><span class="line"><span class="comment">            第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。</span></span><br><span class="line"><span class="comment">            第二：instanceof的语法：(引用 instanceof 类型)</span></span><br><span class="line"><span class="comment">            第三：instanceof运算符的运算结果只能是：true/false</span></span><br><span class="line"><span class="comment">            第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。</span></span><br><span class="line"><span class="comment">                假设(c instanceof Cat)为true表示:c引用指向的堆内存中的java对象是一个Cat。</span></span><br><span class="line"><span class="comment">                假设(c instanceof Cat)为false表示:c引用指向的堆内存中的java对象不是一个Cat。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            程序员要养成一个好习惯：</span></span><br><span class="line"><span class="comment">                任何时候，任何地点，对类型进行向下转型时，一定要使用instanceof 运算符进行判断。（java规范中要求的。）</span></span><br><span class="line"><span class="comment">                这样可以很好的避免：ClassCastException</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(a6 <span class="keyword">instanceof</span> Cat); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a6 <span class="keyword">instanceof</span> Cat)&#123; <span class="comment">// 如果a6是一只Cat</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">y</span> <span class="operator">=</span> (Cat)a6;  <span class="comment">// 再进行强制类型转换</span></span><br><span class="line">            y.catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多种形态，多种状态，编译和运行有两个不同的状态。<br>编译期叫做静态绑定。<br>运行期叫做动态绑定。<br>Animal a &#x3D; new Cat();<br>&#x2F;&#x2F; 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法<br>&#x2F;&#x2F; 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关<br>&#x2F;&#x2F; 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。<br>a.move();</p>
<p>多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）</p>
<p>什么时候必须进行向下转型？调用子类对象上特有的方法时。</p>
<h4 id="为什么要用instanceof"><a href="#为什么要用instanceof" class="headerlink" title="为什么要用instanceof"></a>为什么要用instanceof</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test方法是程序员B负责编写。</span></span><br><span class="line">    <span class="comment">// 这个test()方法的参数是一个Animal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Animal a)</span>&#123; <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="comment">// 你写的这个方法别人会去调用。</span></span><br><span class="line">        <span class="comment">// 别人调用的时候可能给你test()方法传过来一个Bird</span></span><br><span class="line">        <span class="comment">// 当然也可能传过来一个Cat</span></span><br><span class="line">        <span class="comment">// 对于我来说，我不知道你调用的时候给我传过来一个啥。</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;</span><br><span class="line">            c.catchMouse();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">            <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> (Bird)a;</span><br><span class="line">            b.sing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态在开发中的作用"><a href="#多态在开发中的作用" class="headerlink" title="多态在开发中的作用"></a>多态在开发中的作用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意这里的分析：</span></span><br><span class="line"><span class="comment">        主人起初的时候只喜欢养宠物狗狗</span></span><br><span class="line"><span class="comment">        随着时间的推移，主人又喜欢上养“猫咪”</span></span><br><span class="line"><span class="comment">        在实际的开发中这就表示客户产生了新的需求。</span></span><br><span class="line"><span class="comment">        作为软件的开发人员来说，必须满足客户的需求。</span></span><br><span class="line"><span class="comment">        我们怎么去满足客户的需求呢？</span></span><br><span class="line"><span class="comment">            在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？</span></span><br><span class="line"><span class="comment">        一定要记住：软件在扩展过程当中，修改的越少越好。</span></span><br><span class="line"><span class="comment">        修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        其实这里涉及到一个软件的开发原则：</span></span><br><span class="line"><span class="comment">            软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：</span></span><br><span class="line"><span class="comment">                其中有一条最基本的原则：OCP（开闭原则）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        什么是开闭原则？</span></span><br><span class="line"><span class="comment">            对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。</span></span><br><span class="line"><span class="comment">            在软件的扩展过程当中，修改的越少越好。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    什么是软件扩展性？</span></span><br><span class="line"><span class="comment">        假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。</span></span><br><span class="line"><span class="comment">        这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。</span></span><br><span class="line"><span class="comment">    因为面向具体编程会让软件的扩展力很差。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>非常重要：五颗星。</p>
<p>多态在开发中的作用是：降低程序的耦合度，提高程序的扩展力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog d)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat c)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上的代码中表示：Master和Dog以及Cat的关系很紧密（耦合度高）。导致扩展力很差。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">pet.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上的代表中表示：Master和Dog以及Cat的关系就脱离了，Master关注的是Pet类。</span></span><br><span class="line"><span class="comment">//这样Master和Dog以及Cat的耦合度就降低了，提高了软件的扩展性。</span></span><br></pre></td></tr></table></figure>

<p>有了封装，有了这种整体的概念之后。<br>对象和对象之间产生了继承。<br>有了继承之后，才有了方法的覆盖和多态。</p>
<p>这里提到了一个软件开发原则：<br>七大原则最基本的原则：OCP（对扩展开放，对修改关闭）<br>目的是：降低程序耦合度，提高程序扩展力。<br>面向抽象编程，不建议面向具体编程。</p>
<h4 id="解释之前遗留的问题"><a href="#解释之前遗留的问题" class="headerlink" title="解释之前遗留的问题"></a>解释之前遗留的问题</h4><p>私有方法无法覆盖。</p>
<p>方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）</p>
<p>总结两句话：私有不能覆盖。静态不谈覆盖。</p>
<p>在方法覆盖中，关于方法的返回值类型。<br>什么条件满足之后，会构成方法的覆盖呢？</p>
<ol>
<li>发生具有继承关系的两个类之间。</li>
<li>父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、方法覆盖需要和多态机制联合起来使用才有意义。</span></span><br><span class="line"><span class="comment">        Animal a = new Cat();</span></span><br><span class="line"><span class="comment">        a.move();</span></span><br><span class="line"><span class="comment">        要的是什么效果？</span></span><br><span class="line"><span class="comment">            编译的时候move()方法是Animal的。</span></span><br><span class="line"><span class="comment">            运行的时候自动调用到子类重写move()方法上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        假设没有多态机制，只有方法覆盖机制，你觉得有意义吗？</span></span><br><span class="line"><span class="comment">            没有多态机制的话，方法覆盖可有可无。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            没有多态机制，方法覆盖也可以没有，如果父类的方法无法满足</span></span><br><span class="line"><span class="comment">            子类业务需求的时候，子类完全可以定义一个全新的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        方法覆盖和多态不能分开。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2、静态方法存在方法覆盖吗？</span></span><br><span class="line"><span class="comment">        多态自然就和对象有关系了。</span></span><br><span class="line"><span class="comment">        而静态方法的执行不需要对象。</span></span><br><span class="line"><span class="comment">        所以，一般情况下，我们会说静态方法“不存在”方法覆盖。</span></span><br><span class="line"><span class="comment">        不探讨静态方法的覆盖。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 静态方法可以使用“引用.”来调用吗？可以</span></span><br><span class="line">        <span class="comment">// 虽然使用“引用.”来调用，但是和对象无关。</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//多态</span></span><br><span class="line">        <span class="comment">// 静态方法和对象无关。</span></span><br><span class="line">        <span class="comment">// 虽然使用“引用.”来调用。但是实际运行的时候还是：Animal.doSome()</span></span><br><span class="line">        a.doSome();</span><br><span class="line">        </span><br><span class="line">        Animal.doSome();</span><br><span class="line">        Cat.doSome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“相同的返回值类型”可以修改一下吗？</p>
<ul>
<li>对于返回值类型是基本数据类型来说，必须一致。</li>
<li>对于返回值类型是引用数据类型来说，重写之后返回值类型可以变的更小（但意义不大，实际开发中没人这样写。）。</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="与this相比"><a href="#与this相比" class="headerlink" title="与this相比"></a>与this相比</h3><ul>
<li>super能出现在实例方法和构造方法中。</li>
<li>super的语法是：“super.”、“super()”</li>
<li>super不能使用在静态方法中。</li>
<li>super. 大部分情况下是可以省略的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、super是一个关键字，全部小写。</span></span><br><span class="line"><span class="comment">    2、super和this对比着学习。</span></span><br><span class="line"><span class="comment">        this:</span></span><br><span class="line"><span class="comment">            this能出现在实例方法和构造方法中。</span></span><br><span class="line"><span class="comment">            this的语法是：“this.”、“this()”</span></span><br><span class="line"><span class="comment">            this不能使用在静态方法中。</span></span><br><span class="line"><span class="comment">            this. 大部分情况下是可以省略的。</span></span><br><span class="line"><span class="comment">            this.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。</span></span><br><span class="line"><span class="comment">                public void setName(String name)&#123;</span></span><br><span class="line"><span class="comment">                    this.name = name;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中</span></span><br><span class="line"><span class="comment">            其它的构造方法，目的是：代码复用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        super:</span></span><br><span class="line"><span class="comment">            super能出现在实例方法和构造方法中。</span></span><br><span class="line"><span class="comment">            super的语法是：“super.”、“super()”</span></span><br><span class="line"><span class="comment">            super不能使用在静态方法中。</span></span><br><span class="line"><span class="comment">            super. 大部分情况下是可以省略的。</span></span><br><span class="line"><span class="comment">            super.什么时候不能省略呢？ </span></span><br><span class="line"><span class="comment">            super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中</span></span><br><span class="line"><span class="comment">            的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3、super()</span></span><br><span class="line"><span class="comment">        表示通过子类的构造方法调用父类的构造方法。</span></span><br><span class="line"><span class="comment">        模拟现实世界中的这种场景：要想有儿子，需要先有父亲。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    4、重要的结论：</span></span><br><span class="line"><span class="comment">        当一个构造方法第一行：</span></span><br><span class="line"><span class="comment">            既没有this()又没有super()的话，默认会有一个super();</span></span><br><span class="line"><span class="comment">            表示通过当前子类的构造方法调用父类的无参数构造方法。</span></span><br><span class="line"><span class="comment">            所以必须保证父类的无参数构造方法是存在的。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    5、注意：</span></span><br><span class="line"><span class="comment">        this()和super() 不能共存，它们都是只能出现在构造方法第一行。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    6、无论是怎样折腾，父类的构造方法是一定会执行的。（百分百的。）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            A类的无参数构造方法！</span></span><br><span class="line"><span class="comment">            B类的无参数构造方法！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建议手动的将一个类的无参数构造方法写出来。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//super(); // 这里也是默认有这一行代码的。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A类的无参数构造方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。</span></span><br><span class="line">    <span class="comment">// 一个类如果手动提供了一个构造方法，那么无参数构造系统将不再提供。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A类的有参数构造方法(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public B()&#123;</span></span><br><span class="line"><span class="comment">        super();</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;B类的无参数构造方法！&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用父类中有参数的构造方法</span></span><br><span class="line">        <span class="comment">//super(123);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B类的无参数构造方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;B类的有参数构造方法(String)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、举个例子：在恰当的时间使用：super(实际参数列表);</span></span><br><span class="line"><span class="comment">    2、注意：在构造方法执行过程中一连串调用了父类的构造方法，</span></span><br><span class="line"><span class="comment">    父类的构造方法又继续向下调用它的父类的构造方法，但是实际上</span></span><br><span class="line"><span class="comment">    对象只创建了一个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3、思考：“super(实参)”到底是干啥的？</span></span><br><span class="line"><span class="comment">        super(实参)的作用是：初始化当前对象的父类型特征。</span></span><br><span class="line"><span class="comment">        并不是创建新对象。实际上对象只创建了1个。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    4、super关键字代表什么？</span></span><br><span class="line"><span class="comment">        super关键字代表的就是“当前对象”的那部分父类型特征。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    5、 super和this都不能出现在静态方法中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>super的使用：<br>super.属性名   【访问父类的属性】<br>super.方法名(实参)   【访问父类的方法】<br>super(实参)   【调用父类的构造方法】</p>
<h3 id="什么时候可以省略"><a href="#什么时候可以省略" class="headerlink" title="什么时候可以省略"></a>什么时候可以省略</h3><p>super.什么时候不能省略呢？</p>
<ul>
<li>父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。</li>
</ul>
<p>super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中<br>的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、“this.”和“super.”大部分情况下都是可以省略的。</span></span><br><span class="line"><span class="comment">    2、this. 什么时候不能省略？</span></span><br><span class="line"><span class="comment">        public void setName(String name)&#123;</span></span><br><span class="line"><span class="comment">            this.name = name;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    3、super. 什么时候不能省略？</span></span><br><span class="line"><span class="comment">        父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            java是怎么来区分子类和父类的同名属性的？</span></span><br><span class="line"><span class="comment">                this.name：当前对象的name属性</span></span><br><span class="line"><span class="comment">                super.name：当前对象的父类型特征中的name属性。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在购物!&quot;</span>); <span class="comment">// null 正在购物</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot;正在购物!&quot;</span>); <span class="comment">// 张三正在购物</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在购物!&quot;</span>); <span class="comment">//null 正在购物</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在父和子中有同名的属性，或者说有相同的方法，</span></span><br><span class="line"><span class="comment">    如果此时想在子类中访问父中的数据，必须使用“super.”加以区分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    super.属性名    【访问父类的属性】</span></span><br><span class="line"><span class="comment">    super.方法名(实参) 【访问父类的方法】</span></span><br><span class="line"><span class="comment">    super(实参)  【调用父类的构造方法】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过这个测试得出的结论：</span></span><br><span class="line"><span class="comment">        super 不是引用。super也不保存内存地址，super也不指向任何对象。</span></span><br><span class="line"><span class="comment">        super 只是代表当前对象内部的那一块父类型的特征。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperTest06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// SuperTest06@2f92e0f4</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 输出“引用”的时候，会自动调用引用的toString()方法。</span></span><br><span class="line">        <span class="comment">//System.out.println(this.toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译错误: 需要&#x27;.&#x27;</span></span><br><span class="line">        <span class="comment">//System.out.println(super);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this和super不能使用在static静态方法中。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static void doOther()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(this);</span></span><br><span class="line"><span class="comment">        System.out.println(super.xxx);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SuperTest06</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperTest06</span>();</span><br><span class="line">        st.doSome();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main方法是静态的</span></span><br><span class="line">        <span class="comment">// 错误的。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println(this);</span></span><br><span class="line"><span class="comment">        System.out.println(super.xxxx);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    final</span></span><br><span class="line"><span class="comment">    1、final是java语言中的一个关键字。</span></span><br><span class="line"><span class="comment">    2、final表示最终的，不可变的。</span></span><br><span class="line"><span class="comment">    3、final可以修饰变量以及方法，还有类等。</span></span><br><span class="line"><span class="comment">    4、final修饰的变量？</span></span><br><span class="line"><span class="comment">    5、final修饰的方法？</span></span><br><span class="line"><span class="comment">    6、final修饰的类？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类继承A类，相当于对A类的功能进行扩展。如果你不希望别人对A类型进行扩展。</span></span><br><span class="line"><span class="comment">//你可以给A类加final关键字，这样的话A类就无法继承了。</span></span><br><span class="line"><span class="comment">//错误 ：final修饰的类无法被继承</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="comment">//public void f()&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 错误：final修饰的方法无法被覆盖和重写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//i = 20;</span></span><br><span class="line">        <span class="comment">//错误：final修饰的局部变量不能重新赋值（只能赋一次值）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final修饰的引用变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用是一个变量, 如果用final修饰了，那么他里面的地址就不能变了，但是地址里的东西还是可以变化的，就相当于C++中的 const int*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    final修饰的引用：</span></span><br><span class="line"><span class="comment">    该引用只能指向1个对象，并且它只能永远指向该对象，无法再指向其它对象。并且在该方法执行过程中，该引用指向对象之后，该对象不会被垃圾回收器回收。直到当前方法结束，才会释放空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final修饰的实例变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    也是变量，系统会赋上默认值的变量，加上之后，系统就不会自动赋值了，我们必须手动赋值。</span></span><br><span class="line"><span class="comment">    可以在声明的时候赋值（本质也是在构造方法里赋值）</span></span><br><span class="line"><span class="comment">    也能在构造方法里赋值（在构造方法里也不能重新赋值，只能赋值一次）</span></span><br><span class="line"><span class="comment">    只要在系统赋默认值之前赋值就行（构造方法里赋默认值）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量：static final 修饰的变量称为常量。建议全部大写，每个单词之间用下划线链接</span></span><br><span class="line"><span class="comment">//永远不变的量建议声明为常量，</span></span><br><span class="line"><span class="comment">//常量和静态变量都是存储在方法区，并且都是在类加载的时候初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量一般都是public的，所以大多写为 public static final int PI = 3.14;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>final修饰的类无法继承。</li>
<li>final修饰的方法无法覆盖。</li>
<li>final修饰的变量只能赋一次值。</li>
<li>final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用</li>
<li>指向的对象内部的数据是可以修改的。</li>
<li>final修饰的实例变量必须手动初始化，不能采用系统默认值。</li>
<li>final修饰的实例变量一般和static联合使用，称为常量。</li>
<li>public static final double PI &#x3D; 3.1415926;</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593007439866.png" title="1593007439866" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593007439866.png" alt="1593007439866"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    类到对象是实例化。对象到类是抽象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    抽象类：</span></span><br><span class="line"><span class="comment">        1、什么是抽象类？</span></span><br><span class="line"><span class="comment">            类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类。</span></span><br><span class="line"><span class="comment">            类本身是不存在的，所以抽象类无法创建对象《无法实例化》。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、抽象类属于什么类型？</span></span><br><span class="line"><span class="comment">            抽象类也属于引用数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、抽象类怎么定义？《能把基础语法先学会》</span></span><br><span class="line"><span class="comment">            语法：</span></span><br><span class="line"><span class="comment">                [修饰符列表] abstract class 类名&#123;</span></span><br><span class="line"><span class="comment">                    类体;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        5、final和abstract不能联合使用，这两个关键字是对立的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        6、抽象类的子类可以是抽象类。也可以是非抽象类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        7、抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。super</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        8、抽象类关联到一个概念：抽象方法。什么是抽象方法呢？</span></span><br><span class="line"><span class="comment">            抽象方法表示没有实现的方法，没有方法体的方法。例如：</span></span><br><span class="line"><span class="comment">                public abstract void doSome();</span></span><br><span class="line"><span class="comment">                抽象方法特点是：</span></span><br><span class="line"><span class="comment">                    特点1：没有方法体，以分号结尾。</span></span><br><span class="line"><span class="comment">                    特点2：前面修饰符列表中有abstract关键字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        9、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractTest01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 错误: Account是抽象的; 无法实例化</span></span><br><span class="line">        <span class="comment">//Account act = new Account();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行账户类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final abstract class Account&#123;&#125;</span></span><br><span class="line"><span class="comment">错误: 非法的修饰符组合: abstract和final</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public Account()&#123;&#125;</span></span><br><span class="line"><span class="comment">    public Account(String s)&#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承抽象类，子类可以实例化对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class CreditAccount extends Account&#123;</span></span><br><span class="line"><span class="comment">    public CreditAccount()&#123;</span></span><br><span class="line"><span class="comment">        super();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类可以是抽象类吗？可以</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abstract class CreditAccount extends Account&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、重要结论：重要结论五颗星*****（必须记住）</span></span><br><span class="line"><span class="comment">            一个非抽象的类继承抽象类，必须将抽象类中的所有抽象方法实现了。</span></span><br><span class="line"><span class="comment">            这是java语法上强行规定的，必须的，不然编译器就报错了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            这里的覆盖或者说重写，也可以叫做实现。（对抽象的实现。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractTest02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 能不能使用多态?</span></span><br><span class="line">        <span class="comment">// 父类型引用指向子类型对象。</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();  <span class="comment">// 向上转型。（自动类型转换）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这就是面向抽象编程。</span></span><br><span class="line">        <span class="comment">// 以后你都是调用的a.XXXX</span></span><br><span class="line">        <span class="comment">// a的类型是Animal，Animal是抽象的</span></span><br><span class="line">        <span class="comment">// 面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力。</span></span><br><span class="line">        <span class="comment">// 这种编程思想符合OCP原则。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            分析以下：</span></span><br><span class="line"><span class="comment">                编译的时候这个move()方法是谁的？</span></span><br><span class="line"><span class="comment">                运行的时候这个move()方法又是谁的？</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        a.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态（当对多态不是很理解的时候，以后写代码能用多态就用多态。慢慢就理解了。）</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        x.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类（抽象类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（非抽象的）</span></span><br><span class="line"><span class="comment">// 错误: Bird不是抽象的, 并且未覆盖Animal中的抽象方法move()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Bird extends Animal&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">// 需要将从父类中继承过来的抽象方法进行覆盖/重写，或者也可以叫做“实现”。</span></span><br><span class="line">    <span class="comment">// 把抽象的方法实现了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在走猫步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Bird是抽象类的话，那么这个Animal中继承过来的抽象方法也可以不去重写/覆盖/实现。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abstract class Bird extends Animal&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类怎么定义？在class前添加abstract关键字就行了。</li>
<li>抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。</li>
<li>final和abstract不能联合使用，这两个关键字是对立的。</li>
<li>抽象类的子类可以是抽象类。也可以是非抽象类。</li>
<li>抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。</li>
<li>抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</li>
<li>抽象方法怎么定义？public abstract void doSome();</li>
<li>一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现。</li>
</ul>
<p>面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。错误的。<br>Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们都不是抽象方法，例如：public native int hashCode();这个方法底层调用了C++写的动态链接库程序。前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口：</span></span><br><span class="line"><span class="comment">        1、接口也是一种“引用数据类型”。编译之后也是一个class字节码文件。</span></span><br><span class="line"><span class="comment">        2、接口是完全抽象的。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。</span></span><br><span class="line"><span class="comment">        3、接口怎么定义，语法是什么？</span></span><br><span class="line"><span class="comment">            [修饰符列表] interface 接口名&#123;&#125;</span></span><br><span class="line"><span class="comment">        4、接口支持多继承，一个接口可以继承多个接口。</span></span><br><span class="line"><span class="comment">        5、接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法。接口中没有其它内容了。只有以上两部分。</span></span><br><span class="line"><span class="comment">        6、接口中所有的元素都是public修饰的。（都是公开的。）</span></span><br><span class="line"><span class="comment">        7、接口中的抽象方法定义时：public abstract修饰符可以省略。</span></span><br><span class="line"><span class="comment">        8、接口中的方法都是抽象方法，所以接口中的方法不能有方法体。</span></span><br><span class="line"><span class="comment">        9、接口中的常量的public static final可以省略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问接口的常量。</span></span><br><span class="line">        System.out.println(MyMath.PI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常量能重新赋值吗？</span></span><br><span class="line">        <span class="comment">//错误: 无法为最终变量PI分配值</span></span><br><span class="line">        <span class="comment">//MyMath.PI = 3.1415928;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口支持继承</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接口可以继承多个接口（支持多继承）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>, B&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的数学接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyMath</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="comment">//public static final double PI = 3.1415926;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public static final可以省略吗？</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">//public abstract int sum(int a, int b);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口当中既然都是抽象方法，那么在编写代码的时候，public abstract可以省略吗？可以</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中的方法可以有方法体吗？</span></span><br><span class="line">    <span class="comment">// 错误: 接口抽象方法不能带有主体</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void doSome()&#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相减的抽象方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>接口是一种“引用数据类型”。</li>
<li>接口是完全抽象的。</li>
<li>接口怎么定义：[修饰符列表] interface 接口名{}</li>
<li>接口支持多继承。</li>
<li>接口中只有常量+抽象方法。</li>
<li>接口中所有的元素都是public修饰的</li>
<li>接口中抽象方法的public abstract可以省略。</li>
<li>接口中常量的public static final可以省略。</li>
<li>接口中方法不能有方法体。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口的基础语法：</span></span><br><span class="line"><span class="comment">        1、类和类之间叫做继承，类和接口之间叫做实现。</span></span><br><span class="line"><span class="comment">        别多想：你仍然可以将&quot;实现&quot;看做“继承”。</span></span><br><span class="line"><span class="comment">        继承使用extends关键字完成。</span></span><br><span class="line"><span class="comment">        实现使用implements关键字完成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、五颗星（*****）：当一个非抽象的类实现接口的话，必须将接口中所有的</span></span><br><span class="line"><span class="comment">        抽象方法全部实现（覆盖、重写）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//错误: MyMath是抽象的; 无法实例化</span></span><br><span class="line">        <span class="comment">//new MyMath();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能使用多态吗？可以。</span></span><br><span class="line">        <span class="comment">//Animal a = new Cat();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类型的引用指向子类型的对象</span></span><br><span class="line">        <span class="type">MyMath</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMathImpl</span>();</span><br><span class="line">        <span class="comment">// 调用接口里面的方法（面向接口编程。）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> mm.sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的抽象类，完全抽象的，叫做接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyMath</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样没问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abstract class MyMathImpl implements MyMath &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个类（这个类是一个“非抽象”的类）</span></span><br><span class="line"><span class="comment">// 这个类的名字是随意的。</span></span><br><span class="line"><span class="comment">//错误: MyMathImpl不是抽象的, 并且未覆盖MyMath中的抽象方法sub(int,int)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class MyMathImpl implements MyMath &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修正</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMathImpl</span> <span class="keyword">implements</span> <span class="title class_">MyMath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误：正在尝试分配更低的访问权限; 以前为public</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int sum(int a, int b)&#123;</span></span><br><span class="line"><span class="comment">        return a + b;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写/覆盖/实现 接口中的方法（通常叫做实现。）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;	<span class="keyword">return</span> a + b;	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;	<span class="keyword">return</span> a - b;	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？对于计算机来说，一个机箱上有多个接口，一个接口是接键盘的，一个接口是接鼠标的，一个接口是接电源的，一个接口是接显示器的.....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    重点（五颗星*****）：一个类可以同时实现多个接口。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这种机制弥补了java中的哪个缺陷？</span></span><br><span class="line"><span class="comment">        java中类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中存在多继承，java中的接口弥补了单继承带来的缺陷。接口A和接口B虽然没有继承关系，但是写代码的时候，可以互转。编译器没意见。但是运行时可能出现：ClassCastException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    之前有一个结论：</span></span><br><span class="line"><span class="comment">        无论向上转型还是向下转型，两种类型之间必须要有继承关系，没有继承关系编译器会报错。（这句话不适用在接口方面。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        最终实际上和之前还是一样，需要加：instanceof运算符进行判断。向下转型养成好习惯。转型之前先if+instanceof进行判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 多态该怎么用呢？</span></span><br><span class="line">        <span class="comment">// 都是父类型引用指向子类型对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        <span class="comment">//a.m2(); // 编译报错。A接口中没有m2()方法。</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个编译没问题，运行也没问题。</span></span><br><span class="line">        <span class="comment">// 调用其他接口中的方法，你需要转型（接口转型。）</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)a;</span><br><span class="line">        b2.m2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接向下转型为D可以吗？可以</span></span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> (D)a;</span><br><span class="line">        d.m2();</span><br><span class="line"></span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">        <span class="comment">// 经过测试：接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转。</span></span><br><span class="line">        <span class="comment">// 但是一定要注意，运行时可能会出现ClassCastException异常。</span></span><br><span class="line">        <span class="comment">// 编译没问题，运行有问题。</span></span><br><span class="line">        <span class="comment">//K k = (K)m;</span></span><br><span class="line">        <span class="keyword">if</span>(m <span class="keyword">instanceof</span> K)&#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> (K)m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">K</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">M</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">M</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">X</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Y</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">X</span>,Y&#123; <span class="comment">//接口和接口支持多继承。&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;<span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;<span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现多个接口，其实就类似于多继承。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B,C&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承和实现都存在的话，代码应该怎么写？</span></span><br><span class="line"><span class="comment">        extends 关键字在前。</span></span><br><span class="line"><span class="comment">        implements 关键字在后。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象（表面看Animal类没起作用！）</span></span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//多态。</span></span><br><span class="line">        f.fly();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个接口</span></span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">        <span class="comment">// 调用同一个fly()方法，最后的执行效果不同。</span></span><br><span class="line">        f2.fly();</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">        f3.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类：父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口通常提取的是行为动作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyablevoid</span> fly();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类子类：猫类</span></span><br><span class="line"><span class="comment">// Flyable是一个接口，是一对翅膀的接口，通过接口插到猫身上，让猫变的可以飞翔。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞猫起飞，翱翔太空的一只猫，很神奇，我想做一只猫！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蛇类，如果你不想让它飞，可以不实现Flyable接口</span></span><br><span class="line"><span class="comment">// 没有实现这个接口表示你没有翅膀，没有给你插翅膀，你肯定不能飞。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想飞就插翅膀这个接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只会飞的猪！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鱼（默认实际上是存在继承的，默认继承Object。）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Fish extends Object implements Flyable&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123; <span class="comment">//没写extends，也是有的，默认继承Object。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是六眼飞鱼（流言蜚语）！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。</li>
<li>一个类可以实现多个接口。</li>
<li>extends和implements可以共存，extends在前，implements在后。</li>
<li>使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。</li>
</ul>
<h4 id="在开发中的作用-解耦合"><a href="#在开发中的作用-解耦合" class="headerlink" title="在开发中的作用(解耦合)"></a>在开发中的作用(解耦合)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顾客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="comment">// 顾客手里有一个菜单</span></span><br><span class="line">    <span class="comment">// Customer has a FoodMenu!（这句话什么意思：顾客有一个菜单）</span></span><br><span class="line">    <span class="comment">// 记住：以后凡是能够使用 has a 来描述的，统一以属性的方式存在。</span></span><br><span class="line">    <span class="comment">// 实例变量，属性</span></span><br><span class="line">    <span class="comment">// 面向抽象编程，面向接口编程。降低程序的耦合度，提高程序的扩展力。</span></span><br><span class="line">    <span class="keyword">private</span> FoodMenu foodMenu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果以下这样写，就表示写死了（焊接了。没有可插拔了。）</span></span><br><span class="line">    <span class="comment">// 中餐厨师</span></span><br><span class="line">    <span class="comment">//ChinaCooker cc;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 西餐厨师</span></span><br><span class="line">    <span class="comment">//AmericCooker ac</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(FoodMenu foodMenu)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.foodMenu = foodMenu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter and getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodMenu</span><span class="params">(FoodMenu foodMenu)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.foodMenu = foodMenu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> FoodMenu <span class="title function_">getFoodMenu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foodMenu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个点菜的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 先拿到菜单才能点菜</span></span><br><span class="line">        <span class="comment">// 调用get方法拿菜单。</span></span><br><span class="line">        <span class="comment">//FoodMenu fm = this.getFoodMenu();</span></span><br><span class="line">        <span class="comment">// 也可以不调用get方法，因为在本类中私有的属性是可以访问</span></span><br><span class="line">        foodMenu.shiZiChaoJiDan();</span><br><span class="line">        foodMenu.yuXiangRouSi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Cat is a Animal，但凡满足is a的表示都可以设置为继承。</span></span><br><span class="line"><span class="comment">    Customer has a FoodMenu，但凡是满足has a的表示都以属性的形式存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//西餐厨师</span></span><br><span class="line"><span class="comment">// 实现菜单上的菜</span></span><br><span class="line"><span class="comment">// 厨师是接口的实现者。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericCooker</span> <span class="keyword">implements</span> <span class="title class_">FoodMenu</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 西红柿炒蛋</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shiZiChaoJiDan</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;西餐师傅做的西红柿炒鸡蛋！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鱼香肉丝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">yuXiangRouSi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;西餐师傅做的鱼香肉丝！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中餐厨师</span></span><br><span class="line"><span class="comment">// 实现菜单上的菜</span></span><br><span class="line"><span class="comment">// 厨师是接口的实现者。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChinaCooker</span> <span class="keyword">implements</span> <span class="title class_">FoodMenu</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 西红柿炒蛋</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shiZiChaoJiDan</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中餐师傅做的西红柿炒鸡蛋，东北口味！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鱼香肉丝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">yuXiangRouSi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中餐师傅做的鱼香肉丝，东北口味！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口：菜单，抽象的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodMenu</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 西红柿炒蛋</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shiZiChaoJiDan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鱼香肉丝</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">yuXiangRouSi</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建厨师对象</span></span><br><span class="line">        <span class="comment">//FoodMenu cooker1 = new ChinaCooker();</span></span><br><span class="line">        <span class="type">FoodMenu</span> <span class="variable">cooker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmericCooker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建顾客对象</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(cooker1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顾客点菜</span></span><br><span class="line">        customer.order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：接口在开发中的作用，类似于多态在开发中的作用。</p>
<p>多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。</p>
<p>接口在开发中的作用？<br>接口是不是完全的？是。<br>而我们以后正好要求，面向抽象编程。面向抽象编程这句话以后可以修改为：面向接口编程。有了接口就有了可插拔。可插拔表示扩展力很强。不是焊接死的。<br>主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来。这叫做高扩展性。（低耦合度。）</p>
<p>接口有什么用？扩展性好。可插拔。<br>接口是一个抽象的概念。</p>
<p>总结一句话：三个字“解耦合”<br>面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）</p>
<p>接口可以解耦合，解开的是谁和谁的耦合 ? 任何一个接口都有调用者和实现者。接口可以将调用者和实现者解耦合。调用者面向接口调用。实现者面向接口编写实现。</p>
<p>以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，<br>模块和模块之间采用接口衔接。降低耦合度。</p>
<h4 id="类型之间的关系"><a href="#类型之间的关系" class="headerlink" title="类型之间的关系"></a>类型之间的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">is a（继承）、has a（关联）、like a（实现）</span></span><br><span class="line"><span class="comment">is a：</span></span><br><span class="line"><span class="comment">    Cat is a Animal（猫是一个动物）</span></span><br><span class="line"><span class="comment">    凡是能够满足is a的表示“继承关系”</span></span><br><span class="line"><span class="comment">A extends B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">has a：</span></span><br><span class="line"><span class="comment">    I has a Pen（我有一支笔）</span></span><br><span class="line"><span class="comment">    凡是能够满足has a关系的表示“关联关系”</span></span><br><span class="line"><span class="comment">    关联关系通常以“属性”的形式存在。</span></span><br><span class="line"><span class="comment">A&#123;</span></span><br><span class="line"><span class="comment">B b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">like a：</span></span><br><span class="line"><span class="comment">    Cooker 1ike a Foodienu（厨师像一个菜单一样）凡是能够满足likea关系的表示实现关系”</span></span><br><span class="line"><span class="comment">    实现关系通常是：类实现接口。</span></span><br><span class="line"><span class="comment">A implements B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><p>在这里我们只说一下抽象类和接口在语法上的区别。<br>至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会&#x2F;学习。</p>
<p>抽象类是半抽象的。<br>接口是完全抽象的。</p>
<p>抽象类中有构造方法。<br>接口中没有构造方法。</p>
<p>接口和接口之间支持多继承。<br>类和类之间只能单继承。</p>
<p>一个类可以同时实现多个接口。<br>一个抽象类只能继承一个类（单继承）。</p>
<p>接口中只允许出现常量和抽象方法。</p>
<p>这里先透露一个信息：<br>以后接口使用的比抽象类多。一般抽象类使用的还是少。<br>接口一般都是对“行为”的抽象。</p>
<h3 id="package和import"><a href="#package和import" class="headerlink" title="package和import"></a>package和import</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于java语言中的package和import机制：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1、为什么要使用package？</span></span><br><span class="line"><span class="comment">            package是java中包机制。包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。（按照功能划分的，不同的软件包具有不同的功能。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、package怎么用？</span></span><br><span class="line"><span class="comment">            package是一个关键字，后面加包名。例如：	package com.bjpowernode.javase.chapter17;  		注意：package语句只允许出现在java源代码的第一行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、包名有没有命名规范？有</span></span><br><span class="line"><span class="comment">            一般都采用公司域名倒序的方式（因为公司域名具有全球唯一性。）</span></span><br><span class="line"><span class="comment">            包名命名规范：</span></span><br><span class="line"><span class="comment">                公司域名倒序 + 项目名 + 模块名 + 功能名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、对于带有package的java程序怎么编译？怎么运行？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            采用之前的编译和运行不行了。</span></span><br><span class="line"><span class="comment">            类名不再是：HelloWorld了。</span></span><br><span class="line"><span class="comment">            类名是：com.bjpowernode.javase.chapter17.HelloWorld</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            编译：</span></span><br><span class="line"><span class="comment">                javac -d . HelloWorld.java</span></span><br><span class="line"><span class="comment">                解释一下：</span></span><br><span class="line"><span class="comment">                    javac 负责编译的命令</span></span><br><span class="line"><span class="comment">                    -d		带包编译</span></span><br><span class="line"><span class="comment">                    .		代表编译之后生成的东西放到当前目录下（点代表当前目录）</span></span><br><span class="line"><span class="comment">                    HelloWorld.java  被编译的java文件名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            运行：</span></span><br><span class="line"><span class="comment">                java com.bjpowernode.javase.chapter17.HelloWorld</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        5、关于import的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            import什么时候使用？</span></span><br><span class="line"><span class="comment">                A类中使用B类。</span></span><br><span class="line"><span class="comment">                A和B类都在同一个包下。不需要import。</span></span><br><span class="line"><span class="comment">                A和B类不在同一个包下。需要使用import。</span></span><br><span class="line"><span class="comment">                java.lang.*;这个包下的类不需要使用import导入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            import怎么用？</span></span><br><span class="line"><span class="comment">                import语句只能出现在package语句之下，class声明语句之上。</span></span><br><span class="line"><span class="comment">                import语句还可以采用星号的方式。(导入所有类)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.javase.chapter17;</span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.javase.chapter17.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------Scanner解释---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么要这样写？</span></span><br><span class="line">        <span class="comment">// Test03类和Scanner类不在同一个包下。</span></span><br><span class="line">        <span class="comment">// java.util就是Scanner类的包名。</span></span><br><span class="line">        <span class="comment">//java.util.Scanner s = new java.util.Scanner(System.in);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的字符串是---&gt;&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>package出现在java源文件第一行。</li>
<li>带有包名怎么编译？javac -d . xxx.java</li>
<li>怎么运行？java 完整类名</li>
</ul>
<p>补充：以后说类名的时候，如果带着包名描述，表示完整类名。<br>如果没有带包，描述的话，表示简类名。<br>java.util.Scanner 完整类名。<br>Scanner 简类名</p>
<p>import什么时候不需要？<br>java.lang不需要。<br>同包下不需要。<br>其它一律都需要。</p>
<p>怎么用？<br>import 完整类名;<br>import 包名.*;</p>
<p>import java.util.Scanner; &#x2F;&#x2F; 完整类名。</p>
<p>&#x2F;&#x2F; 同学的疑问：这样是不是效率比较低。<br>&#x2F;&#x2F; 这个效率不低，因为编译器在编译的时候，会自动把<em>变成具体的类名。<br>import java.util.</em>;</p>
<p>&#x2F;&#x2F; 想省懒劲你不能太省了。<br>import java.<em>; 这是不允许的，因为在java语言中规定，这里的</em>只代表某些类的名字。</p>
<h3 id="objective类"><a href="#objective类" class="headerlink" title="objective类"></a>objective类</h3><p>目前为止我们只需要知道这几个方法即可：</p>
<ul>
<li>protected Object clone()   &#x2F;&#x2F; 负责对象克隆的。</li>
<li>int hashCode()&#x2F;&#x2F; 获取对象哈希值的一个方法。</li>
<li>boolean equals(Object obj)  &#x2F;&#x2F; 判断两个对象是否相等</li>
<li>String toString()  &#x2F;&#x2F; 将对象转换成字符串形式</li>
<li>protected void finalize()  &#x2F;&#x2F; 垃圾回收器负责调用的方法</li>
</ul>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于Object类中的toString()方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1、源代码长什么样？</span></span><br><span class="line"><span class="comment">            public String toString() &#123;</span></span><br><span class="line"><span class="comment">                return this.getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            源代码上toString()方法的默认实现是：</span></span><br><span class="line"><span class="comment">                类名@对象的内存地址转换为十六进制的形式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、SUN公司设计toString()方法的目的是什么？</span></span><br><span class="line"><span class="comment">            toString()方法的作用是什么？</span></span><br><span class="line"><span class="comment">                toString()方法的设计目的是：通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、其实SUN公司开发java语言的时候，建议所有的子类都去重写toString()方法。toString()方法应该是一个简洁的、详实的、易阅读的.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 一个日期对象转换成字符串形式的话，我可能还是希望能看到具体的日期信息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> t1.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MyTime类重写toString()方法之前</span></span><br><span class="line">        <span class="comment">//System.out.println(s1); // MyTime@28a418fc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//MyTime类重写toString()方法之后</span></span><br><span class="line">        System.out.println(s1); <span class="comment">// 1970年1月1日</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：输出引用的时候，会自动调用该引用的toString()方法。</span></span><br><span class="line">        System.out.println(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTime</span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    <span class="comment">// 这个toString()方法怎么重写呢？</span></span><br><span class="line">    <span class="comment">// 越简洁越好，可读性越强越好。</span></span><br><span class="line">    <span class="comment">// 向简洁的、详实的、易阅读的方向发展</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//return this.year + &quot;年&quot; + this.month + &quot;月&quot; + this.day + &quot;日&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year + <span class="string">&quot;/&quot;</span> + <span class="built_in">this</span>.month + <span class="string">&quot;/&quot;</span> + <span class="built_in">this</span>.day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以后所有类的toString()方法是需要重写的。</li>
<li>重写规则，越简单越明了就好。</li>
<li>System.out.println(引用); 这里会自动调用“引用”的toString()方法。</li>
<li>ring类是SUN写的，toString方法已经重写了。</li>
</ul>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于Object类中的equals方法</span></span><br><span class="line"><span class="comment">        1、equals方法的源代码</span></span><br><span class="line"><span class="comment">            public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">                return (this == obj);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            以上这个方法是Object类的默认实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、SUN公司设计equals方法的目的是什么？</span></span><br><span class="line"><span class="comment">            以后编程的过程当中，都要通过equals方法来判断两个对象是否相等。equals方法是判断两个对象是否相等的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、我们需要研究一下Object类给的这个默认的equals方法够不够用！！！！</span></span><br><span class="line"><span class="comment">                在Object类中的equals方法当中，默认采用的是“==”判断两个java对象是否相等。而“==”判断的是两个java对象的内存地址，我们应该判断两个java对象的内容是否相等。所以老祖宗的equals方法不够用，需要子类重写equals。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、判断两个java对象是否相等，不能使用“==”，因为“==”比较的是两个对象的内存地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个基本数据类型的数据是否相等直接使用“==”就行。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 这个“==”是判断a中保存的100和b中保存的100是否相等。</span></span><br><span class="line">        System.out.println(a == b); <span class="comment">//true（相等） false(不相等)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个java对象是否相等，我们怎么办？能直接使用“==”吗？</span></span><br><span class="line">        <span class="comment">// 创建一个日期对象是：2008年8月8日。</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">//MyTime t1 = 0x1234;</span></span><br><span class="line">        <span class="comment">// 创建了一个新的日期对象，但表示的日期也是：2008年8月8日。</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">//MyTime t2 = 0x3698;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试以下，比较两个对象是否相等，能不能使用“==”？？？</span></span><br><span class="line">        <span class="comment">// 这里的“==”判断的是：t1中保存的对象内存地址和t2中保存的对象内存地址是否相等。</span></span><br><span class="line">        System.out.println(t1 == t2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写Object equals方法之前（比较的是对象内存地址）</span></span><br><span class="line">        <span class="comment">// 重写Object equals方法之后（比较的是内容。）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> t1.equals(t2);</span><br><span class="line">        System.out.println(flag); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再创建一个新的日期</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 两个日期不相等，就是false。</span></span><br><span class="line">        System.out.println(t1.equals(t3)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们这个程序有bug吗？可以运行，但是效率怎么样？低（怎么改造。）</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(t1.equals(t4)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTime</span> &#123; <span class="comment">//extends Object&#123;</span></span><br><span class="line">    <span class="type">int</span> year;<span class="type">int</span> month;<span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的equals方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">        return (this == obj);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写Object类的equals方法</span></span><br><span class="line">    <span class="comment">// 怎么重写？复制粘贴。相同的返回值类型、相同的方法名、相同的形式参数列表。</span></span><br><span class="line">    <span class="comment">// equals到底应该怎么重写？你自己定，你认为两个对象什么相等的时候表示相等，你就怎么重写。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 当年相同，月相同，并且日也相同的时候，表示两个日期相同。两个对象相等。</span></span><br><span class="line">        <span class="comment">// 获取第一个日期的年月日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year1</span> <span class="operator">=</span> <span class="built_in">this</span>.year;</span><br><span class="line">        <span class="type">int</span> <span class="variable">month1</span> <span class="operator">=</span> <span class="built_in">this</span>.month;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day1</span> <span class="operator">=</span> <span class="built_in">this</span>.day;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取第二个日期的年月日</span></span><br><span class="line">        <span class="comment">//int year2 = obj.year;</span></span><br><span class="line">        <span class="comment">//int month2 = obj.month;</span></span><br><span class="line">        <span class="comment">//int day2 = obj.day;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> MyTime)&#123;</span><br><span class="line">            <span class="type">MyTime</span> <span class="variable">t</span> <span class="operator">=</span> (MyTime)obj;</span><br><span class="line">            <span class="type">int</span> <span class="variable">year2</span> <span class="operator">=</span> t.year;</span><br><span class="line">            <span class="type">int</span> <span class="variable">month2</span> <span class="operator">=</span> t.month;</span><br><span class="line">            <span class="type">int</span> <span class="variable">day2</span> <span class="operator">=</span> t.day;</span><br><span class="line">            <span class="keyword">if</span>(year1 == year2 &amp;&amp; month1 == month2 &amp;&amp; day1 == day2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够执行到此处表示日期不相等。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改良。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果obj是空，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果obj不是一个MyTime，没必要比较了 ，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> MyTime))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果this和obj保存的内存地址相同，没必要比较了，直接返回true。</span></span><br><span class="line">        <span class="comment">// 内存地址相同的时候指向的堆内存的对象肯定是同一个。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够执行到此处说明什么？</span></span><br><span class="line">        <span class="comment">// 说明obj不是null，obj是MyTime类型。</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t</span> <span class="operator">=</span> (MyTime)obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year == t.year &amp;&amp; <span class="built_in">this</span>.month == t.month &amp;&amp; <span class="built_in">this</span>.day == t.day ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===最终版本===</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> MyTime))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">t</span> <span class="operator">=</span> (MyTime)obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year == t.year &amp;&amp; <span class="built_in">this</span>.month == t.month &amp;&amp; <span class="built_in">this</span>.day == t.day ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    private String idCard;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java语言当中的字符串String有没有重写toString方法，有没有重写equals方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总结：</span></span><br><span class="line"><span class="comment">        1、String类已经重写了equals方法，比较两个字符串不能使用==，必须使用equals。equals是通用的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、String类已经重写了toString方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    大结论：</span></span><br><span class="line"><span class="comment">        java中什么类型的数据可以使用“==”判断java中基本数据类型比较是否相等，使用==</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        java中什么类型的数据需要使用equals判断java中所有的引用数据类型统一使用equals方法来判断是否相等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这是规矩。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大部分情况下，采用这样的方式创建字符串对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际上String也是一个类。不属于基本数据类型。</span></span><br><span class="line">        <span class="comment">// 既然String是一个类，那么一定存在构造方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">        <span class="comment">// new两次，两个对象内存地址，s3保存的内存地址和s4保存的内存地址不同。</span></span><br><span class="line">        <span class="comment">// == 判断的是内存地址。不是内容。</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个字符串能不能使用双等号？</span></span><br><span class="line">        <span class="comment">// 不能，必须调用equals方法。</span></span><br><span class="line">        <span class="comment">// String类已经重写equals方法了。</span></span><br><span class="line">        System.out.println(s3.equals(s4)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类有没有重写toString方法呢？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;动力节点&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果String没有重写toString()方法，输出结果：java.lang.String@十六进制的地址</span></span><br><span class="line">        <span class="comment">// 经过测试：String类已经重写了toString()方法。</span></span><br><span class="line">        System.out.println(x.toString()); <span class="comment">//动力节点</span></span><br><span class="line">        System.out.println(x); <span class="comment">//动力节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> no; <span class="comment">//基本数据类型，比较时使用：==</span></span><br><span class="line">    <span class="comment">// 所在学校</span></span><br><span class="line">    String school; <span class="comment">//引用数据类型，比较时使用：equals方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> no,String school)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.school = school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;学号&quot;</span> + no + <span class="string">&quot;，所在学校名称&quot;</span> + school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals方法</span></span><br><span class="line">    <span class="comment">// 需求：当一个学生的学号相等，并且学校相同时，表示同一个学生。</span></span><br><span class="line">    <span class="comment">// 思考：这个equals该怎么重写呢？</span></span><br><span class="line">    <span class="comment">// equals方法的编写模式都是固定的。架子差不多。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Student)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.no == s.no &amp;&amp; <span class="built_in">this</span>.school.equals(s.school);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串用双等号比较可以吗？</span></span><br><span class="line">        <span class="comment">// 不可以</span></span><br><span class="line">        <span class="comment">//return this.no == s.no &amp;&amp; this.school == s.school;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals方法重写的时候要彻底。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态（自动类型转换。）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;大兴区&quot;</span>,<span class="string">&quot;11111&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;大兴区&quot;</span>,<span class="string">&quot;11111&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(u1.equals(u2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;朝阳区&quot;</span>,<span class="string">&quot;11112&quot;</span>));</span><br><span class="line">        System.out.println(u1.equals(u3)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 用户的住址</span></span><br><span class="line">    Address addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Address addr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals方法</span></span><br><span class="line">    <span class="comment">// 重写规则：当一个用户的用户名和家庭住址都相同，表示同一个用户。</span></span><br><span class="line">    <span class="comment">// 这个equals判断的是User对象和User对象是否相等。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="comment">// 用户名和用户名相同，住址和住址相同的时候，认定是同一个用户。</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> User)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(u.name) &amp;&amp; <span class="built_in">this</span>.addr.equals(u.addr))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city,String street,String zipcode)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">        <span class="built_in">this</span>.street = street;</span><br><span class="line">        <span class="built_in">this</span>.zipcode = zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里并没有重写equals方法。</span></span><br><span class="line">    <span class="comment">// 这里的equals方法判断的是：Address对象和Address对象是否相等。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Address)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 怎么算是家庭住址相同呢？</span></span><br><span class="line">        <span class="comment">// 城市相同，街道相同，邮编相同，表示相同。</span></span><br><span class="line">        <span class="type">Address</span> <span class="variable">a</span> <span class="operator">=</span> (Address)obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.city.equals(a.city)</span><br><span class="line">            &amp;&amp; <span class="built_in">this</span>.street.equals(a.street)</span><br><span class="line">            &amp;&amp; <span class="built_in">this</span>.zipcode.equals(a.zipcode))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。</li>
<li>重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。</li>
<li>基本数据类型比较实用：&#x3D;&#x3D;</li>
<li>对象和对象比较：调用equals方法</li>
<li>String类是SUN编写的，所以String类的equals方法重写了。</li>
<li>以后判断两个字符串是否相等，最好不要使用&#x3D;&#x3D;，要调用字符串对象的equals方法。</li>
<li>注意：重写equals方法的时候要彻底。</li>
</ul>
<h4 id="finalize-【非重点】【jdk9之后就没了】"><a href="#finalize-【非重点】【jdk9之后就没了】" class="headerlink" title="finalize()【非重点】【jdk9之后就没了】"></a>finalize()【非重点】【jdk9之后就没了】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于Object类中的finalize()方法。（非重点  非重点  非重点  了解即可。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1、在Object类中的源代码：</span></span><br><span class="line"><span class="comment">            protected void finalize() throws Throwable &#123; &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            GC：负责调用finalize()方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。</span></span><br><span class="line"><span class="comment">        不像equals toString，equals和toString()方法是需要你写代码调用的。</span></span><br><span class="line"><span class="comment">        finalize()只需要重写，重写完将来自动会有程序来调用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、finalize()方法的执行时机：</span></span><br><span class="line"><span class="comment">            当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用</span></span><br><span class="line"><span class="comment">            finalize()方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        5、finalize()方法实际上是SUN公司为java程序员准备的一个时机，垃圾销毁时机。</span></span><br><span class="line"><span class="comment">        如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        6、静态代码块的作用是什么？</span></span><br><span class="line"><span class="comment">            static &#123;</span></span><br><span class="line"><span class="comment">                ....</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            静态代码块在类加载时刻执行，并且只执行一次。</span></span><br><span class="line"><span class="comment">            这是一个SUN准备的类加载时机。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            finalize()方法同样也是SUN为程序员准备的一个时机。</span></span><br><span class="line"><span class="comment">            这个时机是垃圾回收时机。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        7、提示：</span></span><br><span class="line"><span class="comment">            java中的垃圾回收器不是轻易启动的，</span></span><br><span class="line"><span class="comment">            垃圾太少，或者时间没到，种种条件下，</span></span><br><span class="line"><span class="comment">            有可能启动，也有可能不启动。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 创建对象</span></span><br><span class="line"><span class="comment">        Person p = new Person();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 有一段代码可以建议垃圾回收器启动。</span></span><br><span class="line"><span class="comment">            if(i % 2 == 0)&#123;</span></span><br><span class="line"><span class="comment">                System.gc(); // 建议启动垃圾回收器。（只是建议，可能不启动，也可能启动。启动的概率高了一些。）</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 项目开发中有这样的业务需求：所有对象在JVM中被释放的时候，请记录一下释放时间！！！</span></span><br><span class="line"><span class="comment">// 记录对象被释放的时间点，这个负责记录的代码写到哪里？</span></span><br><span class="line"><span class="comment">// 写到finalize()方法中。</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 重写finalize()方法</span></span><br><span class="line"><span class="comment">    // Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用：p.finalize();</span></span><br><span class="line"><span class="comment">    protected void finalize() throws Throwable &#123;</span></span><br><span class="line"><span class="comment">        // this代表当前对象</span></span><br><span class="line"><span class="comment">        System.out.println(this + &quot;即将被销毁！&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个方法是protected修饰的，在Object类中这个方法的源代码是？<br>protected void finalize() throws Throwable { }</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    hashCode方法：</span></span><br><span class="line"><span class="comment">        在Object中的hashCode方法是怎样的？</span></span><br><span class="line"><span class="comment">            public native int hashCode();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            这个方法不是抽象方法，带有native关键字，底层调用C++程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        hashCode()方法返回的是哈希码：</span></span><br><span class="line"><span class="comment">            实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。</span></span><br><span class="line"><span class="comment">            所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodeValue</span> <span class="operator">=</span> o.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。</span></span><br><span class="line">        System.out.println(hashCodeValue); <span class="comment">//798154996</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodeValue2</span> <span class="operator">=</span> mc.hashCode();</span><br><span class="line">        System.out.println(hashCodeValue2); <span class="comment">//1392838282</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        System.out.println(mc2.hashCode()); <span class="comment">// 523429237</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名内部类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1、什么是内部类？</span></span><br><span class="line"><span class="comment">            内部类：在类的内部又定义了一个新的类。被称为内部类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2、内部类的分类：</span></span><br><span class="line"><span class="comment">            静态内部类：类似于静态变量</span></span><br><span class="line"><span class="comment">            实例内部类：类似于实例变量</span></span><br><span class="line"><span class="comment">            局部内部类：类似于局部变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、使用内部类编写的代码，可读性很差。能不用尽量不用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4、匿名内部类是局部内部类的一种。</span></span><br><span class="line"><span class="comment">            因为这个类没有名字而得名，叫做匿名内部类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。</span></span><br><span class="line"><span class="comment">        并不代表以后都要这样写。因为匿名内部类有两个缺点：</span></span><br><span class="line"><span class="comment">            缺点1：太复杂，太乱，可读性差。</span></span><br><span class="line"><span class="comment">            缺点2：类没有名字，以后想重复使用，不能用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        6、不理解算了，你只要记住这种写法就行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="comment">// 该类在类的内部，所以称为内部类</span></span><br><span class="line">    <span class="comment">// 由于前面有static，所以称为“静态内部类”</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner1</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 该类在类的内部，所以称为内部类</span></span><br><span class="line">    <span class="comment">// 没有static叫做实例内部类。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner2</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 该类在类的内部，所以称为内部类</span></span><br><span class="line">        <span class="comment">// 局部内部类。</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner3</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// doSome()方法中的局部内部类Inner3，在doOther()中不能用。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main方法，入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用MyMath中的mySum方法。</span></span><br><span class="line">        <span class="type">MyMath</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMath</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Compute c = new ComputeImpl();</span></span><br><span class="line"><span class="comment">        mm.mySum(c, 100, 200);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）</span></span><br><span class="line">        <span class="comment">//mm.mySum(new ComputeImpl(), 100, 200);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名内部类，表示这个ComputeImpl这个类没名字了。</span></span><br><span class="line">        <span class="comment">// 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。</span></span><br><span class="line">        <span class="comment">// 后面的&#123;&#125; 代表了对接口的实现。</span></span><br><span class="line">        <span class="comment">// 不建议使用匿名内部类，为什么？</span></span><br><span class="line">        <span class="comment">// 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。</span></span><br><span class="line">        mm.mySum(<span class="keyword">new</span> <span class="title class_">Compute</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责计算的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Compute</span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMath</span>&#123;</span><br><span class="line">    <span class="comment">// 数学求和方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySum</span><span class="params">(Compute c, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retValue</span> <span class="operator">=</span> c.sum(x, y);</span><br><span class="line">        System.out.println(x + <span class="string">&quot;+&quot;</span> + y + <span class="string">&quot;=&quot;</span> + retValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h3><p>访问控制权限都有哪些？4个。</p>
<ul>
<li>private私有 只能在本类中访问</li>
<li>public 公开 任何地方都能访问</li>
<li>protected受保护 只能在本类、同包、子类中访问。</li>
<li>默认 只能在本类，以及同包下访问。</li>
</ul>
<table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>任意位置</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>protected</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>不行</td>
</tr>
<tr>
<td>private</td>
<td>可以</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
</tr>
<tr>
<td>默认</td>
<td>可以</td>
<td>可以</td>
<td>不行</td>
<td>不行</td>
</tr>
</tbody></table>
<p>这个不要死记硬背，自己下去之后编写代码自己测试。</p>
<p>范围从大到小排序：public &gt; protected &gt; 默认 &gt; private</p>
<p>访问控制权限修饰符可以修饰什么？</p>
<ul>
<li>属性（4个都能用）</li>
<li>方法（4个都能用）</li>
<li>类（public和默认能用，其它不行。）</li>
<li>接口（public和默认能用，其它不行。）</li>
</ul>
<h1 id="数组和常用类"><a href="#数组和常用类" class="headerlink" title="数组和常用类"></a>数组和常用类</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object</p>
<p>数组实际上是一个容器，可以同时容纳多个元素。（数组是一个数据的集合。）数组：字面意思是“一组数据”</p>
<p>数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据</p>
<p>数组是存储在堆当中的</p>
<p>数组当中如果存储的是“java对象”的话，实际上存储的是对象的“引用（内存地址）”，数组中不能直接存储java对象。</p>
<p>数组长度不可变</p>
<p>所有的数组对象都有length<strong>属性</strong>(java自带的)，用来获取数组中元素的个数。</p>
<p>java中的数组要求数组中元素的类型统一。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。</p>
<p>数组在内存方面存储的时候，数组中的元素内存地址(存储的每一个元素都是有规则的挨着排列的)是连续的。内存地址连续。  这是数组存储元素的特点（特色）。数组实际上是一种简单的数据结构。</p>
<p>所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。   （数组中首元素的内存地址作为整个数组对象的内存地址。）</p>
<p>数组中每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标是：length - 1</p>
<blockquote>
<p>数组这种数据结构的优点和缺点是什么？</p>
<p><strong>优点</strong>：查询&#x2F;查找&#x2F;检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构。</p>
<p><strong>缺点</strong>：<br>1.由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。（注意：对于数组中最后一个元素的增删，是没有效率影响的。）<br>2.数组不能存储大数据量。为什么？   因为很难在内存空间上找到一块特别大的连续的内存空间。</p>
<p>为什么检索效率高？</p>
<p>1.每一个元素的内存地址在空间存储上是连续的。<br>2.每一个元素类型相同，所以占用空间大小一样。<br>3.知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标上元素的内存地址。直接通过内存地址定位 元素，所以数组的检索效率是最高的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明一个int类型的数组，使用静态初始化的方式</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">689</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下标为6表示第7个元素，第7个元素没有，下标越界了。会出现什么异常呢？</span></span><br><span class="line">        <span class="comment">//System.out.println(a[6]); //ArrayIndexOutOfBoundsException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候采用静态初始化方式，什么时候使用动态初始化方式呢？</p>
<ul>
<li>当你创建数组的时候，确定数组中存储哪些具体的元素时，采用静态初始化方式。</li>
<li>当你创建数组的时候，不确定将来数组中存储哪些数据，你可以采用动态初始化的方式，预先分配内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 采用动态初始化的方式</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]; <span class="comment">// 创建长度为4的int数组，数组中每个元素的默认值是0</span></span><br><span class="line">        Object[] objs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">3</span>]; <span class="comment">// 3个长度，动态初始化，所以每个元素默认值是null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用静态初始化的方式</span></span><br><span class="line">        String[] strs2 = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;xyz&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">            System.out.println(strs2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object[] objects = &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>()&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个方法的参数是一个数组的时候，我们还可以采用这种方式传递参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态初始化一维数组</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        printArray(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没有这种语法。</span></span><br><span class="line">        <span class="comment">//printArray(&#123;1,2,3&#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果直接传递一个静态数组的话，语法必须这样写。</span></span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态初始化一维数组</span></span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        printArray(a2);</span><br><span class="line"></span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="main方法的String-参数"><a href="#main方法的String-参数" class="headerlink" title="main方法的String[] 参数"></a>main方法的String[] 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、main方法上面的“String[] args”有什么用？</span></span><br><span class="line"><span class="comment">    分析以下：谁负责调用main方法（JVM）</span></span><br><span class="line"><span class="comment">    JVM调用main方法的时候，会自动传一个String数组过来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest05</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// JVM默认传递过来的这个数组对象的长度？默认0</span></span><br><span class="line">        <span class="comment">// 通过测试得出：args不是null。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;JVM给传递过来的String数组参数，它这个数组的长度是？&quot;</span> + args.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一维数组的深入，数组中存储的类型为：引用数据类型</span></span><br><span class="line"><span class="comment"> * 对于数组来说，实际上只能存储java对象的“内存地址”。数组中存储的每个元素是“引用”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Animal类型的数组，数组当中存储Cat和Bird</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        Animal[] anis = &#123;c, b&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Animal[] anis = &#123;new Cat(), new Bird()&#125;; // 该数组中存储了两个对象的内存地址。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; anis.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 这个取出来的可能是Cat，也可能是Bird，不过肯定是一个Animal</span></span><br><span class="line">            <span class="comment">// 如果调用的方法是父类中存在的方法不需要向下转型。直接使用父类型引用调用即可。</span></span><br><span class="line">            <span class="comment">//anis[i]</span></span><br><span class="line">            <span class="comment">//Animal an = anis[i];</span></span><br><span class="line">            <span class="comment">//an.move();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Animal中没有sing()方法。</span></span><br><span class="line">            <span class="comment">//anis[i].sing();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用子对象特有方法的话，需要向下转型！！！</span></span><br><span class="line">            <span class="keyword">if</span>(anis[i] <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)anis[i];</span><br><span class="line">                cat.catchMouse();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(anis[i] <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">                <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird)anis[i];</span><br><span class="line">                bird.sing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的扩容和拷贝"><a href="#数组的扩容和拷贝" class="headerlink" title="数组的扩容和拷贝"></a>数组的扩容和拷贝</h3><p>关于一维数组的扩容。</p>
<p>在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？扩容。</p>
<p>java中对数组的扩容是：先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。</p>
<p>结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。</p>
<p>可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// java中的数组是怎么进行拷贝的呢？</span></span><br><span class="line">        <span class="comment">//System.arraycopy(5个参数);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝源（从这个数组中拷贝）</span></span><br><span class="line">        <span class="type">int</span>[] src = &#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝目标（拷贝到这个目标数组上）</span></span><br><span class="line">        <span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>]; <span class="comment">// 动态初始化一个长度为20的数组，每一个元素默认值0</span></span><br><span class="line"></span><br><span class="line">        System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, src.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组中如果存储的元素是引用，可以拷贝吗？当然可以。</span></span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;oracle&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;jdbc&quot;</span>&#125;;</span><br><span class="line">        String[] newStrs = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">20</span>];</span><br><span class="line">        System.arraycopy(strs, <span class="number">0</span>, newStrs, <span class="number">0</span>, strs.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">        Object[] objs = &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>()&#125;;</span><br><span class="line">        Object[] newObjs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 思考一下：这里拷贝的时候是拷贝对象，还是拷贝对象的地址。（地址。）</span></span><br><span class="line">        System.arraycopy(objs, <span class="number">0</span>, newObjs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维数组</span></span><br><span class="line">        String[][] array = &#123;</span><br><span class="line">                &#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;oracle&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;c#&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123; <span class="comment">// 外层循环3次。（负责纵向。）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++)&#123;</span><br><span class="line">                System.out.print(array[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态初始化二维数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3行4列。</span></span><br><span class="line">        <span class="comment">// 3个一维数组，每一个一维数组当中4个元素。</span></span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化</span></span><br><span class="line">        <span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">76</span>&#125;,&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">        printArray(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以这样写。</span></span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">76</span>&#125;,&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[][] array)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历二维数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                System.out.print(array[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每次都重写toString和equals方法 ！！！！</strong></p>
<ul>
<li>第一：空间存储上，内存地址是连续的。</li>
<li>第二：每个元素占用的空间大小相同。</li>
<li>第三：知道首元素的内存地址。</li>
<li>第四：通过下标可以计算出偏移量。</li>
</ul>
<p>优点：检索效率高。直接通过内存地址定位，效率非常高。<br>缺点：随机增删效率较低，数组无法存储大数据量。<br>注意：数组最后一个元素的增删效率不受影响。</p>
<h3 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用以下数组工具类：java.util.Arrays;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">112</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工具类当中的方法大部分都是静态的。</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好消息：</span></span><br><span class="line"><span class="comment"> *  SUN公司已经为我们程序员写好了一个数组工具类。</span></span><br><span class="line"><span class="comment"> *  java.util.Arrays;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// java.util.Arrays; 工具类中有哪些方法，我们开发的时候要参考API帮助文档</span></span><br><span class="line">        <span class="comment">// 不要死记硬背。</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二分法查找（建立在排序基础之上。）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(index == -<span class="number">1</span> ? <span class="string">&quot;该元素不存在&quot;</span> : <span class="string">&quot;该元素下标是：&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h5 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h5><p><code>java.lang.String</code></p>
<p>String表示字符串类型，属于引用数据类型，不属于基本数据类型。</p>
<p>在java中随便使用双引号括起来的都是String对象。例：”abc”，”def”，”hello world!”，这是3个String对象。</p>
<p>java中规定，双引号括起来的字符串，是不可变的，也就是说”abc”自出生到最终死亡，不可变，不能变成”abcd”，也不能变成”ab”</p>
<p>在JDK当中双引号括起来的字符串，例如：”abc” “def”都是直接存储在“方法区”的“字符串常量池”当中的。为什么SUN公司把字符串存储在一个“字符串常量池”当中呢。因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了<code>方法区的字符串常量池</code>当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span> + <span class="string">&quot;xy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析：这是使用new的方式创建的字符串对象。这个代码中的&quot;xy&quot;是从哪里来的？</span></span><br><span class="line">        <span class="comment">// 凡是双引号括起来的都在字符串常量池中有一份。</span></span><br><span class="line">        <span class="comment">// new对象的时候一定在堆内存当中开辟空间。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i变量中保存的是100这个值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// s变量中保存的是字符串对象的内存地址。</span></span><br><span class="line">        <span class="comment">// s引用中保存的不是&quot;abc&quot;，是0x1111</span></span><br><span class="line">        <span class="comment">// 而0x1111是&quot;abc&quot;字符串对象在“字符串常量池”当中的内存地址。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// &quot;hello&quot;是存储在方法区的字符串常量池当中</span></span><br><span class="line">        <span class="comment">// 所以这个&quot;hello&quot;不会新建。（因为这个对象已经存在了。）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 分析结果是true还是false？</span></span><br><span class="line">        <span class="comment">// == 双等号比较的是不是变量中保存的内存地址？是的。</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="comment">// 分析结果是true还是false？</span></span><br><span class="line">        <span class="comment">// == 双等号比较的是不是变量中保存的内存地址？是的。</span></span><br><span class="line">        System.out.println(x == y); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过这个案例的学习，我们知道了，字符串对象之间的比较不能使用“==”</span></span><br><span class="line">        <span class="comment">// &quot;==&quot;不保险。应该调用String类的equals方法。</span></span><br><span class="line">        <span class="comment">// String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。</span></span><br><span class="line">        System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;testString&quot;</span>);</span><br><span class="line">        <span class="comment">//String k = null;</span></span><br><span class="line">        <span class="comment">// &quot;testString&quot;这个字符串可以后面加&quot;.&quot;呢？</span></span><br><span class="line">        <span class="comment">// 因为&quot;testString&quot;是一个String字符串对象。只要是对象都能调用方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;testString&quot;</span>.equals(k)); <span class="comment">// 建议使用这种方式，因为这个可以避免空指针异常。</span></span><br><span class="line">        System.out.println(k.equals(<span class="string">&quot;testString&quot;</span>)); <span class="comment">// 存在空指针异常的风险。不建议这样写。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析以下程序，一共创建了几个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共3个对象：</p>
<ul>
<li>方法区字符串常量池中有1个：”hello”堆内存当中有两个String对象，一共3个。</li>
</ul>
<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p>关于String类中的构造方法。</p>
<ul>
<li>第一个：String s &#x3D; new String(“”);</li>
<li>第二个：String s &#x3D; “”; 最常用</li>
<li>第三个：String s &#x3D; new String(char数组);</li>
<li>第四个：String s &#x3D; new String(char数组,起始下标,长度);</li>
<li>第五个：String s &#x3D; new String(byte数组);</li>
<li>第六个：String s &#x3D; new String(byte数组,起始下标,长度)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建字符串对象最常用的一种方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span>  <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        <span class="comment">// s1这个变量中保存的是一个内存地址。</span></span><br><span class="line">        <span class="comment">// 按说以下应该输出一个地址。</span></span><br><span class="line">        <span class="comment">// 但是输出一个字符串，说明String类已经重写了toString()方法。</span></span><br><span class="line">        System.out.println(s1);<span class="comment">//hello world!</span></span><br><span class="line">        System.out.println(s1.toString()); <span class="comment">//hello world!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里只掌握常用的构造方法。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;; <span class="comment">// 97是a，98是b，99是c</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前面说过：输出一个引用的时候，会自动调用toString()方法，默认Object的话，会自动输出对象的内存地址。</span></span><br><span class="line">        <span class="comment">// 通过输出结果我们得出一个结论：String类已经重写了toString()方法。</span></span><br><span class="line">        <span class="comment">// 输出字符串对象的话，输出的不是对象的内存地址，而是字符串本身。</span></span><br><span class="line">        System.out.println(s2.toString()); <span class="comment">//abc</span></span><br><span class="line">        System.out.println(s2); <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String(字节数组,数组元素下标的起始位置,长度)</span></span><br><span class="line">        <span class="comment">// 将byte数组中的一部分转换成字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(s3); <span class="comment">// bc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将char数组全部转换成字符串</span></span><br><span class="line">        <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        <span class="comment">// 将char数组的一部分转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s5);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line">        System.out.println(s6); <span class="comment">//helloworld!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类当中常用方法。</span></span><br><span class="line">        <span class="comment">//1（掌握）.char charAt(int index)</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;中国人&quot;</span>.charAt(<span class="number">1</span>); <span class="comment">// &quot;中国人&quot;是一个字符串String对象。只要是对象就能“点.”</span></span><br><span class="line">        System.out.println(c); <span class="comment">// 国</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2（了解）.int compareTo(String anotherString)</span></span><br><span class="line">        <span class="comment">// 字符串之间比较大小不能直接使用 &gt; &lt; ，需要使用compareTo方法。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>.compareTo(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(result); <span class="comment">//0（等于0） 前后一致  10 - 10 = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>.compareTo(<span class="string">&quot;abce&quot;</span>);</span><br><span class="line">        System.out.println(result2); <span class="comment">//-1（小于0） 前小后大 8 - 9 = -1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result3</span> <span class="operator">=</span> <span class="string">&quot;abce&quot;</span>.compareTo(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        System.out.println(result3); <span class="comment">// 1（大于0） 前大后小 9 - 8 = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;xyz&quot;</span>.compareTo(<span class="string">&quot;yxz&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3（掌握）.boolean contains(CharSequence s)</span></span><br><span class="line">        <span class="comment">// 判断前面的字符串中是否包含后面的子字符串。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld.java&quot;</span>.contains(<span class="string">&quot;.java&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4（掌握）. boolean endsWith(String suffix)</span></span><br><span class="line">        <span class="comment">// 判断当前字符串是否以某个子字符串结尾。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.java&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.txt&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5（掌握）.boolean equals(Object anObject)</span></span><br><span class="line">        <span class="comment">// 比较两个字符串必须使用equals方法，不能使用“==”</span></span><br><span class="line">        <span class="comment">// equals方法有没有调用compareTo方法？ 老版本可以看一下。JDK13中并没有调用compareTo()方法。</span></span><br><span class="line">        <span class="comment">// equals只能看出相等不相等。</span></span><br><span class="line">        <span class="comment">// compareTo方法可以看出是否相等，并且同时还可以看出谁大谁小。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6（掌握）.boolean equalsIgnoreCase(String anotherString)</span></span><br><span class="line">        <span class="comment">// 判断两个字符串是否相等，并且同时忽略大小写。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;abC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7（掌握）.byte[] getBytes()</span></span><br><span class="line">        <span class="comment">// 将字符串对象转换成字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;abcdef&quot;</span>.getBytes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8（掌握）.int indexOf(String str)</span></span><br><span class="line">        <span class="comment">// 判断某个子字符串在当前字符串中第一次出现处的索引（下标）。</span></span><br><span class="line">System.out.println(<span class="string">&quot;oraclejavac++.netc#phppythonjavaoraclec++&quot;</span>.indexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9（掌握）.boolean isEmpty()</span></span><br><span class="line">        <span class="comment">// 判断某个字符串是否为“空字符串”。底层源代码调用的应该是字符串的length()方法。</span></span><br><span class="line">        <span class="comment">//String s = &quot;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(s.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10（掌握）. int length()</span></span><br><span class="line">        <span class="comment">// 面试题：判断数组长度和判断字符串长度不一样</span></span><br><span class="line">        <span class="comment">// 判断数组长度是length属性，判断字符串长度是length()方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.length()); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.length()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11（掌握）.int lastIndexOf(String str)</span></span><br><span class="line">        <span class="comment">// 判断某个子字符串在当前字符串中最后一次出现的索引（下标）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;oraclejavac++javac#phpjavapython&quot;</span>.lastIndexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12（掌握）. String replace(CharSequence target, CharSequence replacement)</span></span><br><span class="line">        <span class="comment">// 替换。</span></span><br><span class="line">        <span class="comment">// String的父接口就是：CharSequence</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newString</span> <span class="operator">=</span> <span class="string">&quot;http://www.baidu.com&quot;</span>.replace(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        System.out.println(newString); <span class="comment">//https://www.baidu.com</span></span><br><span class="line">        <span class="comment">// 把以下字符串中的“=”替换成“:”</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newString2</span> <span class="operator">=</span> <span class="string">&quot;name=zhangsan&amp;password=123&amp;age=20&quot;</span>.replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        System.out.println(newString2); <span class="comment">//name:zhangsan&amp;password:123&amp;age:20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13（掌握）.String[] split(String regex)</span></span><br><span class="line">        <span class="comment">// 拆分字符串</span></span><br><span class="line">        String[] ymd = <span class="string">&quot;1980-10-11&quot;</span>.split(<span class="string">&quot;-&quot;</span>); <span class="comment">//&quot;1980-10-11&quot;以&quot;-&quot;分隔符进行拆分。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 14（掌握）、boolean startsWith(String prefix)</span></span><br><span class="line">        <span class="comment">// 判断某个字符串是否以某个子字符串开始。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.startsWith(<span class="string">&quot;http&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 15（掌握）、 String substring(int beginIndex) 参数是起始下标。</span></span><br><span class="line">        <span class="comment">// 截取字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.substring(<span class="number">7</span>)); <span class="comment">//www.baidu.com</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 16（掌握）、String substring(int beginIndex, int endIndex)</span></span><br><span class="line">        <span class="comment">// beginIndex起始位置（包括）</span></span><br><span class="line">        <span class="comment">// endIndex结束位置（不包括）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.substring(<span class="number">7</span>, <span class="number">10</span>)); <span class="comment">//www</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 17(掌握)、char[] toCharArray()</span></span><br><span class="line">        <span class="comment">// 将字符串转换成char数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 18（掌握）、String toLowerCase()</span></span><br><span class="line">        <span class="comment">// 转换为小写。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABCDefKXyz&quot;</span>.toLowerCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 19（掌握）、String toUpperCase();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABCDefKXyz&quot;</span>.toUpperCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 20（掌握）. String trim();</span></span><br><span class="line">        <span class="comment">// 去除字符串前后空白</span></span><br><span class="line">        System.out.println(<span class="string">&quot;           hello      world             &quot;</span>.trim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 21（掌握）. String中只有一个方法是静态的，不需要new对象</span></span><br><span class="line">        <span class="comment">// 这个方法叫做valueOf</span></span><br><span class="line">        <span class="comment">// 作用：将“非字符串”转换成“字符串”</span></span><br><span class="line">        <span class="comment">//String s1 = String.valueOf(true);</span></span><br><span class="line">        <span class="comment">//String s1 = String.valueOf(100);</span></span><br><span class="line">        <span class="comment">//String s1 = String.valueOf(3.14);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个静态的valueOf()方法，参数是一个对象的时候，会自动调用该对象的toString()方法吗？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="keyword">new</span> <span class="title class_">Customer</span>());</span><br><span class="line">        <span class="comment">//System.out.println(s1); // 没有重写toString()方法之前是对象内存地址 com.bjpowernode.javase.string.Customer@10f87f48</span></span><br><span class="line">        System.out.println(s1); <span class="comment">//我是一个VIP客户！！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们是不是可以研究一下println()方法的源代码了？</span></span><br><span class="line">        System.out.println(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="number">3.14</span>);</span><br><span class="line">        System.out.println(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 通过源代码可以看出：为什么输出一个引用的时候，会调用toString()方法!!!!</span></span><br><span class="line">        <span class="comment">//　本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出。</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Customer</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是一个VIP客户！！！！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以后需要进行大量字符串的拼接操作，建议使用JDK中自带的：</p>
<ul>
<li>java.lang.StringBuffer</li>
<li>java.lang.StringBuilder</li>
</ul>
<p>如何优化StringBuffer的性能？</p>
<ul>
<li>在创建StringBuffer的时候尽可能给定一个初始化容量。</li>
<li>最好减少底层数组的扩容次数。预估计一下，给一个大一些初始化容量。</li>
<li>关键点：给一个合适的初始化容量。可以提高程序的执行效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个初始化容量为16个byte[] 数组。（字符串缓冲区对象）</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接字符串，以后拼接字符串统一调用 append()方法。</span></span><br><span class="line">        <span class="comment">// append是追加的意思。</span></span><br><span class="line">        stringBuffer.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuffer.append(<span class="number">3.14</span>);</span><br><span class="line">        stringBuffer.append(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// append方法底层在进行追加的时候，如果byte数组满了，会自动扩容。</span></span><br><span class="line">        stringBuffer.append(<span class="number">100L</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stringBuffer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定初始化容量的StringBuffer对象（字符串缓冲区对象）</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">100</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试题：String为什么是不可变的？</p>
<ul>
<li>我看过源代码，String类中有一个byte[]数组，这个byte[]数组采用了final修饰，因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可再指向其它对象，所以String是不可变的！”abc” 无法变成 “abcd”</li>
</ul>
<p>StringBuilder&#x2F;StringBuffer为什么是可变的呢？</p>
<ul>
<li>我看过源代码，StringBuffer&#x2F;StringBuilder内部实际上是一个byte[]数组，    这个byte[]数组没有被final修饰，StringBuffer&#x2F;StringBuilder的初始化容量我记得应该是16，当存满之后会进行扩容，底层调用了数组拷贝的方法System.arraycopy()…是这样扩容的。所以StringBuilder&#x2F;StringBuffer适合于使用字符串的频繁拼接操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.javase.stringbuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串不可变是什么意思？</span></span><br><span class="line">        <span class="comment">// 是说双引号里面的字符串对象一旦创建不可变。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;放到了字符串常量池当中。&quot;abc&quot;不可变。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s变量是可以指向其它对象的。</span></span><br><span class="line">        <span class="comment">// 字符串不可变不是说以上变量s不可变。说的是&quot;abc&quot;这个对象不可变。</span></span><br><span class="line">        s = <span class="string">&quot;xyz&quot;</span>;<span class="comment">//&quot;xyz&quot;放到了字符串常量池当中。&quot;xyz&quot;不可变。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java.lang.StringBuilder</p>
<p>StringBuffer和StringBuilder的区别？</p>
<ul>
<li>StringBuffer中的方法都有：synchronized关键字修饰。表示StringBuffer在多线程环境下运行是安全的。</li>
<li>StringBuilder中的方法都没有：synchronized关键字修饰，表示StringBuilder在多线程环境下运行是不安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringBuilder也是可以完成字符串的拼接。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">100</span>);</span><br><span class="line">        sb.append(<span class="literal">true</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;kitty&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型对应的包装类"><a href="#基本数据类型对应的包装类" class="headerlink" title="基本数据类型对应的包装类"></a>基本数据类型对应的包装类</h3><p>包装类存在有什么用？方便编程。</p>
<p>八种包装类的类名是什么？</p>
<ul>
<li>Byte</li>
<li>Short</li>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Character</li>
</ul>
<p>所有数字的父类Number<br>照葫芦画瓢：学习Integer，其它的模仿Integer。</p>
<p><strong>这里只写Integer的包装类，其他照葫芦画瓢</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、java中为8种基本数据类型又对应准备了8种包装类型。8种包装类属于引用数据类型，父类是Object。</span></span><br><span class="line"><span class="comment">2、思考：为什么要再提供8种包装类呢？因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest01</span> &#123;</span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 有没有这种需求：调用doSome()方法的时候需要传一个数字进去。</span></span><br><span class="line">        <span class="comment">// 但是数字属于基本数据类型，而doSome()方法参数的类型是Object。</span></span><br><span class="line">        <span class="comment">// 可见doSome()方法无法接收基本数据类型的数字。那怎么办呢？可以传一个数字对应的包装类进去。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>java.lang.Byte（父类Number）</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short（父类Number）</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer（父类Number）</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long（父类Number）</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float（父类Number）</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double（父类Number）</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean（父类Object）</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character（父类Object）</td>
</tr>
</tbody></table>
<p>以上八种包装类中，重点以java.lang.Integer为代表进行学习，其它的类型照葫芦画瓢就行。</p>
<p>八种包装类中其中6个都是数字对应的包装类，他们的父类都是Number，可以先研究一下Number中公共的方法：Number是一个抽象类，无法实例化对象。<br>Number类中有这样的方法：</p>
<ul>
<li>byte byteValue() 以 byte 形式返回指定的数值。</li>
<li>abstract  double doubleValue()以 double 形式返回指定的数值。</li>
<li>abstract  float floatValue()以 float 形式返回指定的数值。</li>
<li>abstract  int intValue()以 int 形式返回指定的数值。</li>
<li>abstract  long longValue()以 long 形式返回指定的数值。</li>
<li>short shortValue()以 short 形式返回指定的数值。</li>
</ul>
<p>这些方法其实所有的数字包装类的子类都有，这些方法是负责拆箱的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 123这个基本数据类型，进行构造方法的包装达到了：基本数据类型向引用数据类型的转换。</span></span><br><span class="line">        <span class="comment">// 基本数据类型 -(转换为)-&gt;引用数据类型（装箱）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将引用数据类型--(转换为)-&gt; 基本数据类型</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> i.floatValue();</span><br><span class="line">        System.out.println(f); <span class="comment">//123.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将引用数据类型--(转换为)-&gt; 基本数据类型（拆箱）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">retValue</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        System.out.println(retValue); <span class="comment">//123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于Integer类的构造方法，有两个：</span></span><br><span class="line"><span class="comment">    Integer(int)</span></span><br><span class="line"><span class="comment">    Integer(String)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好消息：在java5之后，引入了一种新特性，自动装箱和自动拆箱</span></span><br><span class="line"><span class="comment"> *  自动装箱：基本数据类型自动转换成包装类。</span></span><br><span class="line"><span class="comment"> *  自动拆箱：包装类自动转换成基本数据类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有了自动拆箱之后，Number类中的方法就用不着了！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自动装箱和自动拆箱的好处？</span></span><br><span class="line"><span class="comment"> *      方便编程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 900是基本数据类型</span></span><br><span class="line">        <span class="comment">// x是包装类型</span></span><br><span class="line">        <span class="comment">// 基本数据类型 --(自动转换)--&gt; 包装类型：自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x是包装类型</span></span><br><span class="line">        <span class="comment">// y是基本数据类型</span></span><br><span class="line">        <span class="comment">// 包装类型 --(自动转换)--&gt; 基本数据类型：自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// z是一个引用，z是一个变量，z还是保存了一个对象的内存地址。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 等同于：Integer z = new Integer(1000);</span></span><br><span class="line">        <span class="comment">// 分析为什么这个没有报错呢？</span></span><br><span class="line">        <span class="comment">// +两边要求是基本数据类型的数字，z是包装类，不属于基本数据类型，这里会进行自动拆箱。将z转换成基本数据类型</span></span><br><span class="line">        <span class="comment">// 在java5之前你这样写肯定编译器报错。</span></span><br><span class="line">        System.out.println(z + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// Integer a = new Integer(1000); a是个引用，保存内存地址指向对象。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// Integer b = new Integer(1000); b是个引用，保存内存地址指向对象。</span></span><br><span class="line">        <span class="comment">// == 比较的是对象的内存地址，a和b两个引用中保存的对象内存地址不同。</span></span><br><span class="line">        <span class="comment">// == 这个运算符不会触发自动拆箱机制。（只有+ - * /等运算的时候才会。）</span></span><br><span class="line">        System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题目是Integer非常重要的面试题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，</span></span><br><span class="line"><span class="comment">        放到了一个方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要</span></span><br><span class="line"><span class="comment">        再new了，直接从整数型常量池当中取出来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// == 永远判断的都是两个对象的内存地址是否相同。</span></span><br><span class="line">        System.out.println(x == y); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下以前遇到的经典的异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结一下之前所学的经典异常？</span></span><br><span class="line"><span class="comment">    空指针异常：NullPointerException</span></span><br><span class="line"><span class="comment">    类型转换异常：ClassCastException</span></span><br><span class="line"><span class="comment">    数组下标越界异常：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">    数字格式化异常：NumberFormatException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Integer类当中有哪些常用的方法呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动拆箱。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译的时候没问题，一切符合java语法，运行时会不会出问题呢？</span></span><br><span class="line">        <span class="comment">// 不是一个“数字”可以包装成Integer吗？不能。运行时出现异常。</span></span><br><span class="line">        <span class="comment">// java.lang.NumberFormatException</span></span><br><span class="line">        <span class="comment">//Integer a = new Integer(&quot;中文&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点方法</span></span><br><span class="line">        <span class="comment">// static int parseInt(String s)</span></span><br><span class="line">        <span class="comment">// 静态方法，传参String，返回int</span></span><br><span class="line">        <span class="comment">//网页上文本框中输入的100实际上是&quot;100&quot;字符串。后台数据库中要求存储100数字，此时java程序需要将&quot;100&quot;转换成100数字。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">retValue</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// String -转换-&gt; int</span></span><br><span class="line">        <span class="comment">//int retValue = Integer.parseInt(&quot;中文&quot;); // NumberFormatException</span></span><br><span class="line">        System.out.println(retValue + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 照葫芦画瓢</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">retValue2</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">        System.out.println(retValue2 + <span class="number">1</span>); <span class="comment">//4.140000000000001（精度问题）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">retValue3</span> <span class="operator">=</span> Float.parseFloat(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        System.out.println(retValue3 + <span class="number">1</span>); <span class="comment">//2.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----------------------------------以下内容作为了解，不需要掌握---------------------------------------</span></span><br><span class="line">        <span class="comment">// static String toBinaryString(int i)</span></span><br><span class="line">        <span class="comment">// 静态的：将十进制转换成二进制字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">3</span>);</span><br><span class="line">        System.out.println(binaryString); <span class="comment">//&quot;11&quot; 二进制字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// static String toHexString(int i)</span></span><br><span class="line">        <span class="comment">// 静态的：将十进制转换成十六进制字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(<span class="number">16</span>);</span><br><span class="line">        System.out.println(hexString); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 十六进制：1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a</span></span><br><span class="line">        hexString = Integer.toHexString(<span class="number">17</span>);</span><br><span class="line">        System.out.println(hexString); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//static String toOctalString(int i)</span></span><br><span class="line">        <span class="comment">// 静态的：将十进制转换成八进制字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(<span class="number">8</span>);</span><br><span class="line">        System.out.println(octalString); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//java.lang.Object@6e8cf4c6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// valueOf方法作为了解</span></span><br><span class="line">        <span class="comment">//static Integer valueOf(int i)</span></span><br><span class="line">        <span class="comment">// 静态的：int--&gt;Integer</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// static Integer valueOf(String s)</span></span><br><span class="line">        <span class="comment">// 静态的：String--&gt;Integer</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Integer String int三种类型互相转换</p>
<p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593166561323.png" title="1593166561323" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593166561323.png" alt="1593166561323"></a></p>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java中对日期的处理</span></span><br><span class="line"><span class="comment">    这个案例最主要掌握：</span></span><br><span class="line"><span class="comment">        知识点1：怎么获取系统当前时间</span></span><br><span class="line"><span class="comment">        知识点2：String ---&gt; Date</span></span><br><span class="line"><span class="comment">        知识点3：Date ---&gt; String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统当前时间（精确到毫秒的系统当前时间） 直接调用无参数构造方法就行。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.util.Date类的toString()方法已经被重写了。</span></span><br><span class="line">        <span class="comment">// 输出的应该不是一个对象的内存地址，应该是一个日期字符串。</span></span><br><span class="line">        <span class="comment">//System.out.println(nowTime); //Thu Mar 05 10:51:06 CST 2020</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日期可以格式化吗？</span></span><br><span class="line">        <span class="comment">// 将日期类型Date，按照指定的格式进行转换：Date --转换成具有一定格式的日期字符串--&gt;String</span></span><br><span class="line">        <span class="comment">// SimpleDateFormat是java.text包下的。专门负责日期格式化的。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        yyyy 年(年是4位)</span></span><br><span class="line"><span class="comment">        MM 月（月是2位）</span></span><br><span class="line"><span class="comment">        dd 日</span></span><br><span class="line"><span class="comment">        HH 时</span></span><br><span class="line"><span class="comment">        mm 分</span></span><br><span class="line"><span class="comment">        ss 秒</span></span><br><span class="line"><span class="comment">        SSS 毫秒（毫秒3位，最高999。1000毫秒代表1秒）</span></span><br><span class="line"><span class="comment">        注意：在日期格式中，除了y M d H m s S这些字符不能随便写之外，剩下的符号格式自己随意组织。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nowTimeStr</span> <span class="operator">=</span> sdf.format(nowTime);</span><br><span class="line">        System.out.println(nowTimeStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设现在有一个日期字符串String，怎么转换成Date类型？</span></span><br><span class="line">        <span class="comment">// String --&gt; Date</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;</span><br><span class="line">        <span class="comment">//SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;格式不能随便写，要和日期字符串格式相同&quot;);</span></span><br><span class="line">        <span class="comment">// 注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一致。不然会出现异常：java.text.ParseException</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateTime</span> <span class="operator">=</span> sdf2.parse(time);</span><br><span class="line">        System.out.println(dateTime); <span class="comment">//Fri Aug 08 08:08:08 CST 2008</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。</span></span><br><span class="line"><span class="comment">1秒 = 1000毫秒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">简单总结一下System类的相关属性和方法：</span></span><br><span class="line"><span class="comment">    System.out 【out是System类的静态变量。】</span></span><br><span class="line"><span class="comment">    System.out.println() 【println()方法不是System类的，是PrintStream类的方法。】</span></span><br><span class="line"><span class="comment">    System.gc() 建议启动垃圾回收器</span></span><br><span class="line"><span class="comment">    System.currentTimeMillis() 获取自1970年1月1日到系统当前时间的总毫秒数。</span></span><br><span class="line"><span class="comment">    System.exit(0) 退出JVM。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(nowTimeMillis); <span class="comment">//1583377912981</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计一个方法耗时</span></span><br><span class="line">        <span class="comment">// 在调用目标方法之前记录一个毫秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        print();</span><br><span class="line">        <span class="comment">// 在执行完目标方法之后记录一个毫秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗费时长&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求：统计一个方法执行所耗费的时长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个时间是什么时间？</span></span><br><span class="line">        <span class="comment">// 1970-01-01 00:00:00 001</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1</span>); <span class="comment">// 注意：参数是一个毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(time);</span><br><span class="line">        <span class="comment">// 北京是东8区。差8个小时。</span></span><br><span class="line">        System.out.println(strTime); <span class="comment">// 1970-01-01 08:00:00 001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取昨天的此时的时间。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime2</span> <span class="operator">=</span> sdf.format(time2);</span><br><span class="line">        System.out.println(strTime2); <span class="comment">//2020-03-04 11:44:14 829</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取“去年的今天”的时间</span></span><br><span class="line">        <span class="comment">// 自己玩。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取系统当前时间</p>
<ul>
<li>Date d &#x3D; new Date();</li>
<li>日期格式化：Date –&gt; String</li>
<li>yyyy-MM-dd HH:mm:ss SSS</li>
<li>SimpleDateFormat sdf &#x3D; new SimpleDate(“yyyy-MM-dd HH:mm:ss SSS”);</li>
<li>String s &#x3D; sdf.format(new Date());</li>
<li>String –&gt; Date</li>
<li>SimpleDateFormat sdf &#x3D; new SimpleDate(“yyyy-MM-dd HH:mm:ss”);</li>
<li>Date d &#x3D; sdf.parse(“2008-08-08 08:08:08”);</li>
<li>获取毫秒数</li>
<li>long begin &#x3D; System.currentTimeMillis();</li>
<li>Date d &#x3D; new Date(begin - 1000 * 60 * 60 * 24);</li>
</ul>
<h3 id="数字类"><a href="#数字类" class="headerlink" title="数字类"></a>数字类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于数字的格式化。（了解）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecimalFormatTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// java.text.DecimalFormat专门负责数字格式化的。</span></span><br><span class="line">        <span class="comment">//DecimalFormat df = new DecimalFormat(&quot;数字格式&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        数字格式有哪些？</span></span><br><span class="line"><span class="comment">            # 代表任意数字</span></span><br><span class="line"><span class="comment">            , 代表千分位</span></span><br><span class="line"><span class="comment">            . 代表小数点</span></span><br><span class="line"><span class="comment">            0 代表不够时补0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ###,###.##</span></span><br><span class="line"><span class="comment">                表示：加入千分位，保留2个小数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###,###.##&quot;</span>);</span><br><span class="line">        <span class="comment">//String s = df.format(1234.56);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> df.format(<span class="number">1234.561232</span>);</span><br><span class="line">        System.out.println(s); <span class="comment">// &quot;1,234.56&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###,###.0000&quot;</span>); <span class="comment">//保留4个小数位，不够补上0</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> df2.format(<span class="number">1234.56</span>);</span><br><span class="line">        System.out.println(s2); <span class="comment">// &quot;1,234.5600&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）</span></span><br><span class="line"><span class="comment">这是SUN提供的一个类。专门用在财务软件当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、注意：财务软件中double是不够的。咱们之前有一个学生去用友面试，经理就问了这样一个问题：</span></span><br><span class="line"><span class="comment">    你处理过财务数据吗？用的哪一种类型？</span></span><br><span class="line"><span class="comment">        千万别说double，说java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个100不是普通的100，是精度极高的100</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 精度极高的200</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="comment">// v1 + v2; // 这样不行，v1和v2都是引用，不能直接使用+求和。</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">v3</span> <span class="operator">=</span> v1.add(v2); <span class="comment">// 调用方法求和。</span></span><br><span class="line">        System.out.println(v3); <span class="comment">//300</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">v4</span> <span class="operator">=</span> v2.divide(v1);</span><br><span class="line">        System.out.println(v4); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>DecimalFormat数字格式化</li>
</ul>
<p>###,###.## 表示加入千分位，保留两个小数。<br>###,###.0000 表示加入千分位，保留4个小数，不够补0</p>
<ul>
<li><ul>
<li>BigDecimal</li>
</ul>
</li>
</ul>
<p>财务软件中通常使用BigDecimal</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建随机数对象</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机产生一个int类型取值范围内的数字。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(num1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 产生[0~100]之间的随机数。不能产生101。</span></span><br><span class="line">        <span class="comment">// nextInt翻译为：下一个int类型的数据是101，表示只能取到100.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> random.nextInt(<span class="number">101</span>); <span class="comment">//不包括101</span></span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>怎么产生int类型随机数。</li>
</ul>
<p>Random r &#x3D; new Random();<br>int i &#x3D; r.nextInt();</p>
<ul>
<li>怎么产生某个范围之内的int类型随机数。</li>
</ul>
<p>Random r &#x3D; new Random();<br>int i &#x3D; r.nextInt(101); &#x2F;&#x2F; 产生[0-100]的随机数。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// switch语句支持枚举类型</span></span><br><span class="line">        <span class="comment">// switch也支持String、int</span></span><br><span class="line">        <span class="comment">// 低版本的JDK，只支持int</span></span><br><span class="line">        <span class="comment">// 高版本的JDK，支持int、String、枚举。</span></span><br><span class="line">        <span class="comment">// byte short char也可以，因为存在自动类型转换。</span></span><br><span class="line">        <span class="keyword">switch</span> (Season.SPRING) &#123;</span><br><span class="line">            <span class="comment">// 必须省略Season.</span></span><br><span class="line">            <span class="keyword">case</span> SPRING:</span><br><span class="line">                System.out.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUMMER:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AUTUMN:</span><br><span class="line">                System.out.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WINTER:</span><br><span class="line">                System.out.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.javase.enum2; <span class="comment">// 标识符，关键字不能做标识符。enum是关键字。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个案例没有使用java中的枚举，分析以下程序，在设计方面有什么缺陷？</span></span><br><span class="line"><span class="comment">    以下代码可以编译，也可以运行。这些都没有问题。</span></span><br><span class="line"><span class="comment">    就是设计上你觉得有什么缺陷？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(10 / 0); //java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int retValue = divide(10, 2);</span></span><br><span class="line"><span class="comment">        System.out.println(retValue == 1 ? &quot;计算成功&quot; : &quot;计算失败&quot;); // 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int retValue2 = divide(10, 0);</span></span><br><span class="line"><span class="comment">        System.out.println(retValue2 == 0 ? &quot;计算失败&quot; : &quot;计算成功&quot;); // 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(success ? <span class="string">&quot;计算成功&quot;</span> : <span class="string">&quot;计算失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需求（这是设计者说的！）：以下程序，计算两个int类型数据的商，计算成功返回1，计算失败返回0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int类型的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b int类型的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回1表示成功，返回0表示失败！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static int divide(int a, int b)&#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            int c = a / b;</span></span><br><span class="line"><span class="comment">            // 程序执行到此处表示以上代码没有发生异常。表示执行成功！</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">            // 程序执行到此处表示以上程序出现了异常！</span></span><br><span class="line"><span class="comment">            // 表示执行失败！</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设计缺陷？在这个方法的返回值类型上。返回一个int不恰当。</span></span><br><span class="line">    <span class="comment">// 既然最后的结果只是成功和失败，最好使用布尔类型。因为布尔类型true和false正好可以表示两种不同的状态。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static int divide(int a, int b)&#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            int c = a / b;</span></span><br><span class="line"><span class="comment">            // 返回10已经偏离了需求，实际上已经出错了，但是编译器没有检查出来。</span></span><br><span class="line"><span class="comment">            // 我们一直想追求的是：所有的错误尽可能让编译器找出来，所有的错误越早发现越好！</span></span><br><span class="line"><span class="comment">            return 10;</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种设计不错。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思考：以上的这个方法设计没毛病，挺好，返回true和false表示两种情况，</span></span><br><span class="line"><span class="comment">    但是在以后的开发中，有可能遇到一个方法的执行结果可能包括三种情况，</span></span><br><span class="line"><span class="comment">    四种情况，五种情况不等，但是每一个都是可以数清楚的，一枚一枚都是可以</span></span><br><span class="line"><span class="comment">    列举出来的。这个布尔类型就无法满足需求了。此时需要使用java语言中的</span></span><br><span class="line"><span class="comment">    枚举类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用枚举的方式改造程序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">    1、枚举是一种引用数据类型</span></span><br><span class="line"><span class="comment">    2、枚举类型怎么定义，语法是？</span></span><br><span class="line"><span class="comment">        enum 枚举类型名&#123;</span></span><br><span class="line"><span class="comment">            枚举值1,枚举值2</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    3、结果只有两种情况的，建议使用布尔类型。</span></span><br><span class="line"><span class="comment">    结果超过两种并且还是可以一枚一枚列举出来的，建议使用枚举类型。</span></span><br><span class="line"><span class="comment">        例如：颜色、四季、星期等都可以使用枚举类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(r == Result.SUCCESS ? <span class="string">&quot;计算成功&quot;</span> : <span class="string">&quot;计算失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两个int类型数据的商。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b int数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result.SUCCESS表示成功，Result.FAIL表示失败！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">            <span class="keyword">return</span> Result.SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举：一枚一枚可以列举出来的，才建议使用枚举类型。</span></span><br><span class="line"><span class="comment">// 枚举编译之后也是生成class文件。</span></span><br><span class="line"><span class="comment">// 枚举也是一种引用数据类型。</span></span><br><span class="line"><span class="comment">// 枚举中的每一个值可以看做是常量。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="comment">// SUCCESS 是枚举Result类型中的一个值</span></span><br><span class="line">    <span class="comment">// FAIL 是枚举Result类型中的一个值</span></span><br><span class="line">    <span class="comment">// 枚举中的每一个值，可以看做是“常量”</span></span><br><span class="line">    SUCCESS, FAIL</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>枚举是一种引用数据类型。</li>
<li>枚举编译之后也是class文件。</li>
<li>枚举类型怎么定义？</li>
<li>enum 枚举类型名{</li>
</ul>
<p>枚举值,枚举值2,枚举值3<br>}</p>
<ul>
<li>当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来</li>
</ul>
<p>的时候，建议返回值类型设计为枚举类型。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h2><p>什么是集合？有什么用？</p>
<ul>
<li>数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。</li>
</ul>
<p>集合为什么说在开发中使用较多？</p>
<ul>
<li>集合是一个容器，是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来。</li>
</ul>
<p>注意：</p>
<ul>
<li>集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）</li>
<li>集合在java中本身是一个容器，是一个对象。</li>
<li>集合中任何时候存储的都是“引用”。</li>
</ul>
<p>在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如：数组、二叉树、链表、哈希表…以上这些都是常见的数据结构。</p>
<p>new ArrayList(); 创建一个集合，底层是数组。<br>new LinkedList(); 创建一个集合对象，底层是链表。<br>new TreeSet(); 创建一个集合对象，底层是二叉树。<br>…..</p>
<p>集合在java JDK中哪个包下？</p>
<ul>
<li>java.util.*;所有的集合类和集合接口都在java.util包下。</li>
</ul>
<p>为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！</p>
<p>在java中集合分为两大类：</p>
<ul>
<li>一类是单个方式存储元素：单个方式存储元素，这一类集合中超级父接口：java.util.Collection;</li>
<li>一类是以键值对儿的方式存储元素以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;</li>
</ul>
<p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553406932.png" title="1595553406932" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553406932.png" alt="1595553406932"></a></p>
<p><a href="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553421651.png" title="1595553421651" class="gallery-item" style="box-shadow: none;"> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553421651.png" alt="1595553421651"></a></p>
<p>重点：</p>
<ul>
<li>第一个重点：把集合继承结构图背会。</li>
<li>第二个重点：把Collection接口中常用方法测试几遍。</li>
<li>第三个重点：把迭代器弄明白。</li>
<li>第四个重点：Collection接口中的remove方法和contains方法底层都会调用equals，<br>这个弄明白。</li>
</ul>
<p>总结：所有实现类</p>
<ul>
<li>ArrayList 底层是数组</li>
<li>LinkedList 底层是双向链表</li>
<li>Vector 底层是数组，线程安全，效率比较低，使用较少</li>
<li>HashSet 底层是HashMap，放在HashSet集合中的元素等同于放到HashMap集合key部分了</li>
<li>TreeSet 底层是TreeMap，放在TreeSet集合中的元素等同于放到TreeMap集合的key部分了</li>
<li>HashMap 底层是哈希表</li>
<li>HashTable 底层也是哈希表，不过是线程安全的，效率较低，使用较少</li>
<li>Properties 是线程安全的，并且k和v只能存储字符串String</li>
<li>TreeMap 底层是二叉树。TreeMap集合的key可以自动按照大小顺序排序</li>
</ul>
<p>List 集合存储元素特点</p>
<ul>
<li>有序可重复</li>
<li>有序：存进去的顺序和取出得到顺序相同，每一个元素都有下标</li>
<li>可重复：存进去1， 可以再存储一个1</li>
</ul>
<p>Set(Map) 集合存储元素特点</p>
<ul>
<li>无序不可重复</li>
<li>无序：存进去的顺序和去除的顺序不一定相同，另外Set集合中没有下标</li>
<li>不可重复：存进去1，不能再存储1了</li>
</ul>
<p>SortedSet（SortedMap） 集合存储元素特点</p>
<ul>
<li>无序不可重复但是可以排序</li>
<li>可排序：可以按照大小顺序排列</li>
</ul>
<p>Map集合的Key就是一个Set集合，往Set中放数据就相当于放到了map的key部分</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>关于java.util.Collection接口中常用的方法。</p>
<p>Collection中能存放什么元素？</p>
<ul>
<li>没有使用“泛型”之前，Collection中可以存储Object的所有子类型，且<strong>可以不同</strong>，因为存的是地址</li>
<li>使用了“泛型”之后，Collection中只能存储某个具体的类型。</li>
<li>Collection中什么都能存只要是Object的子类型就行。</li>
<li>集合中不能直接存储基本数据类型,也不能存java对象，只是存储java对象的内存地址。</li>
</ul>
<p>Collection中的常用方法</p>
<ul>
<li>boolean add(Object e) 向集合中添加元素(自动装箱)</li>
<li>int size()  获取集合中元素的个数</li>
<li>void clear() 清空集合</li>
<li>boolean contains(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false</li>
<li>boolean remove(Object o) 删除集合中的某个元素。</li>
<li>boolean isEmpty()  判断该集合中元素的个数是否为0</li>
<li>Object[] toArray()  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。</span></span><br><span class="line">        <span class="comment">// 在Map集合中不能用。在所有的Collection以及子类中使用。</span></span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。</span></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">// 对集合Collection进行遍历/迭代</span></span><br><span class="line">        <span class="comment">// 第一步：获取集合对象的迭代器对象Iterator</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">        <span class="comment">// 第二步：通过以上获取的迭代器对象开始迭代/遍历集合。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            以下两个方法是迭代器对象Iterator中的方法：</span></span><br><span class="line"><span class="comment">                boolean hasNext()如果仍有元素可以迭代，则返回 true。</span></span><br><span class="line"><span class="comment">                Object next() 返回迭代的下一个元素。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//等价于：</span></span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            System.out.println(it2.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一直取，不判断，会出现异常：java.util.NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><p>深入Collection集合的contains方法：</p>
<p>boolean contains(Object o)<br>判断集合中是否包含某个对象o<br>如果包含返回true， 如果不包含返回false。</p>
<p>contains方法是用来判断集合中是否包含某个元素的方法，那么它在底层是怎么判断集合中是否包含某个元素的呢？<br>调用了equals方法进行比对。equals方法返回true，就表示包含这个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合中存储元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// s1 = 0x1111</span></span><br><span class="line">        c.add(s1); <span class="comment">// 放进去了一个&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>); <span class="comment">// s2 = 0x2222</span></span><br><span class="line">        c.add(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合中元素的个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;元素的个数是：&quot;</span> + c.size()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建的对象String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// x = 0x5555</span></span><br><span class="line">        <span class="comment">// c集合中是否包含x？结果猜测一下是true还是false？</span></span><br><span class="line">        System.out.println(c.contains(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含，因为底层调用了String的equals方法，比较的是内容，内容一样所以是true</span></span><br><span class="line"><span class="comment">//和字符串常量值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论：<strong>放在集合中的元素一定要重写equals方法</strong></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><ul>
<li>当集合的结构发生改变时，迭代器必须重新获取，如果还是用以前老的迭代器，会出现异常：java.util.ConcurrentModificationException</li>
<li>在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：c.remove(o); 迭代过程中不能这样。会出现：java.util.ConcurrentModificationException</li>
<li>在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素不要使用集合自带的remove方法删除元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。</span></span><br><span class="line">        <span class="comment">// 一定要注意：集合结构只要发生改变，迭代器必须重新获取。</span></span><br><span class="line">        <span class="comment">// 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        c.add(<span class="number">1</span>); <span class="comment">// Integer类型</span></span><br><span class="line">        c.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        <span class="comment">//Iterator it = c.iterator();</span></span><br><span class="line">        <span class="comment">/*while(it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            // 编写代码时next()方法返回值类型必须是Object。</span></span><br><span class="line"><span class="comment">            // Integer i = it.next();</span></span><br><span class="line"><span class="comment">            Object obj = it.next();</span></span><br><span class="line"><span class="comment">            System.out.println(obj);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c2.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it2</span> <span class="operator">=</span> c2.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> it2.next();</span><br><span class="line">            <span class="comment">// 删除元素</span></span><br><span class="line">            <span class="comment">// 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器</span></span><br><span class="line">            <span class="comment">// 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException</span></span><br><span class="line">            <span class="comment">// 出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）</span></span><br><span class="line">            <span class="comment">//c2.remove(o); // 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）</span></span><br><span class="line">            <span class="comment">// 使用迭代器来删除可以吗？</span></span><br><span class="line">            <span class="comment">// 迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。</span></span><br><span class="line">            it2.remove(); <span class="comment">// 删除的一定是迭代器指向的当前元素。</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(c2.size()); <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List集合存储元素特点：有序可重复</p>
<ul>
<li>有序：List集合中的元素有下标。</li>
<li>从0开始，以1递增。</li>
<li>可重复：存储一个1，还可以再存储1.</li>
</ul>
<p>List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法：<br>以下只列出List接口特有的常用的方法：</p>
<ul>
<li>void add(int index, Object element)</li>
<li>Object set(int index, Object element)</li>
<li>Object get(int index)</li>
<li>int indexOf(Object o)</li>
<li>int lastIndexOf(Object o)</li>
<li>Object remove(int index)</li>
</ul>
<p>以上几个方法不需要死记硬背，可以自己编写代码测试一下，理解一下, 以后开发的时候，还是要翻阅帮助文档。</p>
<p>迭代器迭代元素的过程中不能使用集合对象的remove方法删除元素，要使用迭代器Iterator的remove方法来删除元素，防止出现异常： ConcurrentModificationException</p>
<p>怎么得到一个线程安全的List：<br>Collections.synchronizedList(list);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建List类型的集合。</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        myList.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// 默认都是向集合末尾添加元素。</span></span><br><span class="line">        myList.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在列表的指定位置插入指定元素（第一个参数是下标）</span></span><br><span class="line">        <span class="comment">// 这个方法使用不多，因为对于ArrayList集合来说效率比较低。</span></span><br><span class="line">        myList.add(<span class="number">1</span>, <span class="string">&quot;KING&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> myList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">elt</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(elt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据下标获取元素</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">firstObj</span> <span class="operator">=</span> myList.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(firstObj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为有下标，所以List集合有自己比较特殊的遍历方式</span></span><br><span class="line">        <span class="comment">// 通过下标遍历。【List集合特有的方式，Set没有。】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.size(); i++)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myList.get(i);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定对象第一次出现处的索引。</span></span><br><span class="line">        System.out.println(myList.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定对象最后一次出现处的索引。</span></span><br><span class="line">        System.out.println(myList.lastIndexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为0的元素</span></span><br><span class="line">        myList.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指定位置的元素</span></span><br><span class="line">        myList.set(<span class="number">2</span>, <span class="string">&quot;Soft&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.size(); i++)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myList.get(i);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li>默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）扩容为原容量1.5倍。</li>
<li>集合底层是一个Object[]数组。</li>
<li>构造方法：<ul>
<li>new ArrayList();</li>
<li>new ArrayList(20);</li>
</ul>
</li>
<li>ArrayList集合的扩容：        增长到原容量的1.5倍。</li>
<li>ArrayList集合底层是数组，怎么优化？<ul>
<li>尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。</li>
</ul>
</li>
<li>数组优点：<ul>
<li>检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）</li>
</ul>
</li>
<li>数组缺点：<ul>
<li>随机增删元素效率比较低。</li>
<li>另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）</li>
</ul>
</li>
<li>向数组末尾添加元素，效率很高，不受影响。</li>
<li>面试官经常问的一个问题？ 这么多的集合中，你用哪个集合最多？<ul>
<li>答：ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们检索&#x2F;查找某个元素的操作比较多。</li>
</ul>
</li>
<li>ArrayList集合是非线程安全的。（不是线程安全的集合。）</li>
<li>ArrayList之所以检索效率比较高，不是单纯因为下标的原因。是因为底层数组发挥的作用。</li>
<li>LinkedList集合照样有下标，但是检索&#x2F;查找某个元素的时候效率比较低，因为只能从头节点开始一个一个遍历。</li>
</ul>
<p>怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？<br>使用集合工具类：java.util.Collections;</p>
<p>java.util.Collection 是集合接口。</p>
<p>java.util.Collections 是集合工具类。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>链表的优点：<br>    由于链表上的元素在空间存储上内存地址不连续。所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。在以后的开发中，如果遇到<strong>随机增删集合中元素</strong>的业务比较多时，建议使用LinkedList。</p>
<p>链表的缺点：<br>    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索&#x2F;查找的效率较低。</p>
<ul>
<li>LinkedList集合底层也是有下标的。</li>
<li>LinkedList集合有初始化容量吗？没有。</li>
<li>最初这个链表中没有任何元素。first和last引用都是null。</li>
</ul>
<p>ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）<br>LinkedList：把随机增删发挥到极致。<br>加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector初始化容量是10.</p>
<p>扩容为原容量的2倍。</p>
<p>底层是数组。</p>
<p>Vector底层是线程安全的。</p>
<p>Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h4><ul>
<li>JDK5.0之后推出的新特性：泛型</li>
<li>泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）</li>
<li>使用了泛型好处是什么？<ul>
<li>第一：集合中存储的元素类型统一了。</li>
<li>第二：从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”！</li>
</ul>
</li>
<li>泛型的缺点是什么？<ul>
<li>导致集合中存储的元素缺乏多样性！</li>
<li>大多数业务中，集合中元素的类型还是统一的。所以这种泛型特性被大家所认可。</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。</span></span><br><span class="line">        <span class="comment">// 用泛型来指定集合中存储的数据类型。</span></span><br><span class="line">        List&lt;Animal&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定List集合中只能存储Animal，那么存储String就编译报错了。</span></span><br><span class="line">        <span class="comment">// 这样用了泛型之后，集合中元素的数据类型更加统一了。</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        myList.add(c); myList.add(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        <span class="comment">// 这个表示迭代器迭代的是Animal类型。</span></span><br><span class="line">        Iterator&lt;Animal&gt; it = myList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 使用泛型之后，每一次迭代返回的数据都是Animal类型。</span></span><br><span class="line">            <span class="comment">//Animal a = it.next();</span></span><br><span class="line">            <span class="comment">// 这里不需要进行强制类型转换了。直接调用。</span></span><br><span class="line">            <span class="comment">//a.move();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用子类型特有的方法还是需要向下转换的！</span></span><br><span class="line">            <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">x</span> <span class="operator">=</span> (Cat)a;</span><br><span class="line">                x.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">                <span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span> (Bird)a;</span><br><span class="line">                y.fly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 父类自带方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="钻石表达式（自动类型推断）"><a href="#钻石表达式（自动类型推断）" class="headerlink" title="钻石表达式（自动类型推断）"></a>钻石表达式（自动类型推断）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ArrayList&lt;这里的类型会自动推断&gt;()，前提是JDK8之后才允许。</span></span><br><span class="line">        <span class="comment">// 自动类型推断，钻石表达式！</span></span><br><span class="line">        List&lt;Animal&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        myList.add(<span class="keyword">new</span> <span class="title class_">Animal</span>());</span><br><span class="line">        myList.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">        myList.add(<span class="keyword">new</span> <span class="title class_">Bird</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Animal&gt; it = myList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> it.next();</span><br><span class="line">            a.move();</span><br><span class="line">            <span class="comment">//调用子类中的方法还是要转型</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it2 = strList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 直接通过迭代器获取了String类型的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it2.next();</span><br><span class="line">            <span class="comment">// 直接调用String类的substring方法截取字符串。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newString</span> <span class="operator">=</span> s.substring(<span class="number">7</span>);</span><br><span class="line">            System.out.println(newString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h4><p>&#x2F;&#x2F;不太明白这个</p>
<p>自定义泛型可以吗？可以</p>
<ul>
<li>自定义泛型的时候，&lt;&gt; 尖括号中的是一个标识符，随便写。</li>
<li>java源代码中经常出现的是： <E>和<T></li>
<li>E是Element单词首字母。</li>
<li>T是Type单词首字母。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest03</span>&lt;标识符随便写&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(标识符随便写 o)</span>&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new对象的时候指定了泛型是：String类型</span></span><br><span class="line">        GenericTest03&lt;String&gt; gt = <span class="keyword">new</span> <span class="title class_">GenericTest03</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        gt.doSome(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =============================================================</span></span><br><span class="line">        GenericTest03&lt;Integer&gt; gt2 = <span class="keyword">new</span> <span class="title class_">GenericTest03</span>&lt;&gt;();</span><br><span class="line">        gt2.doSome(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型不匹配</span></span><br><span class="line">        <span class="comment">//gt2.doSome(&quot;abc&quot;);</span></span><br><span class="line"></span><br><span class="line">        MyIterator&lt;String&gt; mi = <span class="keyword">new</span> <span class="title class_">MyIterator</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> mi.get();</span><br><span class="line"></span><br><span class="line">        MyIterator&lt;Animal&gt; mi2 = <span class="keyword">new</span> <span class="title class_">MyIterator</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> mi2.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用泛型就是Object类型。</span></span><br><span class="line">        <span class="comment">/*GenericTest03 gt3 = new GenericTest03();</span></span><br><span class="line"><span class="comment">        gt3.doSome(new Object());*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><p>Map和Collection没有继承关系。</p>
</li>
<li><p>Map集合以key和value的方式存储数据：键值对</p>
<ul>
<li>key和value都是引用数据类型。</li>
<li>key和value都是存储对象的内存地址。</li>
<li>key起到主导的地位，value是key的一个附属品。</li>
</ul>
</li>
<li><p>Map接口中常用方法：</p>
<ul>
<li>V put(K key, V value) 向Map集合中添加键值对</li>
<li>V get(Object key) 通过key获取value</li>
<li>void clear()    清空Map集合</li>
<li>boolean containsKey(Object key) 判断Map中是否包含某个key</li>
<li>boolean containsValue(Object value) 判断Map中是否包含某个value</li>
<li>boolean isEmpty()   判断Map集合中元素个数是否为0</li>
<li>V remove(Object key) 通过key删除键值对</li>
<li>int size() 获取Map集合中键值对的个数。</li>
<li>Collection<V> values() 获取Map集合中所有的value，返回一个Collection</li>
<li>Set<K> keySet() 获取Map集合所有的key（所有的键是一个set集合）</li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()  将Map集合转换成Set集合</li>
</ul>
<h2 id="假设现在有一个Map集合，如下所示：-map1集合对象-key-value"><a href="#假设现在有一个Map集合，如下所示：-map1集合对象-key-value" class="headerlink" title="  假设现在有一个Map集合，如下所示：  map1集合对象  key             value"></a>  假设现在有一个Map集合，如下所示：<br>  map1集合对象<br>  key             value</h2><p>  1               zhangsan<br>  2               lisi<br>  3               wangwu<br>  4               zhaoliu</p>
</li>
</ul>
<p>Set set &#x3D; map1.entrySet();<br>set集合对象<br>1&#x3D;zhangsan 【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry&lt;K,V&gt;】<br>2&#x3D;lisi【Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】<br>3&#x3D;wangwu<br>4&#x3D;zhaoliu —&gt; 这个东西是个什么？ Map.Entry</p>
<h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 向Map集合中添加键值对</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>); <span class="comment">// 1在这里进行了自动装箱。</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 获取键值对的数量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span> + map.size());</span><br><span class="line">        <span class="comment">// 通过key删除key-value</span></span><br><span class="line">        map.remove(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 判断是否包含某个key</span></span><br><span class="line">        <span class="comment">// contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>))); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 判断是否包含某个value</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wangwu&quot;</span>))); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的value</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(String s : values)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空map集合</span></span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span> + map.size());</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        System.out.println(map.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种方式：获取所有的key，通过遍历key，来遍历value</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历Map集合</span></span><br><span class="line">        <span class="comment">// 获取所有的key，所有的key是一个Set集合</span></span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历key，通过key获取value</span></span><br><span class="line">        <span class="comment">// 迭代器可以</span></span><br><span class="line">        <span class="comment">/*Iterator&lt;Integer&gt; it = keys.iterator();</span></span><br><span class="line"><span class="comment">        while(it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            // 取出其中一个key</span></span><br><span class="line"><span class="comment">            Integer key = it.next();</span></span><br><span class="line"><span class="comment">            // 通过key获取value</span></span><br><span class="line"><span class="comment">            String value = map.get(key);</span></span><br><span class="line"><span class="comment">            System.out.println(key + &quot;=&quot; + value);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// foreach也可以</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key : keys)&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方式：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span></span><br><span class="line">        <span class="comment">// 以上这个方法是把Map集合直接全部转换成Set集合。</span></span><br><span class="line">        <span class="comment">// Set集合中元素的类型是：Map.Entry</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="comment">// 遍历Set集合，每一次取出一个Node</span></span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        <span class="comment">/*Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();</span></span><br><span class="line"><span class="comment">        while(it2.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            Map.Entry&lt;Integer,String&gt; node = it2.next();</span></span><br><span class="line"><span class="comment">            Integer key = node.getKey();</span></span><br><span class="line"><span class="comment">            String value = node.getValue();</span></span><br><span class="line"><span class="comment">            System.out.println(key + &quot;=&quot; + value);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="comment">// 这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。</span></span><br><span class="line">        <span class="comment">// 这种方式比较适合于大数据量。</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; node : set)&#123;</span><br><span class="line">            System.out.println(node.getKey() + <span class="string">&quot;---&gt;&quot;</span> + node.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h3><p>HashMap集合：</p>
<ul>
<li>HashMap集合底层是哈希表&#x2F;散列表的数据结构。</li>
<li>哈希表是一个怎样的数据结构呢？<ul>
<li>哈希表是一个数组和单向链表的结合体。</li>
<li>数组：在查询方面效率很高，随机增删方面效率很低。</li>
<li>单向链表：在随机增删方面效率较高，在查询方面效率很低。</li>
<li>哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。”中庸”</li>
</ul>
</li>
<li>HashMap集合底层的源代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&#123;</span><br><span class="line">    <span class="comment">// HashMap底层实际上就是一个数组。（一维数组）</span></span><br><span class="line">    Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 静态的内部类HashMap.Node</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 存储到Map集合中的那个key</span></span><br><span class="line">        V value; <span class="comment">// 存储到Map集合中的那个value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 下一个节点的内存地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>哈希表&#x2F;散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）</li>
<li>最主要掌握的是：<ul>
<li>map.put(k,v)</li>
<li>v &#x3D; map.get(k)</li>
<li>以上这两个方法的实现原理，是必须掌握的。</li>
</ul>
</li>
<li>HashMap集合的key部分特点：<ul>
<li>无序，不可重复。</li>
<li>为什么无序？ 因为不一定挂到哪个单向链表上。</li>
<li>不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。</li>
<li>放在HashMap集合key部分的元素其实就是放到HashSet集合中了。</li>
<li>所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。</li>
</ul>
</li>
<li>哈希表HashMap使用不当时无法发挥性能！</li>
<li>假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们称为：散列分布不均匀。<ul>
<li>什么是散列分布均匀？</li>
<li>假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。</li>
<li>假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？</li>
<li>不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。散列分布均匀需要你重写hashCode()方法时有一定的技巧。</li>
</ul>
</li>
<li>重点：放在HashMap集合key部分的元素,以及放在HashSet集合中的元素,需要同时重写hashCode和equals方法.</li>
<li>HashMap集合的默认初始化容量是16，默认加载因子是0.75, 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。</li>
<li>重点，记住：HashMap集合初始化容量<strong>必须是2的倍数</strong>，这也是官方推荐的，这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。</li>
</ul>
<p>这里有个图</p>
<p>测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试HashMap集合key部分的元素特点</span></span><br><span class="line">        <span class="comment">// Integer是key，它的hashCode和equals都重写了。</span></span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1111</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="number">6666</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7777</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2222</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2222</span>, <span class="string">&quot;king&quot;</span>); <span class="comment">//key重复的时候value会自动覆盖。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : set)&#123;</span><br><span class="line">            <span class="comment">// 验证结果：HashMap集合key部分元素：无序不可重复。</span></span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="必须重写hashcode和equals"><a href="#必须重写hashcode和equals" class="headerlink" title="必须重写hashcode和equals"></a>必须重写hashcode和equals</h4><ul>
<li><p>向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！<br>equals方法有可能调用，也有可能不调用。</p>
<ul>
<li>拿put(k,v)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。</li>
<li>拿get(k)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。</li>
</ul>
</li>
<li><p>注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。</p>
<ul>
<li>并且equals方法返回如果是true，hashCode()方法返回的值必须一样。equals方法返回true表示两个对象相同，在同一个单向链表上比较。那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。所以hashCode()方法的返回值也应该相同。</li>
</ul>
</li>
<li><p>hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。</p>
</li>
<li><p>对于哈希表数据结构来说：如果o1和o2的hash值相同，一定是放到同一个单向链表上。 如果o1和o2的hash值不同，但由于哈希算法执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”。</p>
</li>
<li><p>HashMap集合key部分允许null吗？  允许  但是要注意：HashMap集合的key null值只能有一个。</p>
</li>
<li><p>终极结论：放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要<strong>同时重写hashCode方法和equals方法</strong>。</p>
</li>
</ul>
<h4 id="HashMap和Hashtable的区别。"><a href="#HashMap和Hashtable的区别。" class="headerlink" title="HashMap和Hashtable的区别。"></a>HashMap和Hashtable的区别。</h4><p>Hashtable和HashMap一样，底层都是哈希表数据结构。</p>
<p>HashMap：</p>
<ul>
<li>初始化容量16，扩容2倍。非线程安全。key和value可以为null。</li>
<li>HashMap集合的key和value都是可以为null的。</li>
</ul>
<p>Hashtable：</p>
<ul>
<li>初始化容量11，默认加载因子是：0.75f，扩容2倍+1。线程安全。key和value都不能是null。</li>
<li>Hashtable的key和value都是不能为null的。</li>
</ul>
<p>Hashtable方法都带有synchronized：线程安全的。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。</p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>目前只需要掌握Properties属性类对象的相关方法即可。<br>Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。<br>Properties被称为属性类对象。<br>Properties是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要掌握Properties的两个方法，一个存，一个取。</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;driver&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-TreeSet"><a href="#TreeMap-TreeSet" class="headerlink" title="TreeMap&#x2F;TreeSet"></a>TreeMap&#x2F;TreeSet</h3><p>TreeSet集合存储元素特点：</p>
<ul>
<li>无序不可重复的，但是存储的元素可以自动按照大小顺序排序！称为：可排序集合。</li>
<li>无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</li>
<li>TreeSet集合底层实际上是一个TreeMap</li>
<li>TreeMap集合底层是一个二叉树。</li>
<li>放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</li>
<li>无法对自定义类型排序castException</li>
<li>可以不写equals方法，因为底层调用了comparable方法进行比较了</li>
</ul>
<h4 id="自定义排序规则"><a href="#自定义排序规则" class="headerlink" title="自定义排序规则"></a>自定义排序规则</h4><p>TreeMap的key或者TreeSet集合中的元素要想排序，有两种实现方式：</p>
<ul>
<li>第一种：实现java.lang.Comparable接口。</li>
<li>第二种：单独编写一个比较器Comparator接口。</li>
</ul>
<h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">32</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 创建TreeSet集合</span></span><br><span class="line">        TreeSet&lt;Customer&gt; customers = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        customers.add(c1);</span><br><span class="line">        customers.add(c2);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Customer c : customers)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放在TreeSet集合中的元素需要实现java.lang.Comparable接口。</span></span><br><span class="line"><span class="comment">// 并且实现compareTo方法。equals可以不写。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Customer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！</span></span><br><span class="line">    <span class="comment">// k.compareTo(t.key)</span></span><br><span class="line">    <span class="comment">// 拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;0 &lt;0 =0</span></span><br><span class="line">    <span class="comment">// 比较规则最终还是由程序员指定的：例如按照年龄升序。或者按照年龄降序。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Customer c)</span> &#123; <span class="comment">// c1.compareTo(c2);</span></span><br><span class="line">        <span class="keyword">return</span> c.age - <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Customer[age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">先按照年龄升序，如果年龄一样的再按照姓名升序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Vip v)</span> &#123;</span><br><span class="line">        <span class="comment">// 写排序规则，按照什么进行比较。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age == v.age)&#123;</span><br><span class="line">            <span class="comment">// 年龄相同时按照名字排序。</span></span><br><span class="line">            <span class="comment">// 姓名是String类型，可以直接比。调用compareTo来完成比较。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(v.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 年龄不一样</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - v.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>使用比较器的方式</p>
<p>最终的结论：放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式<br>    - 第一种：放在集合中的元素实现java.lang.Comparable接口。<br>    - 第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。</p>
<p>Comparable和Comparator怎么选择呢？</p>
<ul>
<li><p>当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。</p>
</li>
<li><p>如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</p>
</li>
<li><p>Comparator接口的设计符合OCP原则。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建TreeSet集合的时候，需要使用这个比较器。</span></span><br><span class="line">        <span class="comment">// TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;();//这样不行，没有通过构造方法传递一个比较器进去。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给构造方法传递一个比较器。</span></span><br><span class="line">        <span class="comment">//TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）</span></span><br><span class="line">        TreeSet&lt;WuGui&gt; wuGuis = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;WuGui&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(WuGui o1, WuGui o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">1000</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">800</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">810</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(WuGui wuGui : wuGuis)&#123;</span><br><span class="line">            System.out.println(wuGui);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乌龟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuGui</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WuGui</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小乌龟[&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独在这里编写一个比较器</span></span><br><span class="line"><span class="comment">//比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuGuiComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;WuGui&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(WuGui o1, WuGui o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定比较规则</span></span><br><span class="line">        <span class="comment">// 按照年龄排序</span></span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h4><p>图片</p>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>synchronizedList方法</p>
<p>sort方法（要求集合中元素实现Comparable接口。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Collection 集合接口</span></span><br><span class="line"><span class="comment">java.util.Collections 集合工具类，方便集合的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ArrayList集合不是线程安全的。</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变成线程安全的</span></span><br><span class="line">        Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        list.add(<span class="string">&quot;abf&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;abx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;WuGui2&gt; wuGuis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui2</span>(<span class="number">1000</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui2</span>(<span class="number">8000</span>));</span><br><span class="line">        <span class="comment">// 注意：对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口。</span></span><br><span class="line">        Collections.sort(wuGuis);</span><br><span class="line">        <span class="keyword">for</span>(WuGui2 wg : wuGuis)&#123;</span><br><span class="line">            System.out.println(wg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对Set集合怎么排序呢？</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;kingsoft&quot;</span>);</span><br><span class="line">        <span class="comment">// 将Set集合转换成List集合</span></span><br><span class="line">        List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">        Collections.sort(myList);</span><br><span class="line">        <span class="keyword">for</span>(String s : myList) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这种方式也可以排序。</span></span><br><span class="line">        <span class="comment">//Collections.sort(list集合, 比较器对象);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuGui2</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;WuGui2&gt;&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WuGui2</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(WuGui2 o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WuGui2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、什么是异常，java提供异常处理机制有什么用？</span></span><br><span class="line"><span class="comment">    以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常</span></span><br><span class="line"><span class="comment">    java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，</span></span><br><span class="line"><span class="comment">    java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对</span></span><br><span class="line"><span class="comment">    程序进行修改，让程序更加的健壮。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    什么是异常：程序执行过程中的不正常情况。</span></span><br><span class="line"><span class="comment">    异常的作用：增强程序的健壮性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、以下程序执行控制台出现了：</span></span><br><span class="line"><span class="comment">    Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">	    at com.bjpowernode.javase.exception.ExceptionTest01.main(ExceptionTest01.java:14)</span></span><br><span class="line"><span class="comment">	这个信息被我们称为：异常信息。这个信息是JVM打印的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException(&quot;/ by zero&quot;);</span></span><br><span class="line">        <span class="comment">// 并且JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;/&quot;</span> + b + <span class="string">&quot;=&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处运行也会创建一个：ArithmeticException类型的异常对象。</span></span><br><span class="line">        <span class="comment">//System.out.println(100 / 0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我观察到异常信息之后，对程序进行修改，更加健壮。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java语言中异常是以什么形式存在的呢？</span></span><br><span class="line"><span class="comment">    1、异常在java中以类的形式存在，每一个异常类都可以创建异常对象。</span></span><br><span class="line"><span class="comment">    2、异常对应的现实生活中是怎样的？</span></span><br><span class="line"><span class="comment">        火灾(异常类)：</span></span><br><span class="line"><span class="comment">            2008年8月8日,小明家着火了（异常对象）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        类是：模板。</span></span><br><span class="line"><span class="comment">        对象是：实际存在的个体。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        钱包丢了（异常类）：</span></span><br><span class="line"><span class="comment">            2008年1月8日，小明的钱包丢了（异常对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过“异常类”创建“异常对象”</span></span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">npe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;空指针异常发生了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java.lang.NullPointerException: 空指针异常发生了！</span></span><br><span class="line">        System.out.println(npe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        程序执行到此处发生了ArithmeticException异常，底层new了一个ArithmeticException异常对象，然后抛出了，由于是main方法调用了100 / 0，所以这个异常ArithmeticException抛给了main方法，main方法没有处理，将这个异常自动抛给了JVM。JVM最终终止程序的执行。</span></span><br><span class="line"><span class="comment">        ArithmeticException 继承 RuntimeException，属于运行时异常。</span></span><br><span class="line"><span class="comment">        在编写程序阶段不需要对这种异常进行预先的处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        System.out.println(<span class="number">100</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这里的HelloWorld没有输出，没有执行。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以下代码报错的原因是什么？</span></span><br><span class="line"><span class="comment">    因为doSome()方法声明位置上使用了：throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">    而ClassNotFoundException是编译时异常。必须编写代码时处理，没有处理</span></span><br><span class="line"><span class="comment">    编译器报错。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// main方法中调用doSome()方法</span></span><br><span class="line">        <span class="comment">// 因为doSome()方法声明位置上有：throws ClassNotFoundException</span></span><br><span class="line">        <span class="comment">// 我们在调用doSome()方法的时候必须对这种异常进行预先的处理。</span></span><br><span class="line">        <span class="comment">// 如果不处理，编译器就报错。</span></span><br><span class="line">        <span class="comment">//编译器报错信息： Unhandled exception: java.lang.ClassNotFoundException</span></span><br><span class="line">        <span class="comment">//doSome();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">     * 这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常。</span></span><br><span class="line"><span class="comment">     * 叫做类没找到异常。这个异常直接父类是：Exception，所以ClassNotFoundException属于编译时异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>java中异常的作用是：增强程序健壮性。</li>
<li>java中异常以类和对象的形式存在。</li>
</ul>
<p>Object<br>Object下有Throwable（可抛出的）<br>Throwable下有两个分支：</p>
<ul>
<li>Error（不可处理，直接退出JVM）</li>
<li>Exception（可处理的）<ul>
<li>Exception下有两个分支：</li>
<li>Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</li>
<li>RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</li>
</ul>
</li>
</ul>
<p>编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</p>
<p>编译时异常因为什么而得名？<br>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。因为异常的发生就是new异常对象。<br>编译时异常和运行时异常的区别？编译时异常一般发生的概率比较高。<br>举个例子：<br>你看到外面下雨了，倾盆大雨的。你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。“拿一把伞”就是对“生病异常”发生之前的一种处理方式。</p>
<p>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</p>
<p>运行时异常一般发生的概率比较低。<br>举个例子：<br>小明走在大街上，可能会被天上的飞机轮子砸到。被飞机轮子砸到也算一种异常。但是这种异常发生概率较低。在出门之前你没必要提前对这种发生概率较低的异常进行预处理。如果你预处理这种异常，你将活的很累。</p>
<p>假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。</p>
<p>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？首先，如果这样的话，程序肯定是绝对的安全的。<br>但是程序员编写程序太累，代码到处都是处理异常的代码。</p>
<p>编译时异常还有其他名字：</p>
<ul>
<li>受检异常：CheckedException</li>
<li>受控异常<br>运行时异常还有其它名字：</li>
<li>未受检异常：UnCheckedException</li>
<li>非受控异常</li>
</ul>
<p>再次强调：所有异常都是发生在运行阶段的。</p>
<h3 id="怎样处理"><a href="#怎样处理" class="headerlink" title="怎样处理"></a>怎样处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest05</span> &#123;</span><br><span class="line">    <span class="comment">// 第一种处理方式：在方法声明的位置上继续使用：throws，来完成异常的继续上抛。抛给调用者。上抛类似于推卸责任。（继续把异常传递给调用者。）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		public static void main(String[] args) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">			doSome();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种处理方式：try..catch进行捕捉。</span></span><br><span class="line">    <span class="comment">// 捕捉等于把异常拦下了，异常真正的解决了。（调用者是不知道的。）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doSome();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">处理异常的第一种方式：</span></span><br><span class="line"><span class="comment">    在方法声明的位置上使用throws关键字抛出，谁调用我这个方法，我就抛给谁。抛给调用者来处理。</span></span><br><span class="line"><span class="comment">    这种处理异常的态度：上报。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">处理异常的第二种方式：</span></span><br><span class="line"><span class="comment">    使用try..catch语句对异常进行捕捉。这个异常不会上报，自己把这个事儿处理了。异常抛到此处为止，不再上抛了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">    只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。try..catch捕捉异常之后，后续代码可以执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？</span></span><br><span class="line"><span class="comment">    如果希望调用者来处理，选择throws上报。</span></span><br><span class="line"><span class="comment">    其它情况使用捕捉的方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest06</span> &#123;</span><br><span class="line">    <span class="comment">// 一般不建议在main方法上使用throws，因为这个异常如果真正的发生了，一定会抛给JVM。JVM只有终止。</span></span><br><span class="line">    <span class="comment">// 异常处理机制的作用就是增强程序的健壮性。怎么能做到，异常发生了也不影响程序的执行。所以</span></span><br><span class="line">    <span class="comment">// 一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续上抛了。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static void main(String[] args) throws FileNotFoundException &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;main begin&quot;);</span></span><br><span class="line"><span class="comment">        m1();</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;main over&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100 / 0这是算术异常，这个异常是运行时异常，你在编译阶段，可以处理，也可以不处理。编译器不管。</span></span><br><span class="line">        <span class="comment">//System.out.println(100 / 0); // 不处理编译器也不管</span></span><br><span class="line">        <span class="comment">// 你处理也可以。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// try尝试</span></span><br><span class="line">            m1();</span><br><span class="line">            <span class="comment">// 以上代码出现异常，直接进入catch语句块中执行。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e)&#123; <span class="comment">// catch后面的好像一个方法的形参。</span></span><br><span class="line">            <span class="comment">// 这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。</span></span><br><span class="line">            <span class="comment">// catch是捕捉异常之后走的分支。</span></span><br><span class="line">            <span class="comment">// 在catch分支中干什么？处理异常。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在，可能路径错误，也可能该文件被删除了！&quot;</span>);</span><br><span class="line">            System.out.println(e); <span class="comment">//java.io.FileNotFoundException: D:\course\01-课\学习方法.txt (系统找不到指定的路径。)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try..catch把异常抓住之后，这里的代码会继续执行。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 begin&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        <span class="comment">// 以上代码出异常，这里是无法执行的。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛别的不行，抛ClassCastException说明你还是没有对FileNotFoundException进行处理</span></span><br><span class="line">    <span class="comment">//private static void m2() throws ClassCastException&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛FileNotFoundException的父对象IOException，这样是可以的。因为IOException包括FileNotFoundException</span></span><br><span class="line">    <span class="comment">//private static void m2() throws IOException &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样也可以，因为Exception包括所有的异常。</span></span><br><span class="line">    <span class="comment">//private static void m2() throws Exception&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// throws后面也可以写多个异常，可以使用逗号隔开。</span></span><br><span class="line">    <span class="comment">//private static void m2() throws ClassCastException, FileNotFoundException&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 begin&quot;</span>);</span><br><span class="line">        <span class="comment">// 编译器报错原因是：m3()方法声明位置上有：throws FileNotFoundException</span></span><br><span class="line">        <span class="comment">// 我们在这里调用m3()没有对异常进行预处理，所以编译报错。</span></span><br><span class="line">        <span class="comment">// m3();</span></span><br><span class="line"></span><br><span class="line">        m3();</span><br><span class="line">        <span class="comment">// 以上如果出现异常，这里是无法执行的！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        编译报错的原因是什么？</span></span><br><span class="line"><span class="comment">            第一：这里调用了一个构造方法：FileInputStream(String name)</span></span><br><span class="line"><span class="comment">            第二：这个构造方法的声明位置上有：throws FileNotFoundException</span></span><br><span class="line"><span class="comment">            第三：通过类的继承结构看到：FileNotFoundException父类是IOException，IOException的父类是Exception，最终得知，FileNotFoundException是编译时异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            错误原因？编译时异常要求程序员编写程序阶段必须对它进行处理，不处理编译器就报错。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new FileInputStream(&quot;D:\\course\\01-开课\\学习方法.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种处理方式：在方法声明的位置上使用throws继续上抛。</span></span><br><span class="line">        <span class="comment">// 一个方法体当中的代码出现异常之后，如果上报的话，此方法结束。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\course\\01-课\\学习方法.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果以上代码出异常，这里会执行吗??不会！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。</p>
<p>第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。</p>
<p>举个例子：<br>我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，第一种方式：我把这件事告诉我的领导【异常上抛】第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】</p>
<p>张三 –&gt; 李四 —&gt; 王五 –&gt; CEO</p>
<p>思考：<br>异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</p>
<p>注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</p>
<h3 id="深入理解try-cache机制"><a href="#深入理解try-cache机制" class="headerlink" title="深入理解try cache机制"></a>深入理解try cache机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">深入try..catch</span></span><br><span class="line"><span class="comment">    1、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。</span></span><br><span class="line"><span class="comment">    2、catch可以写多个。建议catch的时候，精确的一个一个处理。这样有利于程序的调试。</span></span><br><span class="line"><span class="comment">    3、catch写多个的时候，从上到下，必须遵守从小到大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest07</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译报错。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;\JavaSE进阶-01-面向对象.pdf&quot;</span>);</span><br><span class="line">            <span class="comment">//读文件</span></span><br><span class="line">            fis.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读文件报错了！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK8的新特性！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;\JavaSE进阶-01-面向对象.pdf&quot;</span>);</span><br><span class="line">            <span class="comment">// 进行数学运算</span></span><br><span class="line">            System.out.println(<span class="number">100</span> / <span class="number">0</span>); <span class="comment">// 这个异常是运行时异常，编写程序时可以处理，也可以不处理。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException | ArithmeticException | NullPointerException e) &#123;</span><br><span class="line">			<span class="comment">//可以使用或符号进行声明异常类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在？数学异常？空指针异常？都有可能！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常对象的常用方法"><a href="#异常对象的常用方法" class="headerlink" title="异常对象的常用方法"></a>异常对象的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异常对象有两个非常重要的方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    获取异常简单的描述信息：</span></span><br><span class="line"><span class="comment">        String msg = exception.getMessage();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    打印异常追踪的堆栈信息：</span></span><br><span class="line"><span class="comment">        exception.printStackTrace();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里只是为了测试getMessage()方法和printStackTrace()方法。</span></span><br><span class="line">        <span class="comment">// 这里只是new了异常对象，但是没有将异常对象抛出。JVM会认为这是一个普通的java对象。</span></span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getMessage(); <span class="comment">//msg = 空指针异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        <span class="comment">// java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异常对象的两个方法：</span></span><br><span class="line"><span class="comment">    String msg = e.getMessage();</span></span><br><span class="line"><span class="comment">    e.printStackTrace(); // 一般都是使用这个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们以后查看异常的追踪信息，我们应该怎么看，可以快速的调试程序呢？</span></span><br><span class="line"><span class="comment">    异常信息追踪信息，从上往下一行一行看。</span></span><br><span class="line"><span class="comment">    但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的。)。</span></span><br><span class="line"><span class="comment">    主要的问题是出现在自己编写的代码上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 获取异常的简单描述信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">            System.out.println(msg); <span class="comment">//C:\jetns-agent.jar (系统找不到指定的文件。)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//在实际的开发中，建议使用这个。养成好习惯！</span></span><br><span class="line">            <span class="comment">// 这行代码要写上，不然出问题你也不知道！</span></span><br><span class="line">            <span class="comment">//打印异常堆栈追踪信息！</span></span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">				java.io.FileNotFoundException: C:\jetns-agent.jar (系统找不到指定的文件。)</span></span><br><span class="line"><span class="comment">                at com.bjpowernode.javase.exception.ExceptionTest09.m3(ExceptionTest09.java:31)</span></span><br><span class="line"><span class="comment">                at com.bjpowernode.javase.exception.ExceptionTest09.m2(ExceptionTest09.java:27)</span></span><br><span class="line"><span class="comment">                at com.bjpowernode.javase.exception.ExceptionTest09.m1(ExceptionTest09.java:23)</span></span><br><span class="line"><span class="comment">                at com.bjpowernode.javase.exception.ExceptionTest09.main(ExceptionTest09.java:14)</span></span><br><span class="line"><span class="comment">                因为31行出问题导致了27行</span></span><br><span class="line"><span class="comment">                27行出问题导致23行</span></span><br><span class="line"><span class="comment">                23行出问题导致14行。</span></span><br><span class="line"><span class="comment">                应该先查看31行的代码。31行是代码错误的根源。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机》</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\jetns-agent.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="finally子句的使用"><a href="#finally子句的使用" class="headerlink" title="finally子句的使用"></a>finally子句的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于try..catch中的finally子句：</span></span><br><span class="line"><span class="comment">    1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。（除非退出JVM）</span></span><br><span class="line"><span class="comment">        finally子句必须和try一起出现，不能单独编写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2、finally语句通常使用在哪些情况下呢？</span></span><br><span class="line"><span class="comment">        通常在finally语句块中完成资源的释放/关闭。</span></span><br><span class="line"><span class="comment">		因为finally中的代码比较有保障。</span></span><br><span class="line"><span class="comment">		即使try语句块中的代码出现异常，finally中代码也会正常执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明位置放到try外面。这样在finally中才能用。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\course\\02-JavaSE\\document\\JavaSE进阶讲义\\JavaSE进阶-01-面向对象.pdf&quot;</span>);</span><br><span class="line">            <span class="comment">// 开始读文件....</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 这里一定会出现空指针异常！</span></span><br><span class="line">            s.toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 流使用完需要关闭，因为流是占用资源的。</span></span><br><span class="line">            <span class="comment">// 即使以上程序出现异常，流也必须要关闭！</span></span><br><span class="line">            <span class="comment">// 放在这里有可能流关不了。</span></span><br><span class="line">            <span class="comment">//fis.close();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello Finally ！&quot;</span>);</span><br><span class="line">            <span class="comment">// 流的关闭放在这里比较保险。</span></span><br><span class="line">            <span class="comment">// finally中的代码是一定会执行的。</span></span><br><span class="line">            <span class="comment">// 即使try中出现了异常！</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123; <span class="comment">// 避免空指针异常！</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// close()方法有异常，采用捕捉的方式。</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">finally语句：</span></span><br><span class="line"><span class="comment">    放在finally语句块中的代码是一定会执行的（除非退出JVM）【再次强调！！！】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try和finally，没有catch可以吗？可以。</span></span><br><span class="line"><span class="comment">            try不能单独使用。</span></span><br><span class="line"><span class="comment">            try finally可以联合使用。</span></span><br><span class="line"><span class="comment">        以下代码的执行顺序：</span></span><br><span class="line"><span class="comment">            先执行try...</span></span><br><span class="line"><span class="comment">            再执行finally...</span></span><br><span class="line"><span class="comment">            最后执行 return （return语句只要执行方法必然结束。）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finally中的语句会执行。能执行到。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里不能写语句，因为这个代码是无法执行到的。</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">            <span class="comment">// 退出JVM</span></span><br><span class="line">            System.exit(<span class="number">0</span>); <span class="comment">// 退出JVM之后，finally语句中的代码就不执行了！</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------面试题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【面试题】【特殊情况】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> m();</span><br><span class="line">        System.out.println(result); <span class="comment">//100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：</span></span><br><span class="line"><span class="comment">        java中有一条这样的规则：</span></span><br><span class="line"><span class="comment">            方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）</span></span><br><span class="line"><span class="comment">        java中还有一条语法规则：</span></span><br><span class="line"><span class="comment">            return语句一旦执行，整个方法必须结束（亘古不变的语法！）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100</span></span><br><span class="line">            <span class="comment">// return语句还必须保证是最后执行的。一旦执行，整个方法结束。</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反编译之后的效果</span></span><br><span class="line"><span class="comment">public static int m()&#123;</span></span><br><span class="line"><span class="comment">    int i = 100;</span></span><br><span class="line"><span class="comment">    int j = i;</span></span><br><span class="line"><span class="comment">    i++;</span></span><br><span class="line"><span class="comment">    return j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="finally-finalize-final"><a href="#finally-finalize-final" class="headerlink" title="finally finalize final"></a>finally finalize final</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final finally finalize有什么区别？</span></span><br><span class="line"><span class="comment">    final 关键字</span></span><br><span class="line"><span class="comment">        final修饰的类无法继承</span></span><br><span class="line"><span class="comment">        final修饰的方法无法覆盖</span></span><br><span class="line"><span class="comment">        final修饰的变量不能重新赋值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    finally 关键字</span></span><br><span class="line"><span class="comment">        和try一起联合使用。</span></span><br><span class="line"><span class="comment">        finally语句块中的代码是必须执行的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    finalize 标识符</span></span><br><span class="line"><span class="comment">        是一个Object类中的方法名。</span></span><br><span class="line"><span class="comment">        这个方法是由垃圾回收器GC负责调用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// final是一个关键字。表示最终的。不变的。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//i = 200;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// finally也是一个关键字，和try联合使用，使用在异常处理机制中</span></span><br><span class="line">        <span class="comment">// 在fianlly语句块中的代码是一定会执行的。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// finalize()是Object类中的一个方法。作为方法名出现。</span></span><br><span class="line">        <span class="comment">// 所以finalize是标识符。</span></span><br><span class="line">        <span class="comment">// finalize()方法是JVM的GC垃圾回收器负责调用。</span></span><br><span class="line">        Object obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的类无法继承</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 常量。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// final修饰的方法无法覆盖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，</span></span><br><span class="line"><span class="comment">这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们</span></span><br><span class="line"><span class="comment">程序员可以自己定义吗？</span></span><br><span class="line"><span class="comment">    可以。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、Java中怎么自定义异常呢？</span></span><br><span class="line"><span class="comment">    两步：</span></span><br><span class="line"><span class="comment">        第一步：编写一个类继承Exception或者RuntimeException.</span></span><br><span class="line"><span class="comment">        第二步：提供两个构造方法，一个无参数的，一个带有String参数的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    死记硬背。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123; <span class="comment">// 编译时异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class MyException extends RuntimeException&#123; // 运行时异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建异常对象（只new了异常对象，并没有手动抛出）</span></span><br><span class="line">        <span class="type">MyException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;用户名不能为空！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取异常简单描述信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	编写程序，使用一维数组，模拟栈数据结构。</span></span><br><span class="line"><span class="comment">	【有删减】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 被压入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> MyStackOperationException &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= elements.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 手动抛出异常！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyStackOperationException</span>(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> MyStackOperationException &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyStackOperationException</span>(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够执行到此处说明栈没有空。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈操作异常：自定义异常！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStackOperationException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123; <span class="comment">// 编译时异常！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>IDEA的默认当前路径是在哪？工程的根目录</p>
<p>有多种分类方式：</p>
<ul>
<li><p>一种方式是按照流的方向进行分类：以内存作为参照物</p>
<ul>
<li>往内存中去，叫做输入(Input)。或者叫做读(Read)。</li>
<li>从内存中出来，叫做输出(Output)。或者叫做写(Write)。</li>
</ul>
</li>
<li><p>另一种方式是按照读取数据方式不同进行分类：</p>
</li>
<li><p>有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等….<br>假设文件file1.txt，采用字节流的话是这样读的：<br>a中国bc张三fe<br>第一次读：一个字节，正好读到’a’<br>第二次读：一个字节，正好读到’中’字符的一半。<br>第三次读：一个字节，正好读到’中’字符的另外一半。</p>
</li>
<li><p>有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。<br>假设文件file1.txt，采用字符流的话是这样读的：<br>a中国bc张三fe<br>第一次读：’a’字符（’a’字符在windows系统中占用1个字节。）<br>第二次读：’中’字符（’中’字符在windows系统中占用2个字节。）</p>
</li>
</ul>
<p>流的分类</p>
<ul>
<li>输入流、输出流</li>
<li>字节流、字符流</li>
</ul>
<p>java中所有的流都是在：java.io.*;下。</p>
<p>java中主要还是研究：<br>怎么new流对象。调用流对象的哪个方法是读，哪个方法是写。</p>
<p>java IO流这块有四大家族：<br>四大家族的首领：<br>四大家族的首领都是抽象类。(abstract class)</p>
<ul>
<li><p>java.io.InputStream  字节输入流</p>
</li>
<li><p>java.io.OutputStream 字节输出流</p>
</li>
<li><p>java.io.Reader字符输入流</p>
</li>
<li><p>java.io.Writer字符输出流</p>
</li>
</ul>
<p>所有的<strong>流</strong>都实现了：<br>java.io.Closeable接口，都是可关闭的，都有close()方法。<br>流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。</p>
<p>所有的<strong>输出流</strong>都实现了：<br>java.io.Flushable接口，都是可刷新的，都有flush()方法。<br>养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下。这个刷新表示将通道&#x2F;管道当中剩余未输出的数据强行输出完（清空管道！）刷新的作用就是清空管道。<br><strong>注意：如果没有flush()可能会导致丢失数据。</strong></p>
<p>注意：在java中只要“类名”以Stream结尾的都是字节流。以“Reader&#x2F;Writer”结尾的都是字符流。</p>
<p>java.io包下需要掌握的流有16个：</p>
<p>文件专属：<br>java.io.FileInputStream（掌握）<br>java.io.FileOutputStream（掌握）<br>java.io.FileReader<br>java.io.FileWriter</p>
<p>转换流：（将字节流转换成字符流）<br>java.io.InputStreamReader<br>java.io.OutputStreamWriter</p>
<p>缓冲流专属：<br>java.io.BufferedReader<br>java.io.BufferedWriter<br>java.io.BufferedInputStream<br>java.io.BufferedOutputStream</p>
<p>数据流专属：<br>java.io.DataInputStream<br>java.io.DataOutputStream</p>
<p>标准输出流：<br>java.io.PrintWriter<br>java.io.PrintStream（掌握）</p>
<p>对象专属流：<br>java.io.ObjectInputStream（掌握）<br>java.io.ObjectOutputStream（掌握）</p>
<p>java.io.File类。<br>File类的常用方法。</p>
<p>java io这块还剩下什么内容：<br>第一：ObjectInputStream ObjectOutputStream的使用。<br>第二：IO流+Properties集合的联合使用。</p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</p>
<p>2、字节的方式，完成输入的操作，完成读的操作（硬盘—&gt; 内存）</p>
<p>最终版：背模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个 null 的流对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;chapter23/src/tempfile3&quot;</span>); <span class="comment">//流对象赋值</span></span><br><span class="line">            <span class="comment">// 准备一个byte数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">/*while(true)&#123;</span></span><br><span class="line"><span class="comment">                int readCount = fis.read(bytes);</span></span><br><span class="line"><span class="comment">                if(readCount == -1)&#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // 把byte数组转换成字符串，读到多少个转换多少个。</span></span><br><span class="line"><span class="comment">                System.out.print(new String(bytes, 0, readCount));</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, readCount)); <span class="comment">//取已经更新了的字符串输出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>FileInputStream类的其它常用方法：</p>
<ul>
<li>int available()：返回流当中剩余的没有读到的字节数量</li>
<li>long skip(long n)：跳过几个字节不读。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;tempfile&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;总字节数量：&quot;</span> + fis.available());</span><br><span class="line">            <span class="comment">// 读1个字节</span></span><br><span class="line">            <span class="comment">//int readByte = fis.read();</span></span><br><span class="line">            <span class="comment">// 还剩下可以读的字节数量是：5</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;剩下多少个字节没有读：&quot; + fis.available());</span></span><br><span class="line">            <span class="comment">// 这个方法有什么用？</span></span><br><span class="line">            <span class="comment">//byte[] bytes = new byte[fis.available()];</span></span><br><span class="line">            <span class="comment">// 这种方式不太适合太大的文件，因为byte[]数组不能太大。</span></span><br><span class="line">            <span class="comment">// 不需要循环了。</span></span><br><span class="line">            <span class="comment">// 直接读一次就行了。</span></span><br><span class="line">            <span class="comment">//int readCount = fis.read(bytes); // 6</span></span><br><span class="line">            <span class="comment">//System.out.println(new String(bytes)); // abcdef</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// skip跳过几个字节不读取，这个方法也可能以后会用！</span></span><br><span class="line">            fis.skip(<span class="number">3</span>);</span><br><span class="line">            System.out.println(fis.read()); <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件不存在的时候会自动新建！</span></span><br><span class="line">            <span class="comment">// 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以追加的方式在文件末尾写入。不会清空原文件内容。 加个true</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;chapter23/src/tempfile3&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 开始写。</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>&#125;;</span><br><span class="line">            <span class="comment">// 将byte数组全部写出！</span></span><br><span class="line">            fos.write(bytes); <span class="comment">// abcd</span></span><br><span class="line">            <span class="comment">// 将byte数组的一部分写出！</span></span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 再写出ab</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我是一个中国人，我骄傲！！！&quot;</span>;</span><br><span class="line">            <span class="comment">// 将字符串转换成byte数组。</span></span><br><span class="line">            <span class="type">byte</span>[] bs = s.getBytes();</span><br><span class="line">            <span class="comment">// 写</span></span><br><span class="line">            fos.write(bs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写完之后，最后一定要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><ul>
<li>文件字符输入流，只能读取普通文本。</li>
<li>读取文本内容时，比较方便，快捷。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建文件字符输入流</span></span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;tempfile&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备一个char数组</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">// 往char数组中读</span></span><br><span class="line">            <span class="comment">// 开始读</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>]; <span class="comment">// 一次读取4个*字符*</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = reader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readCount));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><ul>
<li>文件字符输出流。写。</li>
<li>只能输出普通文本，普通文本，不能输出图片声音等文件</li>
<li>能用记事本编辑的都是普通文件</li>
<li>word不是普通文本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建文件字符输出流对象</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file&quot;</span>, <span class="literal">true</span>); <span class="comment">// true 表示追加</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始写。</span></span><br><span class="line">            <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">            out.write(chars);</span><br><span class="line">            out.write(chars, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//“中国人”</span></span><br><span class="line"></span><br><span class="line">            out.write(<span class="string">&quot;我是一名java软件工程师！&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出一个换行符。</span></span><br><span class="line">            out.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刷新</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><ul>
<li>这个流没有前面那些快</li>
<li>带有缓冲区的字符输入流。</li>
<li>使用这个流的时候<strong>不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Copy02.java&quot;</span>);</span><br><span class="line">        <span class="comment">// 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。</span></span><br><span class="line">        <span class="comment">// 外部负责包装的这个流，叫做：包装流（处理流）</span></span><br><span class="line">        <span class="comment">// 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// br.readLine()方法读取一个文本行，但不带换行符。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="literal">null</span>)&#123; <span class="comment">//一行一行地读</span></span><br><span class="line">            System.out.print(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        <span class="comment">// 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 带有缓冲区的字符输出流</span></span><br><span class="line">        <span class="comment">//BufferedWriter out = new BufferedWriter(new FileWriter(&quot;copy&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy&quot;</span>, <span class="literal">true</span>)));</span><br><span class="line">        <span class="comment">// 开始写。</span></span><br><span class="line">        out.write(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        out.flush();</span><br><span class="line">        <span class="comment">// 关闭最外层</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流-少用"><a href="#转换流-少用" class="headerlink" title="转换流(少用)"></a>转换流(少用)</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p>把字节流转换为字符流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*// 字节流</span></span><br><span class="line"><span class="comment">        FileInputStream in = new FileInputStream(&quot;Copy02.java&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 通过转换流转换（InputStreamReader将字节流转换成字符流。）</span></span><br><span class="line"><span class="comment">        // in是节点流。reader是包装流。</span></span><br><span class="line"><span class="comment">        InputStreamReader reader = new InputStreamReader(in);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 这个构造方法只能传一个字符流。不能传字节流。</span></span><br><span class="line"><span class="comment">        // reader是节点流。br是包装流。</span></span><br><span class="line"><span class="comment">        BufferedReader br = new BufferedReader(reader);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Copy02.java&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭最外层</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据流（了解）"><a href="#数据流（了解）" class="headerlink" title="数据流（了解）"></a>数据流（了解）</h3><ul>
<li>java.io.DataOutputStream：数据专属的流。</li>
<li>这个流可以将数据连同数据的类型一并写入文件。</li>
<li>注意：这个文件不是普通文本文档。（这个文件使用记事本<strong>打不开</strong>。）</li>
</ul>
<p>写入文件之后，相当于“加密了”。<br>用普通的记事本文件打开是乱码，在“解密”的时候，必须按照<strong>一样的顺序</strong>读入流中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建数据专属的字节输出流</span></span><br><span class="line">        <span class="comment">// 抽象类不能创建对象，所以创建文件流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">400L</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.0F</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 写</span></span><br><span class="line">        dos.writeByte(b); <span class="comment">// 把数据以及数据的类型一并写入到文件当中。</span></span><br><span class="line">        dos.writeShort(s);</span><br><span class="line">        dos.writeInt(i);</span><br><span class="line">        dos.writeLong(l);</span><br><span class="line">        dos.writeFloat(f);</span><br><span class="line">        dos.writeDouble(d);</span><br><span class="line">        dos.writeBoolean(sex);</span><br><span class="line">        dos.writeChar(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="comment">// 关闭最外层</span></span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>DataInputStream:数据字节输入流。</li>
<li>DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。</li>
<li>读的顺序需要和写的顺序一致。才可以正常取出数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        <span class="comment">// 开始读</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> dis.readByte();</span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> dis.readShort();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> dis.readLong();</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> dis.readFloat();</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sex</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> dis.readChar();</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(i + <span class="number">1000</span>);</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(sex);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.PrintStream：标准的字节输出流。默认输出到控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合起来写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分开写</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">        ps.println(<span class="string">&quot;hello zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标准输出流不需要手动close()关闭。</span></span><br><span class="line">        <span class="comment">// 可以改变标准输出流的输出方向吗？ 可以</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 这些是之前System类使用过的方法和属性。</span></span><br><span class="line"><span class="comment">        System.gc();</span></span><br><span class="line"><span class="comment">        System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        PrintStream ps2 = System.out;</span></span><br><span class="line"><span class="comment">        System.exit(0);</span></span><br><span class="line"><span class="comment">        System.arraycopy(....);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标准输出流不再指向控制台，指向“log”文件。</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;log&quot;</span>));</span><br><span class="line">        <span class="comment">// 修改输出方向，将输出方向修改到&quot;log&quot;文件。</span></span><br><span class="line">        System.setOut(printStream);</span><br><span class="line">        <span class="comment">// 再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//这些就输出在log文件中了（日志框架）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">日志工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    记录日志的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 指向一个日志文件</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;log.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">            <span class="comment">// 改变输出方向</span></span><br><span class="line">            System.setOut(out);</span><br><span class="line">            <span class="comment">// 日期当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(nowTime);</span><br><span class="line"></span><br><span class="line">            System.out.println(strTime + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>java.io.NotSerializableException:</p>
<ul>
<li><p>Student对象不支持序列化</p>
</li>
<li><p>参与序列化和反序列化的对象，必须实现Serializable接口。</p>
</li>
<li><p>注意：通过源代码发现，Serializable接口只是一个标志接口：</p>
<ul>
<li>public interface Serializable {}这个接口当中什么代码都没有。</li>
<li>那么它起到一个什么作用呢？<ul>
<li>起到标识的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。<br>  Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成<br>  一个序列化版本号。</li>
</ul>
</li>
</ul>
</li>
<li><p>序列化版本号有什么用呢？<br>  java.io.InvalidClassException:<br>  com.bjpowernode.java.bean.Student;<br>  local class incompatible:<br>      stream classdesc serialVersionUID &#x3D; -684255398724514298（十年后）,<br>      local class serialVersionUID &#x3D; -3463447116624555755（十年前）</p>
</li>
<li><p>java语言中是采用什么机制来区分类的？</p>
<ul>
<li>第一：首先通过类名进行比对，如果类名不一样，肯定不是同一个类。</li>
<li>第二：如果类名一样，再怎么进行类的区别？靠序列化版本号进行区分。</li>
</ul>
</li>
<li><p>小鹏编写了一个类：com.bjpowernode.java.bean.Student implements Serializable</p>
</li>
<li><p>胡浪编写了一个类：com.bjpowernode.java.bean.Student implements Serializable</p>
</li>
<li><p>不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了:对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）</p>
</li>
</ul>
<p>请思考？</p>
<ul>
<li>这种自动生成序列化版本号有什么缺陷？</li>
<li>这种自动生成的序列化版本号缺点是：一旦代码确定之后，不能进行后续的修改，</li>
<li>因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java</li>
<li>虚拟机会认为这是一个全新的类。（这样就不好了！）</li>
</ul>
<p>最终结论：</p>
<ul>
<li>凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。</li>
<li>private static final long serialVersionUID &#x3D; -123456789;(自己指定)</li>
<li>IDEA生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个一个存，存多个对象报错，只能通过序列化集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建java对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1111</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;students&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一次序列化多个对象呢？</span></span><br><span class="line"><span class="comment">    可以，可以将对象放到集合当中，序列化集合。</span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">    参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;users&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化一个集合，这个集合对象中放了很多其他对象。</span></span><br><span class="line">        oos.writeObject(userList);</span><br><span class="line"></span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        <span class="comment">// 开始反序列化，读</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="comment">// 反序列化回来是一个学生对象，所以会调用学生对象的toString方法。</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反序列化集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStreamTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;users&quot;</span>));</span><br><span class="line">        <span class="comment">//Object obj = ois.readObject();</span></span><br><span class="line">        <span class="comment">//System.out.println(obj instanceof List);</span></span><br><span class="line">        List&lt;User&gt; userList = (List&lt;User&gt;)ois.readObject();</span><br><span class="line">        <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>transient 关键字，指定的变量不参加序列化</p>
<h3 id="IO-properties-联合使用"><a href="#IO-properties-联合使用" class="headerlink" title="IO + properties 联合使用"></a>IO + properties 联合使用</h3><p>IO+Properties的联合应用。</p>
<p>非常好的一个设计理念：</p>
<ul>
<li><p>以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启。就可以拿到动态的信息。</p>
</li>
<li><p>类似于以上机制的这种文件被称为配置文件。并且当配置文件中的内容格式是： key&#x3D;value 的时候，我们把这种配置文件叫做属性配置文件。</p>
</li>
</ul>
<p>java规范中有要求：</p>
<ul>
<li>属性配置文件建议以.properties结尾，但这不是必须的。</li>
<li>这种以.properties结尾的文件在java中被称为：属性配置文件。</li>
<li>其中Properties是专门存放属性配置文件内容的一个类。</li>
<li>最好不要有空格</li>
<li>在属性配置文件中， # 为注释，重复的值会覆盖</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoPropertiesTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Properties是一个Map集合，key和value都是String类型。</span></span><br><span class="line"><span class="comment">        想将userinfo文件中的数据加载到Properties对象当中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 新建一个输入流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;chapter23/userinfo.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个Map集合</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Properties对象的load方法将文件中的数据加载到Map集合中。</span></span><br><span class="line">        pro.load(reader); <span class="comment">// 文件中的数据顺着管道加载到Map集合中，其中等号=左边做key，右边做value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过key来获取value呢？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><h4 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream + FileOutputStream"></a>FileInputStream + FileOutputStream</h4><ul>
<li>使用FileInputStream + FileOutputStream完成文件的拷贝。</li>
<li>拷贝的过程应该是一边读，一边写。</li>
<li>使用以上的字节流拷贝文件的时候，文件类型随意，万能的。<strong>什么样的文件都能拷贝。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\course\\02-JavaSE\\video\\chapter01\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建一个输出流对象</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最核心的：一边读，一边写</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 1MB（一次最多拷贝1MB。）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刷新，输出流最后要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 分开try，不要一起try。</span></span><br><span class="line">            <span class="comment">// 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。</span></span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader + FileWriter"></a>FileReader + FileWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读</span></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;chapter23/src/com/bjpowernode/java/io/Copy02.java&quot;</span>);</span><br><span class="line">            <span class="comment">// 写</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Copy02.java&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一边读一边写：</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span> * <span class="number">512</span>]; <span class="comment">// 1MB</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = in.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(chars, <span class="number">0</span>, readCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刷新</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录拷贝"><a href="#目录拷贝" class="headerlink" title="目录拷贝"></a>目录拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拷贝目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyAll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 拷贝源</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\02-JavaSE\\document&quot;</span>);</span><br><span class="line">        <span class="comment">// 拷贝目标</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\a\\b\\c&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法拷贝</span></span><br><span class="line">        copyDir(srcFile, destFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 拷贝源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destFile 拷贝目标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyDir</span><span class="params">(File srcFile, File destFile)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(srcFile.isFile()) &#123;</span><br><span class="line">            <span class="comment">// srcFile如果是一个文件的话，递归结束。</span></span><br><span class="line">            <span class="comment">// 是文件的时候需要拷贝。</span></span><br><span class="line">            <span class="comment">// ....一边读一边写。</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读这个文件</span></span><br><span class="line">                <span class="comment">// D:\course\02-JavaSE\document\JavaSE进阶讲义\JavaSE进阶-01-面向对象.pdf</span></span><br><span class="line">                in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">                <span class="comment">// 写到这个文件中</span></span><br><span class="line">                <span class="comment">// C:\course\02-JavaSE\document\JavaSE进阶讲义\JavaSE进阶-01-面向对象.pdf</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (destFile.getAbsolutePath().endsWith(<span class="string">&quot;\\&quot;</span>) ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + <span class="string">&quot;\\&quot;</span>)  + srcFile.getAbsolutePath().substring(<span class="number">3</span>);</span><br><span class="line">                out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line">                <span class="comment">// 一边读一边写</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 一次复制1MB</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((readCount = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes, <span class="number">0</span>, readCount);</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取源下面的子目录</span></span><br><span class="line">        File[] files = srcFile.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">            <span class="comment">// 获取所有文件的（包括目录和文件）绝对路径</span></span><br><span class="line">            <span class="comment">//System.out.println(file.getAbsolutePath());</span></span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">                <span class="comment">// 新建对应的目录</span></span><br><span class="line">                <span class="comment">//System.out.println(file.getAbsolutePath());</span></span><br><span class="line">                <span class="comment">//D:\course\02-JavaSE\document\JavaSE进阶讲义       源目录</span></span><br><span class="line">                <span class="comment">//C:\course\02-JavaSE\document\JavaSE进阶讲义       目标目录</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">srcDir</span> <span class="operator">=</span> file.getAbsolutePath();</span><br><span class="line">                <span class="type">String</span> <span class="variable">destDir</span> <span class="operator">=</span> (destFile.getAbsolutePath().endsWith(<span class="string">&quot;\\&quot;</span>) ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + <span class="string">&quot;\\&quot;</span>)  + srcDir.substring(<span class="number">3</span>);</span><br><span class="line">                <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destDir);</span><br><span class="line">                <span class="keyword">if</span>(!newFile.exists())&#123;</span><br><span class="line">                    newFile.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            copyDir(file, destFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类和四大家族没有关系，所以File类不能完成文件的读和写。<br>File对象代表什么？</p>
<pre><code>- 文件和目录路径名的抽象表示形式。
- C:\Drivers 这是一个File对象
- C:\Drivers\Lan\Realtek\Readme.txt 也是File对象。
- 一个File对象有可能对应的是目录，也可能是文件。
- File只是一个路径名的抽象表示形式。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在！</span></span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果D:\file不存在，则以文件的形式创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(!f1.exists()) &#123;</span><br><span class="line">            <span class="comment">// 以文件形式新建</span></span><br><span class="line">            f1.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果D:\file不存在，则以目录的形式创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(!f1.exists()) &#123;</span><br><span class="line">            <span class="comment">// 以目录的形式新建。</span></span><br><span class="line">            f1.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以创建多重目录吗？</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c/d/e/f&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f2.exists()) &#123;</span><br><span class="line">            <span class="comment">// 多重目录的形式新建。</span></span><br><span class="line">            f2.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\01-开课\\学习方法.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件的父路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> f3.getParent();</span><br><span class="line">        System.out.println(parentPath); <span class="comment">//D:\course\01-开课</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> f3.getParentFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取绝对路径：&quot;</span> + parentFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;copy&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径：&quot;</span> + f4.getAbsolutePath()); <span class="comment">// C:\Users\Administrator\IdeaProjects\javase\copy</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\01-开课\\开学典礼.ppt&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件名：&quot;</span> + f1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是一个目录</span></span><br><span class="line">        System.out.println(f1.isDirectory()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是一个文件</span></span><br><span class="line">        System.out.println(f1.isFile()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件最后一次修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">haoMiao</span> <span class="operator">=</span> f1.lastModified(); <span class="comment">// 这个毫秒是从1970年到现在的总毫秒数。</span></span><br><span class="line">        <span class="comment">// 将总毫秒数转换成日期?????</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(haoMiao);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(time);</span><br><span class="line">        System.out.println(strTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件大小</span></span><br><span class="line">        System.out.println(f1.length()); <span class="comment">//216064字节。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File中的listFiles方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// File[] listFiles()</span></span><br><span class="line">        <span class="comment">// 获取当前目录下所有的子文件。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\01-开课&quot;</span>);</span><br><span class="line">        File[] files = f.listFiles();</span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(file.getAbsolutePath());</span></span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Annotation</p>
<p>注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件。</p>
<p>怎么自定义注解呢？ [修饰符列表] @interface 注解类型名{ }</p>
<p>注解使用时的语法格式是：@注解类型名</p>
<p>注解可以出现在类上、属性上、方法上、变量上等….注解还可以出现在注解类型上。默认情况下，注解可以出现在任意位置。</p>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><p>关于JDK lang包下的Override注解<br>源代码：public @interface Override {}</p>
<ul>
<li>标识性注解，给编译器做参考的。编译器看到方法上有这个注解的时候，编译器会自动检查该方法是否重写了父类的方法。如果没有重写，报错。</li>
<li>这个注解只是在编译阶段起作用，和运行期无关！</li>
<li>@Override这个注解只能注解方法。</li>
<li>@Override这个注解是给编译器参考的，和运行阶段没有关系。</li>
</ul>
<p>凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。<br>Override 表示一个方法声明打算重写超类中的另一个方法声明。</p>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h4><p>作用：告诉其他程序员这个标记的元素已经过时了。</p>
<p>注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>什么是元注解？用来标注“注解类型”的“注解”，称为元注解。</p>
<p>常见的元注解有哪些？Target&#x2F;Retention</p>
<p>关于Target注解：这是一个元注解，用来标注“注解类型”的“注解”这个Target注解用来标注“被标注的注解”可以出现在哪些位置上。</p>
<p>@Target(ElementType.METHOD)：表示“被标注的注解”只能出现在方法上。<br>@Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})<br>表示该注解可以出现在：构造方法上&#x2F;字段上&#x2F;局部变量上&#x2F;方法上&#x2F;类上…</p>
<p>关于Retention注解：这是一个元注解，用来标注“注解类型”的“注解”这个Retention注解用来标注“被标注的注解”最终保存在哪里。</p>
<p>@Retention(RetentionPolicy.SOURCE)：表示该注解只被保留在java源文件中。<br>@Retention(RetentionPolicy.CLASS)：表示该注解被保存在class文件中。<br>@Retention(RetentionPolicy.RUNTIME)：表示该注解被保存在class文件中，并且可以被反射机制所读取。</p>
<h3 id="注解中的属性"><a href="#注解中的属性" class="headerlink" title="注解中的属性"></a>注解中的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们通常在注解当中可以定义属性，以下这个是MyAnnotation的name属性。</span></span><br><span class="line"><span class="comment">     * 看着像1个方法，但实际上我们称之为属性name。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">25</span>; <span class="comment">//属性指定默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//报错的原因：如果一个注解当中有属性，那么必须给属性赋值。（除非该属性使用default指定了默认值。）</span></span><br><span class="line">    <span class="comment">//@MyAnnotation(属性名=属性值,属性名=属性值,属性名=属性值)</span></span><br><span class="line">    <span class="comment">//指定name属性的值就好了。</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;zhangsan&quot;, color = &quot;红色&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个注解的属性的名字是value(其他名字不行)，并且只有一个属性的话，在使用的时候，该属性名可以省略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错原因：没有指定属性的值。</span></span><br><span class="line">    <span class="comment">/*@MyAnnotation</span></span><br><span class="line"><span class="comment">    public void doSome()&#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;hehe&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;haha&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：<br>假设有这样一个注解，叫做：@Id</p>
<p>这个注解只能出现在类上面，当这个类上有这个注解的时候，要求这个类中必须有一个int类型的id属性。如果没有这个属性就报异常。如果有这个属性则正常执行！</p>
<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>反射机制（比较简单，因为只要会查帮助文档，就可以了。）</p>
<p>反射机制有什么用？</p>
<ul>
<li><p>通过java语言中的反射机制可以操作字节码文件。</p>
</li>
<li><p>类似于黑客。（可以读和修改字节码文件。）</p>
</li>
<li><p>通过反射机制可以操作代码片段。（class文件。）</p>
</li>
<li><p>java.lang.reflect.*;</p>
</li>
</ul>
<p>反射机制相关的重要的类有哪些？</p>
<ul>
<li>java.lang.Class：代表整个字节码，代表一个类型，代表整个类。</li>
<li>java.lang.reflect.Method：代表字节码中的方法字节码。代表类中的方法。</li>
<li>java.lang.reflect.Constructor：代表字节码中的构造方法字节码。代表类中的构造方法</li>
<li>java.lang.reflect.Field：代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</li>
</ul>
<h3 id="获取一个类的字节码"><a href="#获取一个类的字节码" class="headerlink" title="获取一个类的字节码"></a>获取一个类的字节码</h3><p>三种方式</p>
<ul>
<li>第一种：Class c &#x3D; Class.forName(“完整类名带包名”);</li>
<li>第二种：Class c &#x3D; 对象.getClass();</li>
<li>第三种：Class c &#x3D; 任何类型.class;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Class.forName()</span></span><br><span class="line"><span class="comment">            1、静态方法</span></span><br><span class="line"><span class="comment">            2、方法的参数是一个字符串。</span></span><br><span class="line"><span class="comment">            3、字符串需要的是一个完整类名。</span></span><br><span class="line"><span class="comment">            4、完整类名必须带有包名。java.lang包也不能省略。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// c1代表String.class文件，或者说c1代表String类型。</span></span><br><span class="line">            c2 = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>); <span class="comment">// c2代表Date类型</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式 java中任何一个对象都有一个方法：getClass()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">x</span> <span class="operator">=</span> s.getClass(); <span class="comment">// x代表String.class字节码文件，x代表String类型。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.class属性。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">z</span> <span class="operator">=</span> String.class; <span class="comment">// z代表String类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">e</span> <span class="operator">=</span> <span class="type">double</span>.class; <span class="comment">// e代表double类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3、关于JDK中自带的类加载器：（聊一聊，不需要掌握，知道当然最好！）<br>3.1、什么是类加载器？<br>专门负责加载类的命令&#x2F;工具。<br>ClassLoader</p>
<p>3.2、JDK中自带了3个类加载器<br>启动类加载器:rt.jar<br>扩展类加载器:ext&#x2F;*.jar<br>应用类加载器:classpath</p>
<p>3.3、假设有这样一段代码：<br>String s &#x3D; “abc”;</p>
<p>代码在开始执行之前，会将所需要类全部加载到JVM当中。<br>通过类加载器加载，看到以上代码类加载器会找String.class<br>文件，找到就加载，那么是怎么进行加载的呢？</p>
<p>首先通过“启动类加载器”加载。<br>注意：启动类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\rt.jar<br>rt.jar中都是JDK最核心的类库。</p>
<p>如果通过“启动类加载器”加载不到的时候，<br>会通过”扩展类加载器”加载。<br>注意：扩展类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\ext*.jar</p>
<p>如果“扩展类加载器”没有加载到，那么<br>会通过“应用类加载器”加载。<br>注意：应用类加载器专门加载：classpath中的类。</p>
<p>3.4、java中为了保证类加载的安全，使用了双亲委派机制。<br>优先从启动类加载器中加载，这个称为“父”<br>“父”无法加载到，再从扩展类加载器中加载，<br>这个称为“母”。双亲委派。如果都加载不到，<br>才会考虑从应用类加载器中加载。直到加载<br>到为止。</p>
<p>1、回顾反射机制</p>
<p>1.1、什么是反射机制？反射机制有什么用？<br>反射机制：可以操作字节码文件<br>作用：可以让程序更加灵活。</p>
<p>1.2、反射机制相关的类在哪个包下？<br>java.lang.reflect.*;</p>
<p>1.3、反射机制相关的主要的类？<br>java.lang.Class<br>java.lang.reflect.Method;<br>java.lang.reflect.Constructor;<br>java.lang.reflect.Field;</p>
<p>1.4、在java中获取Class的三种方式？<br>第一种：<br>Class c &#x3D; Class.forName(“完整类名”);<br>第二种：<br>Class c &#x3D; 对象.getClass();<br>第三种：<br>Class c &#x3D; int.class;<br>Class c &#x3D; String.class;</p>
<p>1.5、获取了Class之后，可以调用无参数构造方法来实例化对象</p>
<p>&#x2F;&#x2F;c代表的就是日期Date类型<br>Class c &#x3D; Class.forName(“java.util.Date”);</p>
<p>&#x2F;&#x2F;实例化一个Date日期类型的对象<br>Object obj &#x3D; c.newInstance();</p>
<p>一定要注意：<br>newInstance()底层调用的是该类型的无参数构造方法。<br>如果没有这个无参数构造方法会出现”实例化”异常。</p>
<p>1.6、如果你只想让一个类的“静态代码块”执行的话，你可以怎么做？<br>Class.forName(“该类的类名”);<br>这样类就加载，类加载的时候，静态代码块执行！！！！<br>在这里，对该方法的返回值不感兴趣，主要是为了使用“类加载”这个动作。</p>
<p>1.7、关于路径问题？</p>
<p>String path &#x3D; Thread.currentThread().getContextClassLoader()<br>  .getResource(“写相对路径，但是这个相对路径从src出发开始找”).getPath();</p>
<p>String path &#x3D; Thread.currentThread().getContextClassLoader()<br>  .getResource(“abc”).getPath();&#x2F;&#x2F;必须保证src下有abc文件。</p>
<p>String path &#x3D; Thread.currentThread().getContextClassLoader()<br>  .getResource(“a&#x2F;db”).getPath();&#x2F;&#x2F;必须保证src下有a目录，a目录下有db文件。</p>
<p>String path &#x3D; Thread.currentThread().getContextClassLoader()<br>  .getResource(“com&#x2F;bjpowernode&#x2F;test.properties”).getPath();<br>  &#x2F;&#x2F;必须保证src下有com目录，com目录下有bjpowernode目录。<br>  &#x2F;&#x2F;bjpowernode目录下有test.properties文件。</p>
<p>这种方式是为了获取一个文件的绝对路径。（通用方式，不会受到环境移植的影响。）<br>但是该文件要求放在类路径下，换句话说：也就是放到src下面。<br>src下是类的根路径。</p>
<p>直接以流的形式返回：<br>InputStream in &#x3D; Thread.currentThread().getContextClassLoader()<br>.getResourceAsStream(“com&#x2F;bjpowernode&#x2F;test.properties”);</p>
<p>1.8、IO + Properties，怎么快速绑定属性资源文件？</p>
<p>&#x2F;&#x2F;要求：第一这个文件必须在类路径下<br>&#x2F;&#x2F;第二这个文件必须是以.properties结尾。<br>ResourceBundle bundle &#x3D; ResourceBundle.getBundle(“com&#x2F;bjpowernode&#x2F;test”);<br>String value &#x3D; bundle.getString(key);</p>
<p>2、今日反射机制的重点内容<br>2.1、通过反射机制访问对象的某个属性。<br>2.2、通过反射机制调用对象的某个方法。<br>2.3、通过反射机制调用某个构造方法实例化对象。<br>2.4、通过反射机制获取父类以及父类型接口。</p>
<h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>什么是进程？什么是线程？</p>
<ul>
<li>进程是一个应用程序（1个进程是一个软件）。</li>
<li>线程是一个进程中的执行场景&#x2F;执行单元。</li>
<li>一个进程可以启动多个线程。</li>
</ul>
<p>对于java程序来说，当在DOS命令窗口中输入：java HelloWorld 回车之后。会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收线程，一个是执行main方法的主线程。</p>
<p>进程和线程是什么关系？举个例子</p>
<ul>
<li>阿里巴巴：进程<ul>
<li>马云：阿里巴巴的一个线程</li>
<li>童文红:阿里巴巴的一个线程</li>
</ul>
</li>
<li>京东：进程<ul>
<li>强东：京东的一个线程</li>
<li>妹妹：京东的一个线程</li>
</ul>
</li>
<li>进程可以看做是现实生活当中的公司。</li>
<li>线程可以看做是公司当中的某个员工。</li>
</ul>
<p>注意：</p>
<ul>
<li>进程A和进程B的内存独立不共享。（阿里巴巴和京东资源不会共享的！）</li>
<li>魔兽游戏是一个进程</li>
<li>酷狗音乐是一个进程</li>
<li>这两个进程是独立的，不共享资源。</li>
</ul>
<p>线程A和线程B呢？<br>在java语言中：线程A和线程B，<strong>堆内存和方法区内存</strong>共享。但是<strong>栈内存</strong>独立，一个线程一个栈。<br>假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。</p>
<p>火车站，可以看做是一个进程。火车站中的每一个售票窗口可以看做是一个线程。我在窗口1购票，你可以在窗口2购票，你不需要等我，我也不需要等你。所以多线程并发可以提高效率。</p>
<ul>
<li><p>java中之所以有多线程机制，目的就是为了提高程序的处理效率。</p>
</li>
<li><p>使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈。</p>
</li>
</ul>
<p>对于多核的CPU电脑来说，真正的多线程并发是没问题的。4核CPU表示同一个时间点上，可以真正的有4个进程并发执行。</p>
<p>分析一个问题：对于单核的CPU来说，真的可以做到真正的多线程并发吗？</p>
<p>什么是真正的多线程并发？t1线程执行t1的。t2线程执行t2的。t1不会影响t2，t2也不会影响t1。这叫做真正的多线程并发。</p>
<p>单核的CPU表示只有一个大脑：<br><strong>不能</strong>够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是：多个事情同时在做！<br>线程A：播放音乐<br>线程B：运行魔兽游戏<br>线程A和线程B频繁切换执行，人类会感觉音乐一直在播放，游戏一直在运行，给我们的感觉是同时并发的。</p>
<p>电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要“很长的”时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。</p>
<h3 id="实现多线程的两种方式"><a href="#实现多线程的两种方式" class="headerlink" title="实现多线程的两种方式"></a>实现多线程的两种方式</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>实现线程的第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。</p>
<ul>
<li>怎么创建线程对象？ new就行了。</li>
<li>怎么启动线程呢？ 调用线程对象的start()方法。</li>
<li>注意：亘古不变的道理：方法体当中的代码永远都是自上而下的顺序依次逐行执行的。</li>
<li>以下程序的输出结果有这样的特点：有先有后。有多有少。这是咋回事？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是main方法，这里的代码属于主线程，在主栈中运行。</span></span><br><span class="line">        <span class="comment">// 新建一个分支线程对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="comment">//t.run(); // 直接调用run方法不会启动另一个线程，不会分配新的分支栈。（这种方式就是单线程。）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。</span></span><br><span class="line">        <span class="comment">// run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 这里的代码还是运行在主线程中。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 编写程序，这段程序运行在分支线程中（分支栈）。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>实现线程的第二种方式，编写一个类实现java.lang.Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个可运行的对象</span></span><br><span class="line">        <span class="comment">// 将可运行的对象封装成一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 合并代码</span></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程---&gt;&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这并不是一个线程类，是一个可运行的类。它还不是一个线程。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程对象，采用匿名内部类方式。</span></span><br><span class="line">        <span class="comment">// 这是通过一个没有名字的类，new出来的对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t线程---&gt; &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程---&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h4><p>实现线程的第三种方式：实现Callable接口。（JDK8新特性。）<br>这种方式实现的线程可以获取线程的返回值。<br>之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。</p>
<p>思考：<br>系统委派一个线程去执行一个任务，该线程执行完任务之后，可能<br>会有一个执行结果，我们怎么能拿到这个执行结果呢？<br>使用第三种方式：实现Callable接口方式。</p>
<p>实现线程的第三种方式：</p>
<ul>
<li>实现Callable接口</li>
<li>这种方式的优点：可以获取到线程的执行结果。</li>
<li>这种方式的缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：创建一个“未来任务类”对象。</span></span><br><span class="line">        <span class="comment">// 参数非常重要，需要给一个Callable接口实现类对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// call()方法就相当于run方法。只不过这个有返回值</span></span><br><span class="line">                <span class="comment">// 线程执行一个任务，执行之后可能会有一个执行结果</span></span><br><span class="line">                <span class="comment">// 模拟执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;call method begin&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;call method end!&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">                <span class="keyword">return</span> a + b; <span class="comment">//自动装箱(300结果变成Integer)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是main方法，这是在主线程中。</span></span><br><span class="line">        <span class="comment">// 在主线程中，怎么获取t线程的返回结果？</span></span><br><span class="line">        <span class="comment">// get()方法的执行会导致“当前线程阻塞”</span></span><br><span class="line">        <span class="comment">// main方法这里的程序要想执行必须等待get()方法的结束</span></span><br><span class="line">        <span class="comment">// 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</span></span><br><span class="line">        <span class="comment">// 另一个线程执行是需要时间的。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行结果:&quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么获取当前线程对象？</p>
<ul>
<li>Thread t &#x3D; Thread.currentThread();</li>
<li>返回值t就是当前线程，这个代码出现在main中，当前线程就是主线程</li>
</ul>
<p>获取线程对象的名字</p>
<ul>
<li>String name &#x3D; 线程对象.getName();</li>
</ul>
<p>修改线程对象的名字</p>
<ul>
<li>线程对象.setName(“线程名字”);</li>
</ul>
<p>当线程没有设置名字的时候，默认的名字有什么规律？main&#x2F;Thread-0&#x2F;Thread-1&#x2F;Thread-2&#x2F;Thread-3&#x2F;…..</p>
<h3 id="睡眠与终止"><a href="#睡眠与终止" class="headerlink" title="睡眠与终止"></a>睡眠与终止</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>关于线程的sleep方法： static void sleep(long millis)</p>
<p>1、静态方法：Thread.sleep(1000);<br>2、参数是毫秒<br>3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。<br>4、Thread.sleep()方法，可以做到这种效果：间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 睡眠1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep睡眠太久了，如果希望半道上醒来，你应该怎么办？也就是说怎么叫醒一个正在睡眠的线程？？<br>注意：这个不是终断线程的执行，是终止线程的睡眠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 希望5秒之后，t线程醒来（5秒之后主线程手里的活儿干完了。）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）</span></span><br><span class="line">        <span class="comment">// 所以线程中必须对异常进行捕捉</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 干扰，一盆冷水过去！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>不建议使用：线程名称.stop();  已过时，不建议使用，容易丢失数据！</p>
<p>合理方式：</p>
<p>打标记&#x2F;改标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunable4</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunable4</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程</span></span><br><span class="line">        <span class="comment">// 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。</span></span><br><span class="line">        r.run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 打一个布尔标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(run)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// return就结束了，你在结束之前还有什么没保存的。</span></span><br><span class="line">                <span class="comment">// 在这里可以保存。</span></span><br><span class="line">                <span class="comment">//save....</span></span><br><span class="line">                <span class="comment">//终止当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度-优先级-让位-合并"><a href="#调度-优先级-让位-合并" class="headerlink" title="调度&#x2F;优先级&#x2F;让位&#x2F;合并"></a>调度&#x2F;优先级&#x2F;让位&#x2F;合并</h3><p>常见的线程调度模型有哪些？</p>
<ul>
<li>抢占式调度模型：那个线程的优先级比较高，抢到的CPU时间片的概率就高一些&#x2F;多一些。java采用的就是抢占式调度模型。</li>
<li>均分式调度模型：平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。平均分配，一切平等。有一些编程语言，线程调度模型采用的是这种方式。</li>
</ul>
<h4 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h4><p>实例方法：</p>
<ul>
<li>void setPriority(int newPriority) 设置线程的优先级</li>
<li>int getPriority() 获取线程优先级</li>
<li>最低优先级1</li>
<li>默认优先级是5</li>
<li>最高优先级10</li>
<li>优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的。）</li>
</ul>
<p>main线程的默认优先级是：5</p>
<ul>
<li>优先级较高的，只是抢到的CPU时间片相对多一些。</li>
<li>大概率方向更偏向于优先级比较高的。</li>
</ul>
<h4 id="让位"><a href="#让位" class="headerlink" title="让位"></a>让位</h4><p>静态方法：</p>
<ul>
<li>static void yield()  让位方法</li>
<li>Thread.yield(); 让位，当前线程暂停，回到就绪状态，让给其它线程。</li>
<li>暂停当前正在执行的线程对象，并执行其他线程</li>
<li>yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。注意：在回到就绪之后，有可能还会再次抢到。</li>
</ul>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable7</span>());</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//合并线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join(); <span class="comment">// t合并到当前线程中，当前线程受阻塞，t线程执行直到结束。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable7</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>为什么这个是重点？</p>
<ul>
<li>以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编写。</li>
</ul>
<p>最重要的是</p>
<ul>
<li>你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。（重点）</li>
</ul>
<p>什么时候数据在多线程并发的环境下会存在安全问题呢？</p>
<ul>
<li>条件1：多线程并发。</li>
<li>条件2：有共享数据。</li>
<li>条件3：共享数据有修改的行为。</li>
<li>满足以上3个条件之后，就会存在线程安全问题。</li>
</ul>
<p>当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？</p>
<ul>
<li>线程排队执行。（不能并发）。</li>
<li>用排队执行解决线程安全问题。</li>
<li>这种机制被称为：线程同步机制。</li>
<li>专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。</li>
</ul>
<p>怎么解决线程安全问题？ 使用“线程同步机制”。</p>
<p>线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。</p>
<p>说到线程同步这块，涉及到这两个专业术语：</p>
<ul>
<li><p>异步编程模型：</p>
<ul>
<li>线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型。其实就是：多线程并发（效率较高。）</li>
<li>异步就是并发。</li>
</ul>
</li>
<li><p>同步编程模型：</p>
<ul>
<li>线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。<br>  效率较低。线程排队执行。</li>
<li>同步就是排队。</li>
</ul>
</li>
</ul>
<p>实例变量：在堆中。<br>静态变量：在方法区。<br>局部变量：在栈中。</p>
<p>以上三大变量中：<br>局部变量永远都不会存在线程安全问题。因为局部变量不共享。（一个线程一个栈。）局部变量在栈中。所以局部变量永远都不会共享。</p>
<p>实例变量在堆中，堆只有1个。静态变量在方法区中，方法区只有1个。堆和方法区都是多线程共享的，所以可能存在线程安全问题。</p>
<p>局部变量+常量：不会有线程安全问题。<br>成员变量：可能会有线程安全问题。</p>
<p>如果使用局部变量的话：建议使用：StringBuilder。因为局部变量不存在线程安全问题。选择StringBuilder。StringBuffer效率比较低。</p>
<ul>
<li>ArrayList是非线程安全的。</li>
<li>Vector是线程安全的。</li>
<li>HashMap HashSet是非线程安全的。</li>
<li>Hashtable是线程安全的。</li>
</ul>
<h4 id="银行取钱模拟"><a href="#银行取钱模拟" class="headerlink" title="银行取钱模拟"></a>银行取钱模拟</h4><p>存在问题的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建账户对象，只建一个</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">act</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;act-001&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//创建两个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountThread</span>(act);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountThread</span>(act);</span><br><span class="line">        <span class="comment">//设置name</span></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程取款</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String actno; <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String actno, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getActno</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setActno</span><span class="params">(String actno)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        <span class="comment">//取款之前的余额</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="comment">//取款之后的余额</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - money;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里模拟一下网络延迟，一定会出问题-》两次的余额都是 5000</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新余额</span></span><br><span class="line">        <span class="comment">//t1执行到了这里，但是还没有来得及只从这行代码，t2线程进来withdraw方法了，此时一定出问题</span></span><br><span class="line">        <span class="built_in">this</span>.setBalance(after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//两个线程必须共享同一个账户对象</span></span><br><span class="line">    <span class="keyword">private</span> Account act;</span><br><span class="line">    <span class="comment">//通过构造方法传递过来账户对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountThread</span><span class="params">(Account act)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.act = act;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//run 方法的执行标识取款操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//取5000</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        act.withdraw(money);</span><br><span class="line">        System.out.println( Thread.currentThread().getName() + <span class="string">&quot;账户&quot;</span> + act.getActno() + <span class="string">&quot;取款&quot;</span> + money + <span class="string">&quot;成功， 余额为&quot;</span> + act.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了线程同步机制解决问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建账户对象，只建一个</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">act</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;act-001&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//创建两个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountThread</span>(act);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountThread</span>(act);</span><br><span class="line">        <span class="comment">//设置name</span></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程取款</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String actno; <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String actno, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getActno</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setActno</span><span class="params">(String actno)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actno = actno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        <span class="comment">//以下这几行代码必须时县城排队的，不能并发</span></span><br><span class="line">        <span class="comment">//一个线程把这里的代码全部执行结束之后，另一个线程才能进来</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        线程同步机制的语法：</span></span><br><span class="line"><span class="comment">        synchronized () &#123;</span></span><br><span class="line"><span class="comment">            //线程同步代码块</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        synchronized 后面小括号中的数据时相当关键的，这个数据必须是多线程共享的数据才能达到多线程排队。</span></span><br><span class="line"><span class="comment">        ()中写什么，要看你想让哪些线程同步</span></span><br><span class="line"><span class="comment">            假设t1、t2、t3、t4、t5，有5个线程，你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办？你一定要在()中写一个t1 t2 t3共享的对象。而这个对象对于t4 t5来说不是共享的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            这里的共享对象是：账户对象。</span></span><br><span class="line"><span class="comment">            账户对象是共享的，那么this就是账户对象吧！！！</span></span><br><span class="line"><span class="comment">            不一定是this，这里只要是多线程共享的那个对象就行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            在java语言中，任何一个对象都有“一把锁”，其实这把锁就是标记。（只是把它叫做锁。）</span></span><br><span class="line"><span class="comment">            100个对象，100把锁。1个对象1把锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            以下代码的执行原理？</span></span><br><span class="line"><span class="comment">                1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。</span></span><br><span class="line"><span class="comment">                2、假设t1先执行了，遇到了synchronized，这个时候自动找“后面共享对象”的对象锁，</span></span><br><span class="line"><span class="comment">                找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是</span></span><br><span class="line"><span class="comment">                占有这把锁的。直到同步代码块代码结束，这把锁才会释放。</span></span><br><span class="line"><span class="comment">                3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面</span></span><br><span class="line"><span class="comment">                共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，</span></span><br><span class="line"><span class="comment">                直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后</span></span><br><span class="line"><span class="comment">                t2占有这把锁之后，进入同步代码块执行程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                这样就达到了线程排队执行。</span></span><br><span class="line"><span class="comment">                这里需要注意的是：这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共享的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//synchronized (this)&#123; //正确</span></span><br><span class="line">        <span class="comment">//synchronized (obj) &#123; // 实例变量，只有一个，正确</span></span><br><span class="line">        <span class="comment">//synchronized (&quot;abc&quot;) &#123; // &quot;abc&quot;在字符串常量池当中。-&gt;所有线程都会同步，所以不行</span></span><br><span class="line">        <span class="comment">//synchronized (null) &#123; // 报错：空指针。</span></span><br><span class="line">        <span class="comment">//synchronized (obj2) &#123; // 这样编写就不安全了。因为obj2不是共享对象。是局部变量，不对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">            <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - money;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">//模拟网络延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//更新余额</span></span><br><span class="line">        <span class="comment">//t1执行到了这里，但是还没有来得及只从这行代码，t2线程进来withdraw方法了，此时一定出问题</span></span><br><span class="line">        <span class="built_in">this</span>.setBalance(after);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//两个线程必须共享同一个账户对象</span></span><br><span class="line">    <span class="keyword">private</span> Account act;</span><br><span class="line">    <span class="comment">//通过构造方法传递过来账户对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountThread</span><span class="params">(Account act)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.act = act;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//run 方法的执行标识取款操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//取5000</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        act.withdraw(money);</span><br><span class="line">        System.out.println( Thread.currentThread().getName() + <span class="string">&quot;账户&quot;</span> + act.getActno() + <span class="string">&quot;取款&quot;</span> + money + <span class="string">&quot;成功， 余额为&quot;</span> + act.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>synchronized可以写在实例方法上，如果出现在实例方法上，一定锁的是this，不能有其他对象了，不灵活</li>
<li>另外还有一个缺点：它出现在实例方法上的时候表示整个方法体都要同步，可能会无故扩大同步的范围，导致程序的执行效率变低，所以这种方式不常用。</li>
<li>写在实例方法上有什么优点：代码下的少了，节俭了。</li>
<li>如果共享的对象就是this，并且需要同步的代码块是整个方法体，建议使用这种方式。</li>
<li>同步代码块越小，效率越高</li>
<li>第一种：同步代码块 灵活 synchronized(线程共享对象){同步代码块;}</li>
<li>第二种：在实例方法上使用synchronized表示共享对象一定是this并且同步代码块是整个方法体。</li>
<li>第三种：在静态方法上使用synchronized表示找类锁。类锁永远只有1把。就算创建了100个对象，那类锁也只有一把。</li>
<li>对象锁：1个对象1把锁，100个对象100把锁。类锁：100个对象，也可能只是1把类锁。</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="一"><a href="#一" class="headerlink" title="一"></a>一</h5><p>面试题：doOther方法执行的时候需要等待doSome方法的结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个睡眠的作用是：为了保证t1线程先执行。</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass mc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyClass mc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mc = mc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t2&quot;</span>))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不需要，因为doOther()方法没有synchronized</p>
<h5 id="二"><a href="#二" class="headerlink" title="二"></a>二</h5><p>面试题：doOther方法执行的时候需要等待doSome方法的结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个睡眠的作用是：为了保证t1线程先执行。</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass mc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyClass mc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mc = mc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t2&quot;</span>))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要，因为doOther()方法有synchronized了</p>
<h5 id="三"><a href="#三" class="headerlink" title="三"></a>三</h5><p>面试题：doOther方法执行的时候需要等待doSome方法的结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc2);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个睡眠的作用是：为了保证t1线程先执行。</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass mc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyClass mc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mc = mc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t2&quot;</span>))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要，因为MyClass对象是两个，两把锁。</p>
<h5 id="四"><a href="#四" class="headerlink" title="四"></a>四</h5><p>面试题：doOther方法执行的时候需要等待doSome方法的结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc2);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//这个睡眠的作用是：为了保证t1线程先执行。</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass mc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyClass mc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mc = mc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t2&quot;</span>))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized出现在静态方法上是找类锁。</p>
<p>需要，因为静态方法是类锁，不管创建了几个对象，类锁只有1把。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁代码要会写。<br>一般面试官要求你会写。<br>只有会写的，才会在以后的开发中注意这个事儿。<br>因为死锁很难调试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t1和t2两个线程共享o1,o2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(o1,o2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(o1,o2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread1</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">        <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">        <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 在开发过程中最好不要嵌套使用</p>
<h4 id="怎么解决线程安全问题"><a href="#怎么解决线程安全问题" class="headerlink" title="怎么解决线程安全问题"></a>怎么解决线程安全问题</h4><p>是一上来就选择线程同步吗？synchronized<br>不是，synchronized会让程序的执行效率降低，用户体验不好。系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步机制。</p>
<p>第一种方案：尽量使用局部变量代替“实例变量和静态变量”。</p>
<p>第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）</p>
<p>第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。</p>
<h3 id="守护线程-定时器"><a href="#守护线程-定时器" class="headerlink" title="守护线程&#x2F;定时器"></a>守护线程&#x2F;定时器</h3><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>java语言中线程分为两大类：<br>一类是：用户线程<br>一类是：守护线程（后台线程）<br>其中具有代表性的就是：垃圾回收线程（守护线程）。</p>
<p>守护线程的特点：<br>一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。</p>
<p>注意：主线程main方法是一个用户线程。</p>
<p>守护线程用在什么地方呢？<br>每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，每到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p>
<p>设置为守护线程 t.setDaemon(true);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BakDataThread</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;备份数据的线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程之前，将线程设置为守护线程</span></span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程：主线程是用户线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BakDataThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + (++i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器的作用：间隔特定的时间，执行特定的程序。</p>
<p>每周要进行银行账户的总账操作。每天要进行数据的备份操作。</p>
<p>在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现：可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。（比较low）</p>
<p>在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。</p>
<p>在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用定时器指定定时任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建定时器对象</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">//Timer timer = new Timer(true); //守护线程的方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定定时任务</span></span><br><span class="line">        <span class="comment">//timer.schedule(定时任务, 第一次执行时间, 间隔多久执行一次);</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2020-03-14 09:34:30&quot;</span>);</span><br><span class="line">        <span class="comment">//timer.schedule(new LogTimerTask() , firstTime, 1000 * 10);</span></span><br><span class="line">        <span class="comment">// 每年执行一次。</span></span><br><span class="line">        <span class="comment">//timer.schedule(new LogTimerTask() , firstTime, 1000 * 60 * 60 * 24 * 365);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类方式</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// code....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; , firstTime, <span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个定时任务类</span></span><br><span class="line"><span class="comment">// 假设这是一个记录日志的定时任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 编写你需要执行的任务就行了。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(strTime + <span class="string">&quot;:成功完成了一次数据备份！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者和消费者模式"><a href="#生产者和消费者模式" class="headerlink" title="生产者和消费者模式"></a>生产者和消费者模式</h3><p>关于Object类中的wait和notify方法</p>
<ul>
<li>第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是Object类中自带的。wait方法和notify方法不是通过线程对象调用，不是这样的：t.wait()，也不是这样的：t.notify()..不对。</li>
<li>第二：wait()方法作用？Object o &#x3D; new Object();o.wait();<ul>
<li>表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。o.wait();方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态。</li>
</ul>
</li>
<li>第三：notify()方法作用？Object o &#x3D; new Object(); o.notify();<ul>
<li>表示：唤醒正在o对象上等待的线程。</li>
<li>还有一个notifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>使用wait方法和notify方法实现“生产者和消费者模式”</p>
<p>什么是“生产者和消费者模式”？</p>
<ul>
<li><p>生产线程负责生产，消费线程负责消费。</p>
</li>
<li><p>生产线程和消费线程要达到均衡。</p>
</li>
<li><p>这是一种特殊的业务需求，在这种特殊的情况下需要使用wait方法和notify方法。</p>
</li>
<li><p>wait和notify方法不是线程对象的方法，是普通java对象都有的方法。</p>
</li>
<li><p>wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。</p>
</li>
<li><p>wait方法作用：o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。</p>
</li>
<li><p>notify方法作用：o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。</p>
</li>
</ul>
<p>模拟这样一个需求：</p>
<ul>
<li>仓库我们采用List集合。List集合中假设只能存储1个元素。1个元素就表示仓库满了。如果List集合中元素个数是0，就表示仓库空了。保证List集合中永远都是最多存储1个元素。必须做到这种效果：生产1个消费1个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建1个仓库对象，共享的。</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 创建两个线程对象</span></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(list));</span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(list));</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;生产者线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;消费者线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一直生产（使用死循环来模拟一直生产）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 给仓库对象list加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size() &gt; <span class="number">0</span>)&#123; <span class="comment">// 大于0，说明仓库中已经有1个元素了。</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前线程进入等待状态，并且释放Producer之前占有的list集合的锁。</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 程序能够执行到这里说明仓库是空的，可以生产</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">                <span class="comment">// 唤醒消费者进行消费</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一直消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 仓库已经空了。</span></span><br><span class="line">                        <span class="comment">// 消费者线程等待，释放掉list集合的锁</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 程序能够执行到此处说明仓库中有数据，进行消费。</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">                <span class="comment">// 唤醒生产者生产。</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="sleep-1"><a href="#sleep-1" class="headerlink" title="sleep"></a>sleep</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于Thread.sleep()方法的一个面试题：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用sleep方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 问题：这行代码会让线程t进入休眠状态吗？</span></span><br><span class="line">            t.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒之后这里才会执行。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答案：</p>
<ul>
<li>在执行的时候还是会转换成：Thread.sleep(1000 * 5);</li>
<li>这行代码的作用是：让当前线程进入休眠，也就是说main线程进入休眠。</li>
<li>这样代码出现在main方法中，main线程睡眠。</li>
</ul>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JDBC是什么？</p>
<ul>
<li>Java Database Counnectivity（Java语言链接数据库）</li>
</ul>
<p>本质是什么？</p>
<ul>
<li>SUN公司制定的一套接口（interface）<ul>
<li>java.sql.* 这个包下的</li>
</ul>
</li>
<li>接口都有调用者&#x2F;实现者</li>
<li>面向接口调用&#x2F;面向接口写实现类，都属于面向接口编程</li>
</ul>
<p>为什么面向接口编程？</p>
<ul>
<li>解耦合，降低程序的耦合度，提高程序的扩展力</li>
<li>多态就是非常典型的面向抽象编程（不要面向具体过程编程）</li>
</ul>
<p>为什么制定这一套接口呢？</p>
<ul>
<li>因为每一个数据可以的底层实现原理都不一样（oracle&#x2F;mysql&#x2F;ms sqlserver）</li>
<li>每一个数据库产品都有自己独特的实现原理。</li>
</ul>
<p>开发的准备：如果是用文本编辑器开发，则需要配置classpath文件，用IDEA的时候，不需要</p>
<h2 id="API-主要成员变量"><a href="#API-主要成员变量" class="headerlink" title="API 主要成员变量"></a>API 主要成员变量</h2><p>JDBC API 主要功能：三件事，具体是通过以下类&#x2F;接口实现：</p>
<ul>
<li><p>DriverManager ： 管理jdbc驱动</p>
</li>
<li><p>Connection： 连接（通过DriverManager产生）</p>
</li>
<li><p>Statement（PreparedStatement） ：增删改查  （通过Connection产生 ）</p>
</li>
<li><p>CallableStatement  ： 调用数据库中的 存储过程&#x2F;存储函数  （通过Connection产生 ）</p>
</li>
<li><p>Result ：返回的结果集  （上面的Statement等产生 ）</p>
</li>
</ul>
<p>Connection产生操作数据库的对象：</p>
<ul>
<li><p>Connection产生Statement对象：createStatement()</p>
</li>
<li><p>Connection产生PreparedStatement对象：prepareStatement()</p>
</li>
<li><p>Connection产生CallableStatement对象：prepareCall();</p>
</li>
</ul>
<p>Statement操作数据库：</p>
<ul>
<li><p>增删改：executeUpdate()</p>
</li>
<li><p>查询：executeQuery();</p>
</li>
<li><p>ResultSet：保存结果集 select * from xxx</p>
</li>
<li><p>next():光标下移，判断是否有下一条数据；true&#x2F;false</p>
</li>
<li><p>previous():  true&#x2F;false</p>
</li>
<li><p>getXxx(字段名|位置):获取具体的字段值</p>
</li>
</ul>
<p>PreparedStatement操作数据库：</p>
<p>因为 public interface PreparedStatement extends Statement </p>
<p>所以</p>
<ul>
<li><p>增删改：executeUpdate()</p>
</li>
<li><p>查询：executeQuery();</p>
</li>
<li><p>赋值操作 setXxx();</p>
</li>
</ul>
<p>PreparedStatement与Statement在使用时的区别：</p>
<ol>
<li>Statement: sql executeUpdate(sql)</li>
<li>PreparedStatement: sql(可能存在占位符?) 在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql) executeUpdate() setXxx()替换占位符？</li>
</ol>
<p>推荐使用PreparedStatement：原因如下：</p>
<p>1.编码更加简便（避免了字符串的拼接）</p>
<p>2.提高性能(因为 有预编译操作，预编译只需要执行一次)</p>
<p>3.安全（可以有效防止sql注入）</p>
<p>JDBC编程六步</p>
<ol>
<li>注册驱动（作用：告诉Java程序，即将链接的是哪个品牌的数据库）</li>
<li>获取链接（表示JVM的进程和数据库进程之间的<strong>通道打开</strong>了，属于进程之间的通信，重量级的，使用完一定要关闭）</li>
<li>获取数据库操作对象（专门执行sql语句的对象）</li>
<li>执行SQL语句（DQL and DML）</li>
<li>处理查询结果集（只有当4执行的是select语句的时候，才有这个处理查询结果集）</li>
<li>释放资源（使用完资源之后一定要关闭资源）</li>
</ol>
<hr>
<h2 id="普通数据增删改查实例"><a href="#普通数据增删改查实例" class="headerlink" title="普通数据增删改查实例"></a>普通数据增删改查实例</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>向dept中添加一个职位‘人事部’，no为50，地址为北京</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mytest&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;333&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">            <span class="comment">//3.获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into dept(deptno, dname, loc) value(60, &#x27;renshi2&#x27;, &#x27;beijing1&#x27;)&quot;</span>;</span><br><span class="line">            <span class="comment">//专门执行DML语句的(insert delete update)</span></span><br><span class="line">            <span class="comment">//返回值是“影响数据库中的记录条数”</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">            System.out.print(count == <span class="number">1</span> ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">            <span class="comment">//不是select语句，不需要处理</span></span><br><span class="line">            <span class="comment">//6.释放资源，为了保证资源一定释放，在finally中关闭资源</span></span><br><span class="line">            <span class="comment">//从小到大依次关闭，分别对其try/catch</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭数据库连接，此处省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>删除一条数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实际开发中不建议把数据库的信息写死到java程序中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动， 通过反射机制，这种方式常用</span></span><br><span class="line">        <span class="comment">//因为参数是一个字符串，自负床可以写到.properties文件中</span></span><br><span class="line">        <span class="comment">//以下方法不接受返回值，因为我们只用它的加载动作</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取链接</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 获取数据库操作对象</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//4. 执行SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from dept where deptno = 50&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 未使select语句，所以不用处理查询结果集</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6. 释放资源</span></span><br><span class="line">           <span class="comment">// 关闭数据库连接，此处省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将链接数据库的所有信息配置到信息文件中"><a href="#将链接数据库的所有信息配置到信息文件中" class="headerlink" title="将链接数据库的所有信息配置到信息文件中"></a>将链接数据库的所有信息配置到信息文件中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实际开发中不建议把数据库的信息写死到java程序中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//使用资源绑定器</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">        <span class="comment">//String driver = bundle.getString(&quot;Driver&quot;);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动， 通过反射机制，这种方式常用</span></span><br><span class="line">        <span class="comment">//因为参数是一个字符串，所以可以写到.properties文件中</span></span><br><span class="line">        <span class="comment">//以下方法不接受返回值，因为我们只用它的加载动作</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取链接</span></span><br><span class="line">        conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//3. 获取数据库操作对象</span></span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//4. 执行SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into dept(deptno, dname, loc) value(50,&#x27;HumanResource&#x27;,&#x27;Beijing&#x27;)&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 未使select语句，所以不用处理查询结果集</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6. 释放资源</span></span><br><span class="line">   <span class="comment">// 关闭数据库连接，此处省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询结果集的处理"><a href="#查询结果集的处理" class="headerlink" title="查询结果集的处理"></a>查询结果集的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1. 注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 获取链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="comment">//3. 获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4. 执行sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select ename name ,sal s from emp&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                (int) executeUpdate(insert/delete/update), 返回执行成功的数量</span></span><br><span class="line"><span class="comment">                (ResultSet) executeQuery(select), 返回查询结果集</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            rs = stmt.executeQuery(sql); <span class="comment">//专门处理DQL语句的方法</span></span><br><span class="line">            <span class="comment">//5. 处理查询结果集</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">//光标指向的 行 有数据，取数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>); <span class="comment">//引号里面是列名字，也可以是第几列（从1开始）</span></span><br><span class="line">                <span class="comment">// 不管数据库中的数据类型是什么，都以String类型取出来</span></span><br><span class="line">                <span class="comment">//这里的列名是查询结果集中的列名，也就是重命名之后的列名</span></span><br><span class="line">                <span class="comment">//JDBC 中所有的数据从1开始而不是从0开始</span></span><br><span class="line">                <span class="type">Double</span> <span class="variable">sal</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">                System.out.println(ename + <span class="string">&quot; &quot;</span> + sal);</span><br><span class="line">                <span class="comment">//除了以String类型去除之外，也可以用其他类型取出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 6. 释放资源</span></span><br><span class="line">           <span class="comment">// 关闭数据库连接，此处省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户登录功能实现"><a href="#用户登录功能实现" class="headerlink" title="用户登录功能实现"></a>用户登录功能实现</h3><p>可以对sql脚本进行编辑</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: t_user                                                */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user</span><br><span class="line">(</span><br><span class="line">   id                   <span class="type">bigint</span> auto_increment,</span><br><span class="line">   loginName            <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   loginPwd             <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   realName             <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   <span class="keyword">primary</span> key (id)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user</span><br><span class="line">(</span><br><span class="line"> loginName, loginPwd, realName</span><br><span class="line">)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(</span><br><span class="line"> <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line"> <span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;杰克&#x27;</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line"> <span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;李四&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化界面</span></span><br><span class="line">        Map&lt;String,String&gt; userLoginInfo = initUI();</span><br><span class="line">        <span class="comment">// 验证用户名和密码</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginRst</span> <span class="operator">=</span> login(userLoginInfo);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(loginRst ? <span class="string">&quot;登录成功&quot;</span> : <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *用户登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userLoginInfo 用户登录信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户登录的结果 false失败，true成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(Map&lt;String, String&gt; userLoginInfo)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//打标记</span></span><br><span class="line">        <span class="comment">//JDBC代码</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="comment">//3.获取数据操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user where loginName = &#x27;&quot;</span> + userLoginInfo.get(<span class="string">&quot;loginName&quot;</span>) + <span class="string">&quot;&#x27; and loginPwd = &#x27;&quot;</span> + userLoginInfo.get(<span class="string">&quot;loginPwd&quot;</span>) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                loginSuccess = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException s) &#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException s)&#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException s)&#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loginSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化用户界面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户输入的用户名和密码等信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">initUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> s.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> s.next();</span><br><span class="line">        Map&lt;String, String&gt; userLoginInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginName&quot;</span>, username);</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginPwd&quot;</span>, password);</span><br><span class="line">        <span class="keyword">return</span> userLoginInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>用户名：asd</p>
<p>密码：asd’or’1’ &#x3D; ‘1</p>
<p>原因：用户输入的信息中含有sql语句的关键字，并且这些关键字参与sql语句的编译过程，导致sql的原意被扭曲。</p>
<p>解决：</p>
<p>只要用户提供的信息不参与SQL语句的编译过程，问题就解决了。即使用户提供的信息中含有SQL语句的关键字，但是没有参与编译，不起作用，要想用户信息不参与SQL语句的编译，那么必须使用java.sql.PreparedStatement.<br>这个接口继承了java.sql.Statement,是预编译的数据库操作对象，原理：预先对SQL语句的框架进行编译，然后再给SQL语句传值。</p>
<p>对比Statement和PerparedStatement：</p>
<ul>
<li>Statement存在SQL注入问题，preparedstatement解决了SQL注入问题。</li>
<li>Statement是编译一次执行一次。preparedstatement是编译一次，可执行多次。</li>
<li>PreparedStatement效率较高一些。</li>
<li>PreparedStatement会在编译阶段做类型的安全检查。</li>
</ul>
<p>综上所述：Preparedstatement使用较多。只有极少数的情况下需要使用statement</p>
<p>什么情况下必须使用statement呢？</p>
<ul>
<li>业务方面要求必须支持SQL注入的时候。需要进行SQL语句的拼接的时候。</li>
<li>Statement支持SQL注入，凡是业务方面要求是需要进行SQL语句拼接的，必须使用Statement</li>
</ul>
<h4 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化界面</span></span><br><span class="line">        Map&lt;String,String&gt; userLoginInfo = initUI();</span><br><span class="line">        <span class="comment">// 验证用户名和密码</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginRst</span> <span class="operator">=</span> login(userLoginInfo);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(loginRst ? <span class="string">&quot;登录成功&quot;</span> : <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *用户登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userLoginInfo 用户登录信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户登录的结果 false失败，true成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(Map&lt;String, String&gt; userLoginInfo)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//打标记</span></span><br><span class="line">        <span class="comment">//JDBC代码</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//这里使用PS预编译的数据库操作对象</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="comment">//3.获取预编译的数据操作对象</span></span><br><span class="line">            <span class="comment">// ？ 不能用单引号括起来</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user where loginName = ? and loginPwd = ?&quot;</span>; <span class="comment">// 先写上SQL语句的框架，其中一个？标识一个占位符</span></span><br><span class="line">            <span class="comment">//程序执行到这步，会发送SQL语句的框架给DBMS，然后DBMS进行sql语句的预编译</span></span><br><span class="line">            ps = conn.prepareStatement(sql);<span class="comment">//这里不用传入sql语句参数了</span></span><br><span class="line">            <span class="comment">// 给 ‘？’ 传值 第一个问号下标是1，第二个是2，JDBC所有下标从1开始</span></span><br><span class="line">            ps.setString(<span class="number">1</span>, userLoginInfo.get(<span class="string">&quot;loginName&quot;</span>));<span class="comment">//自动添加上单引号</span></span><br><span class="line">            ps.setString(<span class="number">2</span>, userLoginInfo.get(<span class="string">&quot;loginPwd&quot;</span>));</span><br><span class="line">            <span class="comment">//4.执行ps对象的sql</span></span><br><span class="line">            rs = ps.executeQuery(); <span class="comment">//这里不用传入参数了</span></span><br><span class="line">            <span class="comment">//5.处理结果集</span></span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                loginSuccess = <span class="literal">true</span>; <span class="comment">//登录成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException s) &#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ps != <span class="literal">null</span>)&#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException s)&#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException s)&#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loginSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化用户界面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户输入的用户名和密码等信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">initUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> s.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> s.next();</span><br><span class="line">        Map&lt;String, String&gt; userLoginInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginName&quot;</span>, username);</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginPwd&quot;</span>, password);</span><br><span class="line">        <span class="keyword">return</span> userLoginInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="comment">//3.获取预编译的数据操作对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into dept(dname, loc, deptno) values(?, ?, ?)&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;HR&quot;</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">70</span>);</span><br><span class="line">            <span class="comment">//4.执行ps对象的sql</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="银行转账业务"><a href="#银行转账业务" class="headerlink" title="银行转账业务"></a>银行转账业务</h3><p>JDBC事务默认自动提交，</p>
<p>关闭自动提交？  conn.setAutoCommit(false);</p>
<p>提交事务 conn.commit();</p>
<p>回滚事务 conn.rollback();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="comment">//3.获取预编译的数据操作对象</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">//关闭自动提交</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set balance = ? where act = ?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.执行ps对象的sql</span></span><br><span class="line">            <span class="comment">//给 ？ 传值</span></span><br><span class="line">            ps.setDouble(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span>  <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">            ps.setDouble(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">            ps.setString(<span class="number">2</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">            count  += ps.executeUpdate();</span><br><span class="line">            System.out.println(count == <span class="number">2</span> ? <span class="string">&quot;转账成功&quot;</span> : <span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">            conn.commit(); <span class="comment">//提交事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">//回滚事务</span></span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6.释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC工具类的封装"><a href="#JDBC工具类的封装" class="headerlink" title="JDBC工具类的封装"></a>JDBC工具类的封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工具类中的构造方法是私有的</span></span><br><span class="line"><span class="comment">     * 因为工具类中的方法都是静态的，不需要new对象，直接类名调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DBUtil</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块在类加载时执行，并且只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException 连接异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn 链接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps 操作对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs 查询结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException s) &#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ps != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException s) &#123;</span><br><span class="line">                s.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基于工具类的模糊查询"><a href="#基于工具类的模糊查询" class="headerlink" title="基于工具类的模糊查询"></a>基于工具类的模糊查询</h3><p>查询员工中名字有A的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取链接</span></span><br><span class="line">            conn = DBUtil.getConnection();</span><br><span class="line">            <span class="comment">//3.获取预编译的数据操作对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select ename from emp where ename like ?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;_A%&quot;</span>);</span><br><span class="line">            <span class="comment">//4.执行ps对象的sql</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            DBUtil.close(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="存储过程与存储函数调用"><a href="#存储过程与存储函数调用" class="headerlink" title="存储过程与存储函数调用"></a>存储过程与存储函数调用</h2><p>CallableStatement:调用 存储过程、存储函数</p>
<p>connection.prepareCall(参数：存储过程或存储函数名)</p>
<p>参数格式：</p>
<p>存储过程（无返回值return，用out参数替代）：</p>
<p>​	{ call  存储过程名(参数列表) }</p>
<p>存储函数（有返回值return）：</p>
<p>​	{ ? &#x3D; call  存储函数名(参数列表) }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure addTwoNum ( num1  in number,num2  in number,result out number )  as</span><br><span class="line">begin</span><br><span class="line">	result := num1+num2 ;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure>

<p>强调：</p>
<p>如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID</p>
<p>通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener</p>
<p>JDBC调用存储过程的步骤：</p>
<p>a. 产生 调用存储过程的对象（CallableStatement） cstmt &#x3D; 	connection.prepareCall(   “…” ) ;</p>
<p>b. 通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);</p>
<p>c. 通过 registerOutParameter(…)处理输出参数类型</p>
<p>d.cstmt.execute()执行</p>
<p>e.接受 输出值（返回值）getXxx()</p>
<p>调存储函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create or replace function addTwoNumfunction ( num1  in number,num2  in number)  -- 1 + 2 </span><br><span class="line">return number</span><br><span class="line">as</span><br><span class="line">	result number ;	</span><br><span class="line">begin</span><br><span class="line">	result := num1+num2 ;</span><br><span class="line">	return result ;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure>

<p>JDBC调用存储函数：与调存储过程的区别：<br>在调用时，注意参数：”{? &#x3D;  call addTwoNumfunction	(?,?) }”</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>首先在数据库中创建存过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> ADDNUM(num1 <span class="keyword">in</span> number, num2 <span class="keyword">in</span> number, rst <span class="keyword">out</span> number) <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">-- 计算两个数的和，给第三个值</span></span><br><span class="line">  rst :<span class="operator">=</span> num1 <span class="operator">+</span> num2; </span><br><span class="line"><span class="keyword">END</span> ADDNUM;</span><br></pre></td></tr></table></figure>

<p>然后进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 存储过程返回值的对象</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">callableStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;</span>, <span class="string">&quot;c##libmanager&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">    callableStatement = conn.prepareCall(<span class="string">&quot;&#123;call addNum(?, ?, ?)&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第一个和第二个数</span></span><br><span class="line">    callableStatement.setInt(<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">    callableStatement.setInt(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 设置第三个参数的输出类型</span></span><br><span class="line">    callableStatement.registerOutParameter(<span class="number">3</span>, Types.INTEGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用存储过程， 执行的是num1 + num2</span></span><br><span class="line">    <span class="comment">// 这句话之前处理的是输入值， 这句话之后是输出值</span></span><br><span class="line">    callableStatement.execute();</span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rst</span> <span class="operator">=</span>  callableStatement.getInt(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 输出计算结果</span></span><br><span class="line">    System.out.println(rst);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>在数据库中创建函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> addNum </span><br><span class="line">(</span><br><span class="line">  NUM1 <span class="keyword">IN</span> NUMBER  </span><br><span class="line">, NUM2 <span class="keyword">IN</span> NUMBER  </span><br><span class="line">) <span class="keyword">RETURN</span> NUMBER <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> num1 <span class="operator">+</span> num2;</span><br><span class="line"><span class="keyword">END</span> addNum;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 存储过程返回值的对象</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">callableStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;</span>, <span class="string">&quot;c##libmanager&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">    callableStatement = conn.prepareCall(<span class="string">&quot;&#123;? = call addNum(?, ?)&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第一个和第二个数</span></span><br><span class="line">    callableStatement.setInt(<span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">    callableStatement.setInt(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 设置第三个参数的输出类型</span></span><br><span class="line">    callableStatement.registerOutParameter(<span class="number">1</span>, Types.INTEGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数， 执行的是num1 + num2</span></span><br><span class="line">    <span class="comment">// 这句话之前处理的是输入值， 这句话之后是输出值</span></span><br><span class="line">    callableStatement.execute();</span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rst</span> <span class="operator">=</span> callableStatement.getInt(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 输出计算结果</span></span><br><span class="line">    System.out.println(rst);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="大类型数据存储与读取实例"><a href="#大类型数据存储与读取实例" class="headerlink" title="大类型数据存储与读取实例"></a>大类型数据存储与读取实例</h2><p>处理CLOB&#x2F;BLOB类型 - 处理稍大型数据：</p>
<p>a.存储路径	E:\JDK_API_zh_CN.CHM	通过JDBC存储文件路径，然后 根据IO操作处理</p>
<p>例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式 “E:\JDK_API_zh_CN.CHM” 存储到数据库中</p>
<p>获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO	</p>
<p>b.</p>
<p>CLOB：大文本数据 （小说-&gt;数据）</p>
<p>BLOB：二进制</p>
<p>clob:大文本数据   字符流 Reader Writer</p>
<p>存:</p>
<ol>
<li><p>先通过pstmt 的? 代替小说内容 （占位符）</p>
</li>
<li><p>再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型</p>
</li>
</ol>
<p>取：</p>
<ol>
<li>通过Reader reader &#x3D; rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中</li>
<li>将Reader通过Writer输出即可。</li>
</ol>
<p>blob:二进制  字节流 InputStream OutputStream</p>
<p>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)   </p>
<h3 id="大文本存储"><a href="#大文本存储" class="headerlink" title="大文本存储"></a>大文本存储</h3><p>存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into mynovel values(?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// c.发送sql，执行(增删改、查)</span></span><br><span class="line">pstmt = connection.prepareStatement(sql);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\all.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( file) ;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>( in   ,<span class="string">&quot;UTF-8&quot;</span>) ;<span class="comment">//转换流 可以设置编码</span></span><br><span class="line">pstmt.setCharacterStream(<span class="number">2</span>, reader,  (<span class="type">int</span>)file.length());</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span>pstmt.executeUpdate() ;</span><br><span class="line"><span class="comment">// d.处理结果</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">	System.out.println(<span class="string">&quot;操作成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>



<p>读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select NOVEL from mynovel where id = ? &quot;</span>;</span><br><span class="line"><span class="comment">// c.发送sql，执行(查)</span></span><br><span class="line">pstmt = connection.prepareStatement(sql);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">rs = pstmt.executeQuery() ;</span><br><span class="line"><span class="comment">//setXxxx getXxxx      setInt  getInt</span></span><br><span class="line"><span class="keyword">if</span>(rs.next())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> rs.getCharacterStream(<span class="string">&quot;NOVEL&quot;</span>) ;</span><br><span class="line">	<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/小说.txt&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">100</span>] ;</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(  (len = reader.read(chs)) !=-<span class="number">1</span> ) &#123;</span><br><span class="line">		writer.write( chs,<span class="number">0</span>,len  );</span><br><span class="line">	&#125;</span><br><span class="line">	writer.close();</span><br><span class="line">	reader.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="音乐存储"><a href="#音乐存储" class="headerlink" title="音乐存储"></a>音乐存储</h3><p>存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into mymusic values(?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// c.发送sql，执行(增删改、查)</span></span><br><span class="line">pstmt = connection.prepareStatement(sql);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\luna.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file );</span><br><span class="line">pstmt.setBinaryStream(<span class="number">2</span>,in ,(<span class="type">int</span>)file.length()  );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span>pstmt.executeUpdate() ;</span><br><span class="line"><span class="comment">// d.处理结果</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">	System.out.println(<span class="string">&quot;操作成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select music from mymusic where id = ? &quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// c.发送sql，执行(查)</span></span><br><span class="line">pstmt = connection.prepareStatement(sql);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">rs = pstmt.executeQuery() ;</span><br><span class="line"><span class="keyword">if</span>(rs.next())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> rs.getBinaryStream(<span class="string">&quot;music&quot;</span>) ;</span><br><span class="line">	<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/music.mp3&quot;</span>) ;</span><br><span class="line">	</span><br><span class="line">	<span class="type">byte</span>[] chs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>] ;</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(  (len = in.read(chs)) !=-<span class="number">1</span> ) &#123;</span><br><span class="line">		out.write( chs,<span class="number">0</span>,len  );</span><br><span class="line">	&#125;</span><br><span class="line">	out.close();</span><br><span class="line">	in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2020-07-05</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2020/07/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/'>笔记 | 正则表达式</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2020/06/12/HTML/">笔记 | HTML</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
             

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>Change And Challenge</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>