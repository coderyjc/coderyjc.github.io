---
title: '笔记 | JavaSE'
date: 2020-07-05 10:09:24
tags:
---

# Java基础知识

## Java开发环境

### Java语言的特性

#### 1.简单性（相对于C++）

在Java语言当中真正操作内存的是JVM（Java Virtual Machine）Java虚拟机

所有的java程序都是运行在Java虚拟机当中的, Java语言**屏蔽了指针概念**，程序员*不能直接操作指针*，或者说程序员不能直接操作内存。这种方式有优点也有缺点：

优点：不容易导致内存泄漏

缺点：效率问题(但是可以通过更换更强大的硬件来解决)

#### 2.完全面向对象

面向对象三大特性: 封装，继承，多态

面向对象更容易让人理解，人类通常是以对象的方式认知世界的。

#### 3.健壮性

Java中有一种机制：自动垃圾回收机制（GC机制 Garbage Collection）

Java 程序启动了一个单独的垃圾回收线程，时刻监测内存使用情况，在特定时机会回收/释放垃圾数据，这样会让内存时刻处于最好的状态, 关于这个机制, 我们会在Java进阶篇中讲解.

相对于C语言来说，java语言是健壮的, 因为Java不容易导致内存的泄漏, C++或者C语言需要程序员自己分配内存, 在使用不当时很容易导致内存泄漏。

> 内存泄漏: 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。(来自百度百科: [内存泄漏](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/6181425))

**JVM**负责调度GC机制。程序员不需要干涉。

缺点：内存无法得到及时的清理, (但是我们可以手动调用清理机制)

#### 4.java完美支持多线程并发。

#### 5.可移植性/跨平台

java语言只要编写一次，可以做到到处运行。

例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linux操作系统上，同样也可以运行到MaC OS上面。

一次编写，到处运行。（平台改变了，程序不需要改。）

JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？

- 优点：一次编写到处运行，可以**跨平台**。
- 缺点：麻烦。对于运行java程序来说必须先有一个JVM，也就是需要安装JRE。

### JDK、JRE、JVM的区别

- JDK（Java Development Kit）:Java开发工具箱

- JRE（Java Runtime Environment，Java 运行环境）:java运行环境

- JVM（Java Virtual Machine）:java虚拟机

- JDK包括JRE，JRE包括JVM。

JVM是不能独立安装的。JRE和JDK都可以独立安装。

安装JDK的时候，JRE就自动安装了，同时JRE内部的JVM也就自动安装了。安装JRE的时候，JVM也就自动安装了。

问题：假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？

- 只是把项目跑起来的话，只需要安装JRE就行了。

问题：为什么安装JDK的时候会自带一个JRE？

- 因为开发完程序之后，要运行这个程序，让这个程序运行起来，需要JRE，所以JDK安装的时候内部自带一个JRE。

Java体系的技术被划分为三大块：

- JavaSE：标准版
- JavaEE：企业版
- JavaME：微型版

### 对Java的加载与执行的理解

java程序从编写到最终运行经历了哪些过程？

java程序非常重要的两个阶段：

- 编译阶段
- 运行阶段

注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。（不同的操作系统上编译生成的字节码也是一样的）

java代码这种普通文本被称为：java源代码。（你编写的代码是源代码）源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。

编译阶段和运行阶段可以在不同的操作系统上完成吗？

在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行**完全可以**，因为Java是跨平台的。可以做到一次编写到处运行。

java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？

**完全可以**执行，因为<u>源代码不参与程序的执行过程</u>。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。

- 放源代码的文件扩展名必须是：xxx.java
- 并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class
- .java文件就是源文件，这个文件中编写源代码。
- .class文件就是字节码文件，这个文件是编译源代码而得到的。
- 1个java源文件是可以编译生成多个class文件的。
- 最终运行的是class文件。

问题：字节码文件是二进制文件吗？

字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。

java程序从开发到最终运行经历了什么？

- 编译期：（可以在windows上）
	- 第一步：在硬盘的某个位置（随意），新建一个xxx.java文件
	- 第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件
	- 第三步：在xxx.java文件中编写“符合java语法规则的”源代码。
	- 第四步：保存（一定要将xxx.java文件保存一下）
	- 第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。
	- 第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）
- 运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）
	- 第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）
	- 第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码
	- 第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）
	- 第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和
	硬件进行交互。

注意：在以上的过程中，需要使用两个非常重要的命令？

- javac 命令，负责编译
- java 命令，负责运行

xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。

源文件中编写的代码叫做：源代码。

以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？

- 新建java文件
- 打开java文件
- 写java源代码
- 保存
- javac命令编译
- java命令运行

编写、编译、运行

### Hello World

第一步：安装文本编辑器

第二步：安装JDK（先下载JDK）安装JDK13，直接下一步就行。

JDK13安装的时候内置了一个JRE，独立于JDK之外的JRE并没有生成。对于java13来说，如果你希望生成一个独立于JDK之外的JRE的话需要执行特殊的命令。

注意：
JDK8安装的时候，不仅JDK内置了一个JRE，而且还会在JDK目录之外独立的生成一个单独的JRE。（以前低版本的时候，JRE实际上是有2个。）一个是JDK内置的，一个是独立于JDK之外的。

JDK的bin目录下有：

- javac.exe 负责编译
- java.exe 负责运行

第三步：写代码

第四步：编译

第五步：运行

#### 编译

怎么编译？使用什么命令？这个命令怎么用？

- 需要使用的命令是：C:\Program Files\Java\jdk-13.0.2\bin\javac.exe
- 这个命令需要先测试一下，打开DOS命令窗口，看看javac命令是否可用。

C:\Users\Administrator>javac

'javac' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这说明：windows操作系统没有发现“javac.exe”命令在哪里。windows操作系统没有找到javac.exe文件在哪。

为什么ipconfig、ping等命令可以使用呢？为什么javac用不了？

- 我们发现windows操作系统中有这样一个环境变量，名字叫做：`path`，并且发现`path`环境变量的值是：
  `C:\Windows\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\`我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe

注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。

将path环境变量中的:C:\windows\system32; 删除之后再测试：:\Users\Administrator>ipconfig
'ipconfig' 不是内部或外部命令，也不是可运行的程序或批处理文件。

配置环境变量path的步骤：

- 桌面计算机上右键-->属性-->高级系统设置-->环境变量

怎么修改path环境变量？

- 找到path，鼠标双击！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。

让javac.exe能用，我们配置哪个路径到path中？将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。

注意：

- 环境变量包括“系统变量”和“用户变量”
- 系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
- 用户变量：范围比较小，这个变量只是作用于当前用户。

怎么查看编译器版本？

```bash
C:\Users\Administrator><u>javac -version</u>
javac 13.0.2
```

怎么查看java虚拟机的版本？

```bash
C:\Users\Administrator><u>java -version</u>
java version "13.0.2" 2020-01-14
Java(TM) SE Runtime Environment (build 13.0.2+8)
Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
```

**问题1**：path环境变量的作用是什么？

path环境变量的作用就是给windows操作系统指路的。<u>告诉windows操作系统去哪里找这个命令文件。</u>path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。

path=A;B;C;D......path是环境变量的名字。A;B;C;D......是环境变量path的值。

**问题2**：path环境变量是java中的机制，还是windows操作系统中的机制？path环境变量是隶属于java的吗？path环境变量和java有关系吗？

path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。

#### 运行

运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。

假设该文件的名字叫做：HelloWorld.class

那么HelloWorld被称为类名；如果文件名是Test.class，那么Test就是一个类名。

怎么运行，使用哪个命令？使用JDK的bin目录下的：java.exe命令来运行。

先在DOS命令窗口中测试java.exe这个命令是否可用！java -version

"java.exe"这个命令怎么用，语法格式是什么？java 类名

java HelloWorld.class 对不对？不对！正确的写法是：java HelloWorld

千万千万要注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”，因为java命令后面跟的不是文件，是一个“类名”。

对于这个类：Test.class ，应该：java Test

#### java HelloWorld”的执行过程以及原理

D:\course\JavaProjects\02-JavaSE\chapter01>java HelloWorld 敲完回车，都发生了什么？？？？？

第一步：

会先启动**JVM**（java虚拟机）

第二步：

JVM启动之后，JVM会去启动“类加载器classloader”

类加载器的作用：

- 加载类的。本质上类加载器负责去硬盘上**找“类”对应的“字节码”文件**。
- 假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。
- 假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。
  .......

第三步：

类加载器如果在硬盘上找不到对应的字节码文件，会报错，报什么错？

- 错误: 找不到或无法加载主类

类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000...”这种二进制码，操作系统执行二进制码和硬件交互。

默认情况下，类加载器去硬盘上找“字节码”文件的时候，默认从哪找？

- 默认情况下类加载器（classloader）会从当前路径下找。

能不能给类加载器指定一个路径，让类加载器去指定的路径下加载字节码文件？

- 答案：可以的。但是我们需要设置一个环境变量，叫做：classpath

classpath是一个环境变量，是干啥的？

- 答案：是给“类加载器”指路的。

classpath环境变量**不属于**windows操作系统，classpath环境变量**隶属于java**

classpath环境变量是java特有的。

classpath=A路径;B路径;C路径.....

classpath是一个变量名，A路径;B路径;C路径.....是变量值

我们把classpath配置一下，这个环境变量在windows中没有，需要新建。

`计算机-->右键-->属性-->高级系统设置-->环境变量-->新建...`

注意：变量名不能随意写：大小写无所谓，但必须叫做：classpath

我目前是随意配置的：（重启CMD）classpath=D:\course

非常重要的一个特点，必须记住：配置了classpath=D:\course之后，类加载器只会去D:\course目录下找“xxx.class”文件，不再从当前路径下找了。

到目前为止：classpath环境变量不需要配置。但你必须理解classpath环境变量是干什么的！

你一定要理解classpath环境变量的作用是什么？

- 是给类加载器指路的。
- 在没有配置环境变量classpath的时候，默认从当前路径下加载。
- 如果配置了环境变量classpath的话，就只能从指定的路径下加载了。

path java_home classpath，这3个环境变量path需要配置，后面两个暂时不配置。


在高版本的JDK当中，有这样的一个新特性，可以直接这样一步到位：

java x/y/z/xxx.java

java后面直接加java源文件的路径。

这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。

#### 对于第一个程序的解释

```java
public class HelloWorld{ //类体开始
    //public：公开的
    //class：一个类
    //HelloWorld：类名
    //表示一个共有的类HelloWorld

    public static void main(String[] args){ //方法体开始
        //整个这一块的代码被称为：main方法（程序的入口，sUN公司java语言规定的）
        //也就是说：JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序不能执行
        //main方法也可以叫做主方法。
        //注意：方法必须放到类体中，不能放到类体外面。
        System.out.print("Hello "); //作用：向控制台输出一句话
        //如果println里面的事字符串，就应该用英文创引号括起来
        //
        System.out.println("World!");
    } //方法体结束

}//类体结束

//----------------------------------------------------------------------

//以下程序可以编译通过，但是无法运行，符合语法规则。

public class Test2{
}

/*
>java Test2
错误: 在类 Test2 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/

//---------------------------------------------------------------------

/*
没有语法错误，没有入口，能够编译通过，但是不能运行，因为没有main方法。

错误: 在类 Test3 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/
public class Test3{
    static void main(String[] args){
    
    }
}

//---------------------------------------------------------------------

public class Test4{
	// 注意：args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动
	public static void main(String[] fdsafdsafdsafdsa){
		System.out.println("hello world");
	}
}

//---------------------------------------------------------------------

// 以下程序符合java语法规则吗？不符合！
// 不是不运行，是编译报错。编译过不去，运行肯定不行。

public class Test5{

	// 类体当中应该是方法，而不是直接的java语句
	// 这里可以写吗？不可以！
	System.out.println("hello1");
	
	// 主方法，入口
	public static void main(String[] args){
	
	}

	// 这里可以写吗？不可以！
	System.out.println("hello2");
}

//---------------------------------------------------------------------

// main方法中什么也不写行吗？可以！
// 以下程序编译和运行可以吗？可以！
public class Test6{
	// 入口
	public static void main(String[] args){
	}
}

//---------------------------------------------------------------------

public class Test7{
	
	public static void main(String[] args){

		// 这个不加双引号行吗？ 可以，因为它是数字。
		System.out.println(100);

		// 是数字，加双引号行吗？
		System.out.println("100");

		// 以上性质一样吗？不一样：一个是字符串，一个是数字。
		// 但最终输出到控制台上一个样子，没啥区别。

		// 这里扩展一下：对于数字来说能进行加减乘除吗？
		// + - * / 能用吗 ？ 都可以！
		System.out.println(100 + 200); // 300
		System.out.println(200 - 100); // 100
		System.out.println(200 * 100); // 20000
		System.out.println(200 / 100); // 2
	}
}

class A{

}
class B{

}
class C{

}
class D{

} //编译成功并且生成了 四个类 A.class B.class C.class D.class
/*
	1、这个内容没有为什么，只能经过测试，然后根据测试结果进行记忆。

	2、第一个结论？
		一个java源文件中可以定义多个class。
	
	3、第二个结论？
		public的类不是必须的。可以没有。

	4、第三个结论？
		在源文件中只要有一个class的定义，那么必然会对应生成一个class文件。
	
	5、第四个结论？
		public的类可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。
	
	6、第五个结论？
		public的类有也只能有1个。
*/
class A{

}

/*
	Test8.java:20: 错误: 类 B 是公共的, 应在名为 B.java 的文件中声明
	public class B{
			 ^
	1 个错误
*/
/*
public class B{

}
*/

// 如果定义public的类你只能这样写
public class Test8{
}

class C{

}

class D{

}

//错误: 类重复: Test8
/*
public class Test8{
}
*/

//---------------------------------------------------------------------

// 编译通过了
// 能执行吗？
// 想从哪个入口进去执行，你就加载哪个类就行了！
// 例如：java T1
// 例如：java T2

// 测试不代表以后就这样写，一般一个软件的执行入口是一个。不会出现多个的。
// 以下只是一个测试罢了。
class T1{
	// 想从这个入口进去执行怎么办？java T1
	public static void main(String[] args){
		System.out.println("T1.....");
	}
}

class T2{
	// 想从这个入口进去执行怎么办？java T2
	public static void main(String[] args){
		System.out.println("T2.....");
	}
}
```

```java
/**
javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。
*/
```

### Tips

- 终止程序用System.exit()  方法
- 函数调用：object.method(parameters)

## 标识符与关键字

### 标识符

规则1：标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号（比如空格）。

规则2：标识符不能以数字开头

规则3：关键字不能做标识符。例如：public class static void 这些蓝色的字体都是关键字，关键字是不能做标识符的。

规则4：标识符是严格区分大小写的。大写A和小写a不一样。

规则5：标识符理论上是没有长度限制的。

```java
public class BiaoShiFuTest{
	// main是一个方法的名称，属于标识符
	// 但是这个标识符不能修改，因为这个main是SUN固定死的。
	public static void main(String[] args){
	}

	//doSome是一个方法名，可以改成其他的名字
	public static void doSome(){
		// k是一个变量名
		int k = 100;
		// nianLing 是一个变量名
		int nianLing = 20;
	}
}

```

---

```java
/*
	class 123ABC{
	}

*/
```

以上代码编译报错，错误信息是：

- 错误: 需要<标识符>

- 错误原因：编译器检测到class这个单词，那么编译器会从class这个单词后面找类名，而类名是标识符，编译器找了半天没有找到标识符，因为123ABC不是标识符，所以编译器提示的错误信息是：需要<标识符>

解决办法：将123ABC修改为合法的标识符。

```java

class Y123ABC{
}

```

---

```java
class Hello World{
}
```

类名是标识符，标识符“中”不能有空格

编译器错误信息是：

- 错误: 需要'{'
- 编译器检测到class，然后找class后面的标识符，编译器找到了一个合法的标识符叫做“Hello”，然后编译器继续往后找“{”，结果没有找到“{”，所以报错了。

解决办法：

- 办法1：是把World删除
- 办法2：把空格删除

```java
class Hello{
}

class HelloWorld                   {
}

class _A{
}

class _$1Aa你{
}
```


>题目：
>
>创建一个java文件，起名 123.java可以吗？
>
>	可以，完全可以，在windows操作系统中文件名叫做：123.java 没毛病。
>
> 123其实并不是标识符。只是一个文件名。
>
> 只不过在123.java文件中无法定义public的类。
	

标识符除了命名规则之外，还有命名规范：

1、命名规则和命名规范有什么区别？

- 命名规则是语法，不遵守就会编译报错。

- 命名规范只是说，大家尽量按照统一的规范来进行命名，不符合规范也行，代码是可以编译通过的，但是你的代码风格和大家不一样，这个通常也是不允许的。

规则类似于现实世界中的法律。规范类似于现实世界中的道德。

统一按照规范进行的话，代码的可读性很好。	代码很容易让其它开发人员理解。

2、具体的命名规范是哪些？

规范1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）

规范2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低...）驼峰有利于单词与单词之间很好的进行分隔,	BiaoShiFuTest，这个很好，一眼就能看出来是4个单词。

规范3：类名、接口名有特殊要求: 类名和接口名首字母大写，后面每个单词首字母大写。StudentTest、UserTest ，这是类名、接口名。

规范4：变量名、方法名有特殊要求。

- 变量名和方法名首字母小写，后面每个单词首字母大写。nianLing（NianLing这样就不符合了。）mingZi（MingZi这样也不符合了。）

规范5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。

- USER_AGE ：用户年龄

- MATH_PI：固定不变的常量3.1415926.....

```java
public class IdentifierTest{
	public static void main(String[] args){
		// 主要看两个汉语拼音，可读性很强。
		// nianLing和mingZi都是黑色字体的标识符。
		int nianLing = 20;
		String mingZi = "zhangsan";
	}
}
```


### 关键字

什么是关键字？在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。

切记：java语言中的所有关键字都是全部小写。注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。

### Tips

- java 中整型的范围与运行代码的机器无关

- 从java7开始，加上前缀0b或者0B就可以写二进制数，比如0b10100

- 还可以为数字加上下划线，如1_0000_0000,等价于100000000

- 在C/C++中，int和long等类型的大小与平台直接相关，int型在16位的平台上占用2字节的大小，在32位的平台上占用4字节的大小，在Java中，占用的大小是固定的，与平台无关。

- Java中没有任何的无符号整型

- Java无法精确打印出2.0-1.1的结果的原因（0.89999999而不是0.9）

  - 浮点数采用二进制数表示，但是二进制系统中无法精确的表示分数1/10

- 强烈建议不要使用char类型，除非确实需要处理UTF-16的代码单元

- 不提倡在一行中声明多个变量，逐一声明变量可以提高程序的可读性

## 变量与数据类型

### 变量

字面量：字面量就是数据、数据就是字面量、是一个东西。在java语言中“数据”被称为“字面量”。

```
10 100 123 ：整型
1.34 3.14 2.0：浮点型
true false ：布尔型
'a' '国'：字符型
"a" "abc"  "国" "中国"：字符串型
10：整数，是一个数字
"10"：它不是数字，是一个字符串，或者说，它属于“文字类”的。性质完全不同，在计算机中的对应的二进制码也是完全不同的。
```

其中字符型和字符串型都是描述了现实世界中的文字，需要注意的是：

- 所有的字符型只能使用单引号括起来。

- 所有的字符串型只能使用双引号括起来。

- 字符型一定是单个字符才能成为“字符型”	

在语法级别上怎么区分字符型和字符串型？

- 主要看是双引号还是单引号。

- 单引号的一定是字符型。

- 双引号的一定是字符串型。

什么是变量？

变量就是一个存数据盒子。在内存中的最基本的存储单元。是存数据用的，而且这个数据是可变的，所以叫做变量。（盒子大小谁来决定？数据类型）

变量的使用

变量的三要素？

数据类型、变量名、值  （值就是数据，就是字面量。）`int i = 100;`

```java
// 1. java中的变量必须先声明，再赋值才能访问（必须手动赋值。）
int k; 
System.out.println(k); //这样是不行的。

// 2. 可以在一行上声明多个变量：

int a, b, c = 100;
// c变量赋值100，a,b变量只声明了没有赋值。
int a = 10, b = 20, c = 100;
// 也可以这样每个都赋值。

// 3.声明和赋值可以分开，也可以一起做！

int i;
i = 100; // 先声明再赋值
int k = 200; // 声明的同时赋值
```

在“同一个域”当中，变量名不能重名！但可以重新赋值
```java
{
    int i = 100;
    //double i = 2.0; // 重名了编译器会报错，不允许。
    i = 300; // 可以重新赋值。
}
```

什么叫做同一个域？一个大括号代表一个域。

变量的分类

根据位置进行分类：记住就行

```java
//在方法体当中声明的变量叫做局部变量。

public static void m1(){
//局部变量，方法执行结束之后内存释放。
    int k = 100;
    int i = 200;
}

//在方法体外以及类体内声明的变量叫做成员变量。
public class T{
public static void x(){

}
	// 成员变量
	int i = 200;
}

//变量的作用域
//出了大括号就不认识了。别的先别管。
{
	int i = 100;
	{
		//在这里可以访问i
	}
}
{
	//在这里是无法访问i变量。
}
```

变量的作用域？

1、什么是作用域？变量的有效范围。

2、关于变量的作用域，可一句话：出了大括号就不认识了。（死记这句话。）

3、java中有一个很重要的原则：就近原则。（不仅java中是这样，其它编程语言都有这个原则。）哪个离我近，就访问哪个。

```java
public class VarTest08{

	// 成员变量
	int i = 10000;

	public static void main(String[] args){
		// 局部变量
		int i = 100; // 这个i的有效范围是main方法。
		System.out.println(i); // 这个i是多少？

		// 同一个域当中，这是不允许的。
		//int i = 90;  

		for(int n = 0; n < 10; n++){ // 这里声明的n变量只属于for域。for结束后n释放没了。
			// 这里没有编写代码。
		}

		// for循环执行结束之后，在这里访问n变量可以吗？
		//System.out.println(n);  //错误: 找不到符号

		int k; // 属于main域。
		for(k = 0; k < 10; k++){

		}
	}

	// 这个方法怎么定义先不用管，后面会学习。
	public static void x(){
		// 在这个位置上能访问i吗？不能
		// 错误: 找不到符号
		// System.out.println(i); // i是无法访问的。

		// 可以定义一个变量起名i吗？
		// 这个i的有效范围是x方法。
		// 局部变量
		int i = 200; // 所以这个i和main方法中的i不在同一个域当中。不冲突。
	}
}
```


### 数据类型

数据类型有什么用？

- 数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。

数据类型在java语言中包括两种：

- 第一种：基本数据类型(8小种)基本数据类型又可以划分为4大类8小种：
  - 第一类：整数型 byte,short,int,long （没有小数的）
  - 第二类：浮点型 float,double （带有小数的）
  - 第三类：布尔型 boolean：只有两个值true和false，true表示真，false表示假
  - 第四类：字符型 char：java中规定字符型字面量必须使用单引号括起来。属于文字。
- 第二种：引用数据类型
  - 字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。
- java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。

整数型：byte short int long有什么区别？

浮点型：float和double有什么区别？

区别：占用的空间大小不同。

| 类型 | 占用字节数量(byte) | 取值范围|
| ---- | ------------------ |-----|
| byte | 1 | -128 ~ 127|
| short | 2 | -32768 ~ 32767 |
| int | 4   | -2147483648 ~ 2147483647|
| long | 8  | -2^63~2^63-1 |
| float | 4 | -2^31~2^31-1|
| double | 8  | -2^63~2^63-1|
| boolean | 1 | true、false |
|char | 2 | 0 ~ 65535 |

short和char实际上容量相同，不过char可以表示更大的数字。

因为char表示的是文字，文件没有正负之分，所以char可以表示更大的数字。

其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0;对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。

什么是字符编码？

字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。字符编码是人为规定的。

字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。

关于字符编码的发展过程？

- 起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了战争而开发的，计算导弹的轨道....
- 后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文对应的字符编码方式是：ASCII码。

在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。具体的实现包括：UTF-8 UTF-16 UTF-32....

ASCII（'a'是97 'A'是65 '0'是48...）

#### 字符型：char

1、char占用2个字节。

2、char的取值范围：[0-65535]

3、char采用unicode编码方式。

4、char类型的字面量使用单引号括起来。

5、char可以存储一个汉字。

```java
public class CharTest01{
	public static void main(String[] args){
		// char可以存储1个汉字吗？
		// 可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。
		char c1 = '中';
		System.out.println(c1);

		char c2 = 'a';
		System.out.println(c2);

		// 0如果加上单引号的话，0就不是数字0了，就是文字0，它是1个字符。
		char c3 = '0';
		System.out.println(c3);

		// 错误: 不兼容的类型: String无法转换为char
		//char c4 = "a";

		// 错误: 未结束的字符文字
		//char c5 = 'ab';

		// 错误: 未结束的字符文字
		//char c6 = '1.08';

	}
}

```

转义字符

```java

/*
	关于java中的转义字符
*/
public class CharTest02{
	public static void main(String[] args){


		System.out.println("s");
		// 编译报错。
		//System.out.println(""");
		//System.out.println("\"");

		// 这个可以输出吗？
		// 这个不需要专门进行转义。
		// 这个 ' 在这里只是一个普通的字符，不具备特殊含义。
		System.out.println("'");

		//以下都有问题
		//System.out.println(''');
		//System.out.println(""");

		// 可以的。
		System.out.println("'这样呢'");

		// 编译报错，因为：4e2d 是一个字符串
		// 错误: 未结束的字符文字
		//char x = '4e2d';

		// 反斜杠u表示后面的是一个字符的unicode编码。
		// unicode编码是十六进制的。
		char x = '\u4e2d';
		System.out.println(x); // '中'
	}
}

/*
	1、整数能否直接赋值给char
	2、char x = 97;
		这个java语句是允许的，并且输出的结果是'a'
		经过这个测试得出两个结论：
			第一个结论：当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。

			第二个结论：当一个整数没有超出byte short char的取值范围的时候，
			这个整数可以直接赋值给byte short char类型的变量。
*/
public class CharTest03{
	public static void main(String[] args){
	
		char c1 = 'a';
		System.out.println(c1);

		// 这里会做类型转换吗？
		// 97是int类型（这是java中规定，默认当做int处理）
		// c2是char类型
		//char c2 = (char)97; // 不需要这样做。
		char c2 = 97;
		System.out.println(c2); // 'a'

		// char类型取值范围：[0~65535]
		char c3 = 65535; // 实际上最终是一个“看不懂”的字符。
		System.out.println(c3);

		//错误: 不兼容的类型: 从int转换到char可能会有损失
		//char c4 = 65536;

		// 怎么解决以上问题？
		char c4 = (char)65536;

		byte x = 1;
		short s = 1;
		char c = 1;

	}
}
```

#### 整数型：byte short int long

byte b = 127; // 可以直接赋值short s = 32767; // 可以直接赋值

char // 没有超出char的取值范围可以直接赋值给char变量吗?

浮点型：float double

布尔型：boolean

```java
/*
	开发的时候不用斤斤计较，直接选择使用int就行了。
*/
public class IntTest01{
	public static void main(String[] args){

		// 二进制（JDK8的新特性，低版本不支持。）
		int d = 0b10;
		System.out.println(d); // 2
	}
}


```

##### 过大整数的问题

在java中有一条非常重要的结论，必须记住：

- 在任何情况下，整数型的“字面量/数据”默认被当做int类型处理。（记住就行）果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L/l,	建议使用大写L，因为小写l和1分不清。

```java
public class IntTest02{
	public static void main(String[] args){

		// 分析这个代码存在类型转换吗，以下代码什么意思？
		// 不存在类型转换
		// 100 这个字面量被当做int类型处理
		// a变量是int类型，所以不存在类型的转换。
		// int类型的字面量赋值给int类型的变量。
		int a = 100;
		System.out.println(a);

		// 分析这个程序是否存在类型转换？
		// 分析：200这个字面量默认被当做int类型来处理
		// b变量是long类型，int类型占4个字节，long类型占8个字节
		// 小容量可以自动转换成大容量，这种操作被称为：自动类型转换。
		long b = 200;
		System.out.println(b);

		// 分析这个是否存在类型转换？
		// 这个不存在类型转换。
		// 在整数型字面量300后面添加一个L之后，300L联合起来就是一个long类型的字面量
		// c变量是long类型，long类型赋值给long类型不存在类型转换。
		long c = 300L;
		System.out.println(c);

		// 题目：
		// 可以吗？存在类型转换吗？
		// 2147483647默认被当做int来处理
		// d变量是long类型，小容量可以自动赋值给大容量，自动类型转换
		long d = 2147483647; // 2147483647是int最大值。
		System.out.println(d);

		// 编译器会报错吗？为什么？
		// 在java中，整数型字面量一上来编译器就会将它看做int类型
		// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。
		// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648
		// 只不过2147483648本身已经超出了int范围。
		// 错误: 整数太大
		//long e = 2147483648;

		// 怎么解决这个问题呢？
		long e = 2147483648L;
		System.out.println(e);

	}
}

```

##### 自动类型转换和强制类型转换

1、小容量可以直接赋值给大容量，称为自动类型转换。

2、大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。但需要注意的是：加强制类型转换符之后，虽然编译通过了，但是运行的时候可能会损失精度。

```java
public class IntTest03{
	public static void main(String[] args){
		
		// 不存在类型转换
		// 100L是long类型字面量，x是long类型字面量。
		long x = 100L;

		// x是long类型，占用8个字节，而y变量是int类型，占用4个字节
		// 在java语言中，大容量可以“直接”赋值给小容量吗？不允许，没有这种语法。
		// 编译错误信息：错误: 不兼容的类型: 从long转换到int可能会有损失
		// int y = x;

		// 大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。
		// 底层是怎么进行强制类型转换的呢？
		// long类型100L：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
		// 以上的long类型100L强转为int类型，会自动将“前面”的4个字节砍掉：00000000 00000000 00000000 01100100
		int y = (int)x; // 这个(int)就是强制类型转换符，加上去就能编译通过。
						// 但是要记住：编译虽然过了，但是运行时可能损失精度。
		System.out.println(y); // 100

		// 定义变量a int类型，赋值100
		int a = 100;
		System.out.println(a);

		int b = a; // 将变量a中保存的值100复制一份给b变量。
		System.out.println(b);

	}
}

```

##### 强制类型转换的精度损失

java中有一个语法规则：

- 当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量。short 同理。
	
这种语法机制是为了方便写代码，而存在的。

```java
public class IntTest04{
	public static void main(String[] args){
		// 分析：以下代码编译可以通过吗？
		// 300 被默认当做int类型
		// b变量是byte类型
		// 大容量转换成小容量，要想编译通过，必须使用强制类型转换符
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//byte b = 300;

		// 要想让以上的程序编译通过，必须加强制类型转换符
		// 虽然编译通过了，但是可能精度损失。
		// 300这个int类型对应的二进制：00000000 00000000 00000001 00101100
		// byte占用1个字节，砍掉前3个字节，结果是：00101100 (44)
		byte b = (byte)300;
		System.out.println(b); // 44

		// 这个编译能通过吗？
		// 1是int类型，默认被当做int类型来看。
		// x是byte类型，1个字节，大容量无法直接转换成小容量。
		// 按说是编译报错的。
		byte x = 1;
		byte y = 127;
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		byte z = 128;

		// 当整数型字面量没有超出short类型取值范围的时候，该字面量可以直接赋值给short
		// 类型的变量。
		short s = 1;
		short s1 = 32767;
		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s2 = 32768;
		System.out.println(s);

	}
}
```

##### byte, char, short 混合运算

```java
/*
	结论：byte、char、short做混合运算的时候，各自先转换成int再做运算。
*/
public class IntTest06{
	public static void main(String[] args){

		char c1 = 'a';
		byte b = 1;

		// 注意：这里的"+"是负责求和的
		System.out.println(c1 + b); // 98

		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = c1 + b; // 编译器不知道这个加法最后的结果是多少。只知道是int类型。

		// 这样修改行吗？
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = (short)c1 + b;

		short s = (short)(c1 + b);

		//short k = 98;

		int a = 1;
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		// short x = 1; 可以
		short x = a; // 不可以，编译器只知道a是int类型，不知道a中存储的是哪个值。
		System.out.println(x);
	}
}
```
##### 多种类型混合运算

```java
/*
	结论：多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。

	char+short+byte 这个除外。
	因为char + short + byte混合运算的时候，会各自先转换成int再做运算。
*/
public class IntTest07{
	public static void main(String[] args){
		
		long a = 10L;
		char c = 'a';
		short s = 100;
		int i = 30;

		// 求和
		System.out.println(a + c + s + i); //237

		// 错误: 不兼容的类型: 从long转换到int可能会有损失
		// 计算结果是long类型
		//int x = a + c + s + i;

		int x = (int)(a + c + s + i);
		System.out.println(x);

		// 以下程序执行结果是？
		// java中规定，int类型和int类型最终的结果还是int类型。
		int temp = 10 / 3; // / 是除号。（最终取整）
		System.out.println(temp); // 3.33333吗？结果是：3

		// 在java中计算结果不一定是精确的。
		int temp2 = 1 / 2;
		System.out.println(temp2); // 0

	}
}
```

#### 浮点型数据

关于java语言中的浮点型数据

浮点型包括：

|类型| 大小| 解释 |
|---|---|---|
|float	|	4个字节|	float是单精度|
|double	|	8个字节|	double是双精度,更精确|
	
比如说：
- 10.0 / 3 如果采用float来存储的话结果可能是：3.33333

- 10.0 / 3 如果采用double来存储的话结果可能是：3.3333333333333


>	但是需要注意的是，如果用在银行方面或者说使用在财务方面，double也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门使用在财务软件方面：java.math.BigDecimal （不是基本数据类型，属于引用数据类型。）
	
float和double存储数据的时候都是存储的近似值。

- 因为现实世界中有这种无限循环的数据，例如：3.3333333333333....数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源表示无限的数据，只能存储近似值。

long类型占用8个字节。float类型占用4个字节。

哪个容量大？

- 注意：任意一个浮点型都比整数型空间大。float容量 > long容量。
	
java中规定，任何一个浮点型数据默认被当做double来处理。如果想让这个浮点型字面量被当做float类型来处理，那么请在字面量后面添加F/f。

1.0 那么1.0默认被当做double类型处理。		1.0F 这才是float类型。（1.0f）

```java

public class FloatTest01{
	public static void main(String[] args){

		// 这个不存在类型转换
		// 3.1415926是double类型
		// pi是double类型
		double pi = 3.1415926;
		System.out.println(pi);

		// 这个可以吗？
		//错误: 不兼容的类型: 从double转换到float可能会有损失
		//float f = 3.14;

		// 怎么修改以上的代码呢？
		// 第一种方式:在字面量后面添加F/f
		//float f = 3.14f;
		//float f = 3.14F;

		// 第二种方式：强制类型转换，但可能损失精度。谨慎使用。
		float f = (float)3.14;
		System.out.println(f);

		// 分析这个程序，可以编译通过吗？
		// 错误: 不兼容的类型: 从double转换到int可能会有损失
		// 原理：先将5转换成double类型，然后再做运算，结果是double
		// 大容量无法直接赋值给小容量，需要强转。
		//int i = 10.0 / 5;

		// 怎么修改
		int i = (int)10.0 / 5;
		System.out.println(i); // 2

		// 可以这样修改吗？强转的时候只留下整数位。
		int x = (int)(10.0 / 5);
		System.out.println(x); // 2
	}
}

```

#### 布尔类型

1、在java语言中boolean类型只有两个值，没有其他值：true和false。不像C或者C++，C语言中1和0也可以表示布尔类型。

2、boolean类型在实际开发中使用在哪里呢？		使用在逻辑判断当中，通常放到条件的位置上（充当条件）

```java
public class BooleanTest01{
	public static void main(String[] args){
		//错误: 不兼容的类型: int无法转换为boolean
		//boolean xingBie = 1;
	}
}
```

#### 类型转换

在类型转换的时候需要遵循哪些规则？

- 第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；

- 第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；

- 第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：byte < short(char) < int < long < float < double，其中 short和 char都占用两个字节，但是char 可以表示更大的正整数；

- 第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；

- 第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；

- 第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；

### 运算符

- 算术运算符：+ - * / % ++ --

- 关系运算符： > >= < <= == !=

- 逻辑运算符：& | ! && ||

- 赋值运算符：= += -= *= /= %=

- 三目运算符：布尔表达式 ? 表达式 1 : 表达式 2 

- 字符串连接运算符：+

#### 逻辑运算符


逻辑运算符：
- &	逻辑与（可以翻译成并且）
- |	逻辑或（可以翻译成或者）
- !	逻辑非（取反）
- &&	短路与
- ||	短路或
- 	用普通话描述的话：100 大于 99 并且 100 大于 98；用代码描述的话：100 > 99 & 100 > 98 --> true

true & true --> true

非常重要：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。这是逻辑运算符的特点。	

- 100 & true 不行，语法错误。

- 100 & 200 不行，没有这种语法。

- true & false 这样可以。

100 > 90 & 100 > 101 --> false

- & 两边都是true，结果才是true

- | 有一边是true，结果就是true


短路与&& 和 逻辑与 &有什么区别？

- 首先这两个运算符的运算结果没有任何区别，完全相同。只不过“短路与&&”会发生短路现象。

什么是短路现象呢？

- 右边表达式不执行，这种现象叫做短路现象。

什么时候使用&&，什么时候使用& ？

- 从效率方面来说，&&比&的效率高一些。因为逻辑与&不管第一个表达式结果是什么，第二个表达式一定会执行。

以后的开发中，短路与&&和逻辑与还是需要同时并存的。

- 大部分情况下都建议使用短路与&&，只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&。


```java

System.out.println(true & true); // true
System.out.println(true & false); // false
System.out.println(false & false); // false

System.out.println(true && true); // true
System.out.println(true && false); // false
System.out.println(false && false); // false

// 接下来需要理解一下什么是短路现象，什么时候会发生“短路”。
int x = 10;
int y = 11;
// 逻辑与&什么时候结果为true（两边都是true，结果才是true）
// 左边的 x>y 表达式结果已经是false了，其实整个表达式的结
// 果已经确定是false了，按道理来说右边的表达式不应该执行。
System.out.println(x > y & x > y++); 

// 通过这个测试得出：x > y++ 这个表达式执行了。
System.out.println(y); // 12

//测试短路与&&
int m = 10;
int n = 11;
// 使用短路与&&的时候，当左边的表达式为false的时候，右边的表达式不执行
// 这种现象被称为短路。
System.out.println(m > n && m > n++);
System.out.println(n); // 11
```

问题：什么时候发生短路或现象？|| 短路或

“或”的时候只要有一边是true，结果就是true。

所以，当左边的表达式结果是true的时候，右边的表达式不需要执行，此时会短路。

#### 赋值运算符

扩展的赋值运算符？

- +=

- -=

- *=

- /=

- %=

使用扩展赋值运算符的时候，永远都不会改变运算结果类型。

`byte x = 100;`
`x += 1;`

x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。不管后面是多大的数字。

```java
public class OperatorTest04{
	public static void main(String[] args){

		// 研究：
		// i += 10 和 i = i + 10 真的是完全一样吗？
		// 答案：不一样，只能说相似，其实本质上并不是完全相同。
		byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
		System.out.println(x); // 100

		// 分析：这个代码是否能够编译通过？
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？

		// 使用扩展赋值运算符可以吗？
		// 可以的，所以得出结论：x += 1 和 x = x + 1不一样。
		// 其实 x += 1 等同于：x = (byte)(x + 1);
		x += 1;
		System.out.println(x); // 101

		// 早就超出byte的取值范围了。
		x += 199; // x = (byte)(x + 199);
		System.out.println(x); // 44 （当然会自动损失精度了。）

		int y = 100;
		y += 100;
		System.out.println(y); // 200

		y -= 100; // x = x - 100;
		System.out.println(y); // 100

		y *= 10; // x = x * 10;
		System.out.println(y); // 1000

		y /= 30; // x = x / 30;
		System.out.println(y); // 33

		y %= 10; // x = x % 10;
		System.out.println(y); // 3
		
	}
}

```

一个特例


```java


// 大家讨论最多的一个问题。
// 如果只是针对于面试题的话，建议死记硬背。
public class Homework01{
	public static void main(String[] args){
		int i = 10;
		i = i++;
		// 大部分同学都会认为这个i一定是11
		// 这个i变量最终的结果是10（惊讶）
		// 首先，第一点：这种代码以后不会有人写。
		// 其次：第二点：没必要讨论这个问题，因为在C++中运行结果确实是11.
		// java中运行结果是10
		// c++中运行结果是11
		// 为什么？因为java和c++的编译器是不同的人开发的。原理不同。
		System.out.println(i);
		
		// 在java语言中i++，这种表达式在执行的时候，会提前先将i变量找一个临时
		// 变量存储一下。(C++中并没有这样做。)
		/*
		int k = 10;
		k = k++;
		*/
		int k = 10;
		// k = k++;对应的是下面三行代码
		int temp = k;
		k++;
		k = temp;
		System.out.println(k);
	}
}

```

#### 字符串链接运算符

+ 运算符：

1、+ 运算符在java语言中有两个作用。

- 	作用1：求和

- 	作用2：字符串拼接

2、什么时候求和？什么时候进行字符串的拼接呢？

- 当 + 运算符两边都是数字类型的时候，求和。

- 当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。

3、一定要记住：字符串拼接完之后的结果还是一个字符串。


#### 接收用户键盘输入

输出信息到控制台：`System.out.println(...);`

2、在java中怎么接收键盘的输入呢？

`java.util.Scanner s = new java.util.Scanner(System.in); `

接收一个整数		`int num = s.nextInt();`
		
接收一个字符串		`String str = s.next();`

```java
public class KeyInput{
	public static void main(String[] args){

		// 创建一个键盘扫描器对象
		// s 变量名，可以修改。其它不能改。 
		java.util.Scanner s = new java.util.Scanner(System.in); //这行代码写一次就行了。

		// 接收用户的输入，从键盘上接收一个int类型的数据
		// 解释这行代码，尽量让大家明白：代码执行到这里的时候，会暂停下来
		// 等待用户的输入，用户可以从键盘上输入一个整数，然后回车，回车之后
		// i变量就有值了。并且i变量中保存的这个值是用户输入的数字。
		// i变量就是接收键盘数据的。
		int i = s.nextInt(); // i是变量名，s是上面的变量名
		System.out.println("您输入的数字是：" + i);

		// 代码执行到此处又会停下来，等待用户的输入。
		// 敲完回车，s.nextInt();代码执行结束。
		int j = s.nextInt();
		System.out.println("您输入的数字是：" + j);

		// 如果输入的不是数字，那么会出异常：InputMismatchException
		int m = s.nextInt();
		System.out.println("您输入的数字是：" + m);

		// 我怎么从键盘上接收一个字符串呢？
		// 程序执行到此处会停下来，等待用户的输入，用户可以输入字符串。
		String str = s.next();
		System.out.println("您输入了：" + str);

		// 完整的。
		System.out.print("请输入用户名：");
		String name = s.next();
		System.out.println("欢迎"+name+"回来");
	}
}
```

### Tips

- 在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层的变量，这样可能会导致程序设计的错误，所以在Java中不能这样做。

- Java的引用相当于C++的指针而不是引用，因为：

  - C++中没有空引用

  - 引用不能被赋值

- java中的null引用相当与C++中的NULL指针

## 控制语句和方法

### 控制语句

- 选择语句
	- if
	- switch
		- switch语句本质上是只支持int和String，但是byte,short,char也可以使用在switch语句当中，因为byte short char可以进行**自动类型转换**。
- 循环语句
	- for
	- while
	- do...while
- 转向语句
	- break
	- continue
	- return

**记住 ：Java的 int 和 boolean 不能转换 ！！！**

```java
/*
怎么用break;语句终止指定的循环呢？
	第一步：你需要给循环起一个名字，例如：
		a: for(){
			b:for(){
			}
		}
	第二步：终止：break a;
*/
public class BreakTest01{

	public static void main(String[] args){

		// 这种语法很少用，了解一下即可。
		a:for(int k = 0; k < 2; k++){ 
			b:for(int i = 0; i < 10; i++){
				if(i == 5){
					break a; // 终止指定的循环。
				}
				System.out.println("i ===> " + i); 
			}
		}

		System.out.println("呵呵");

	}
}// continue 也可以这样终止，但是开发中也很少用
```

### 方法

方法定义的先后顺序没有关系。都可以。

方法怎么定义，语法机制是什么？

```java
[修饰符列表] 返回值类型 方法名(形式参数列表){
	方法体; 
}
```

注意：
- [] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。

- 方法体由Java语句构成。

- 方法定义之后需要去调用，不调用是不会执行的。

关于修饰符列表：
- 修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static

关于返回值类型：

- 第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String......

- 第二：方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。
	
- 第三：当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。

- 第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用"return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。
	
- 第五：只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。

- 第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。
	
- 第七：除了void之外，剩下的都必须有“return 值;”这样的语句。

形式参数列表

- 简称：形参

- 注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。

- 形参的个数是：0~N个。

- public static void sumInt(){}

- public static void sumInt(int x){}

- 形参有多个的话使用“逗号,”隔开。逗号是英文的。形参的数据类型起决定性作用，形参对应的变量名是随意的。
	

方法体：

- 由Java语句构成。java语句以“;”结尾。方法体当中编写的是代码，完成某个特定功能。

- 在方法体中的代码遵循自上而下的顺序依次逐行执行。

- 在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。
	

怎么调用呢

- 类名.方法名(实际参数列表);	

- 实参和形参的类型必须一一对应，个数也要一一对应。

你定义了一个/抽取了一个方法出来，而这个方法确无法完成某个功能，那么你抽取的这个方法毫无意义。般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。

“类名.”是可以省略

- a()方法调用b()方法的时候，a和b方法都在同一个类中，“类名.”可以省略。如果不在同一个类中“类名.”不能省略。

```java
	// 在同一个域当中，"return语句"下面不能再编写其它代码。编写之后编译报错。
	public static int m(){
		boolean flag = true;
		if(flag){
			return 1;
			//错误: 无法访问的语句
			//System.out.println("hello1");
		}
		// 这行代码和上面的代码hello1的区别是：不在同一个域当中。
		//System.out.println("hello2");
		return 0;
		// 错误: 无法访问的语句
		//System.out.println("hello3");
	}
```


#### 重载

注意：如果功能不相似，坚决要让方法名不一致。

重载条件

- 条件1：在同一个类当中
- 条件2：方法名相同
- 条件3：形式参数列表不同（类型、个数、顺序）

注意：方法重载和返回值类型无关，和修饰符列表无关。

在java语言中，是怎么进行方法区分的？

- 首先java编译器会通过**方法名**进行区分。
- 但是在java语言中允许方法名相同的情况出现。
- 如果方法名相同的情况下，编译器会通过**方法的参数类型**进行方法的区分。


#### 递归

- 方法自身调用自身。

- 使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。
- StackOverflowError  原因：一直压栈，没有弹栈，栈内存不够用。

- 能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。JVM发生错误之后只有一个结果，就是退出JVM。当然，只有极少数情况下，只能用递归，其它代码解决不了问题。

- 当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？
也不一定。可能递归的太深了。栈内存不够了。因为一直在压栈。

- 在实际的开发中，不建议轻易的选择递归，能用for循环while循环代替的，尽量使用循环来做。因为循环的效率高，耗费的内存少。递归耗费的内存比较大，另外递归的使用不当，会导致JVM死掉。(但在极少数的情况下，不用递归，这个程序没法实现。)所以：递归我们还是要认真学习的。

> - 在实际的开发中，假设有一天你真正的遇到了：StackOverflowError 你怎么解决这个问题，可以谈一下你的思路吗？
> - 我来谈一下我的个人思路：
>   - 第一步：先检查递归的结束条件对不对。如果递归结束条件不对，必须对条件进一步修改，直到正确为止。
>   - 第二步：假设递归条件没问题，怎么办？这个时候需要手动的调整JVM的栈内存初始化大小。可以将栈内存的空间调大点。（可以调整大一些。）				
>   - 第三步：调整了大小，如果运行时还是出现这个错误，没办法，只能继续扩大栈的内存大小。

(java -X)这个可以查看调整堆栈大小的参数

# Java面向对象

## 面向对象

面向过程有什么缺点？（耦合度高，扩展力差。）

- 面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果关系结合在一起，假设其中任何一个因果关系出现问题（错误），此时整个系统的运转都会出现问题。（代码和代码之间的耦合度太高，扩展力太差。）

面向过程有什么优点？（快速开发）

- 对于小型项目（功能），采用面向过程的方式进行开发，效率较高。不需要前期进行对象的提取，模型的建立，采用面向过程方式可以直接开始干活。一上来直接写代码，编写因果关系，从而实现功能。

什么是面向对象的开发方式？

- 采用面向对象的方式进行开发，更符合人类的思维方式。（面向对象成为主流的原因）人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。

- 面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后给一个环境驱动一下，让各个对象之间协作起来形成一个系统。

- 采用面向对象的方式进行开发：耦合度低，扩展力强。

- 面向对象当中最主要“一词”是：对象。

什么是类？

- 实际上在现实世界当中是不存在的，是一个抽象的概念。是一个模板。是我们人类大脑进行“思考、总结、抽象”的一个结果。(主要是因为人类的大脑不一般才有了类的概念。)

- 类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。

什么是对象？对象是实际存在的个体。（真实存在的个体）

这几个术语你需要自己能够阐述出来：

- 类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）

- 对象：实际存在的个体。

- 实例：对象还有另一个名字叫做实例。

- 实例化：通过类这个模板创建对象的过程，叫做：实例化。

- 抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。

类 --【实例化】--> 对象(实例)

对象 --【抽象】--> 类

类是一个模板，是描述共同特征的一个模板，那么共同特征包括什么呢？

类 = 属性 + 方法

属性来源于：状态

方法来源于：动作

思考：“java软件工程师”在开发中起到的一个作用是什么？

我们为什么要做软件开发？说的大一些是为了人民服务。解决现实生活当中的问题。软件开发既然是为了解决现实世界当中的问题，那么首先java软件必须能够模拟现实世界。其实软件是一个虚拟的世界。这个虚拟的世界需要和现实世界一一对应，这才叫模拟。

### 类的定义

```java
[修饰符列表] class 类名{
    // 类体 = 属性 + 方法
    // 属性在代码上以“变量”的形式体现
    //方法描述动作、行为
}
```

```java
`public class XueSheng{ // 这个程序编译之后，会生成XueSheng.class字节码文件。
    // 属性
    // 学号（成员变量）
    int xueHao;
    // 姓名
    String xingMing;
    // 年龄
    int nianLing;
    // 性别
    boolean xingBie;
    // 住址
    String zhuZhi;
}
```

注意：修饰符列表可以省略。

为什么属性是“以”变量的形式存在的？是因为属性对应的是“数据”，数据在程序中只能放到变量中。结论：属性其实就是变量。

变量根据出现位置进行划分：

- 方法体当中声明的变量：局部变量。

- 方法体外声明的变量：成员变量。（这里的成员变量就是“属性”）

关于编译的过程

- 按说应该先编译XueSheng.java，然后再编译XueShengTest.java

- 但是对于编译器来说，编译XueShengTest.java文件的时候，会自动找XueSheng.class，如果没有，会自动编译XueSheng.java文件，生成XueSheng.class文件。

编译方法：

第一种方式：

- javac XueSheng.java

- javac XueShengTest.java

第二种方式：

- javac XueShengTest.java

第三种方式：

- javac *.java

在语法级别上是怎么完成对象创建的呢？

- 类名 变量名 = new 类名();

什么是实例变量？

- 对象又被称为实例。
- 实例变量实际上就是：对象级别的变量。

```java
public class 明星类{
    double height;
}
```

- 身高这个属性所有的明星对象都有，但是每一个对象都有“自己的身高值”。

- 假设创建10个明星对象，height变量应该有10份。

- 所以这种变量被称为对象级别的变量。属于实例变量。

实例变量在访问的时候，是不是必须先创建对象？是

对象和引用的区别？

- 对象是通过new出来的，在堆内存中存储。

- 引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。

成员变量的默认值

|类型|默认值|
| ----- | ----- |
|   byte | 0 |
| short | 0|
| int | 0|
| long | 0L|
|float | 0.0F|
|double | 0.0|
| boolean | flase|
|char | \u0000|
|引用数据类型| null|

### 内存图

1、画内存图注意事项：

- 第一：大家在内存图上不要体现出代码。内存上应该主要体现“数据”。

- 第二：大家画图的时候，图上的图形应该有先后顺序，先画什么，再画什么，必须是有顺序的，而不是想起来这个画这个，想起来那个画那个。程序代码是有执行顺序的，程序执行到哪里你就画哪里就行了。

2、为什么要画内存图（非常重要）？

- 第一：有了内存图，程序不运行，我也知道结果。（可以推算出结果）

- 第二：有了内存图，有助于你调试程序。画内存图是对Java运行机制的一种理解。不知道运行机制，以后复杂的程序出现错误之后你是不会调试的。

所有的实例变量（属性）都是通过“引用.”来访问的。
    
引用和对象怎么区分？

- “引用”是是存储对象内存地址的一个变量。

- “对象”是堆里new出来的。
    
通俗一点：

- 只要这个变量中保存的是一个对象的内存地址，那么这个变量就叫做“引用”。
    
思考：

- 引用一定是局部变量吗？不一定。

```java
public class Test{
    public static void main(String[] args){

        // 家庭住址对象
        Address a = new Address();
        a.city = "北京";
        a.street = "大兴区";
        a.zipcode = "121221";
        
        // 用户对象
        User u = new User();
        System.out.println(u.id); // 0
        System.out.println(u.username); // null
        System.out.println(u.addr); // null

        u.id = 11111;
        u.username = "zhangsan";
        u.addr = a;

    }
}

public class User{
    int id; // 实例变量
    String username; // 实例变量
    Address addr; 
}


// 住址类
public class Address{

    // 一个家庭住址有3个属性。
    // 城市
    String city; // 实例变量
    // 街道
    String street;
    // 邮编
    String zipcode;
}

```

### 空指针异常

空指针异常。（NullPointerException）

关于垃圾回收器：GC

- 在java语言中，垃圾回收器主要针对的是堆内存。当一个java对象没有任何引用指向该对象的时候，GC会考虑将该垃圾数据释放回收掉。

出现空指针异常的前提条件是？"空引用"访问实例【对象相关】相关的数据时，都会出现空指针异常。

```java
public class NullPointerTest{
    public static void main(String[] args){
        // 创建客户对象
        Customer c = new Customer();
        // 访问这个客户的id
        System.out.println(c.id); // 0

        // 重新给id赋值
        c.id = 9521; // 终身代号
        System.out.println("客户的id是=" + c.id);
        //c = null;
        // NullPointerException
        // 编译器没问题，因为编译器只检查语法，编译器发现c是Customer类型，
        // Customer类型中有id属性，所以可以：c.id。语法过了。
        // 但是运行的时候需要对象的存在，但是对象没了，尴尬了，就只能出现一个异常。
        System.out.println(c.id);
    }
}

class Customer{
    // 客户id
    int id; // 成员变量中的实例变量，应该先创建对象，然后通过“引用.”的方式访问。
}
```

方法在调用的时候参数是如何传递的？

- 实际上，在java语言中，方法调用时参数传递，和类型无关，都是将变量中保存的那个“值”传过去，这个“值”可能是一个数字100，也可能是一个java对象的内存地址：0x1234记住这句话：不管是哪一种数据类型的传递，都是将“变量中保存的那个值复制一份传递过去。”


java中关于方法调用时参数传递实际上只有一个规则：

- 不管你是基本数据类型，还是引用数据类型，实际上在传递的时候都是将变量中保存的那个“值”复制一份，传过去。

```java
int x = 1;
int y = x; // 把x中保存1复制一份传给y
// x和y都是两个局部变量。

Person p1 = 0x1234;
Person p2 = p1; 把p1中保存的0x1234复制一份传给p2
// p1和p2都是两个局部变量。
```

你和你媳妇，都有你家大门上的钥匙，钥匙是两把。
但是都可以打开你家的大门。

```java
public class Test2{
    public static void main(String[] args){
        Person p = new Person();
        p.age = 10;
        add(p);
        System.out.println("main--->" + p.age); //11
    }
    // 方法的参数可以是基本数据类型，也可以是引用数据类型，只要是合法的数据类型就行。
    public static void add(Person p){ // p是add方法的局部变量。
        p.age++;
        System.out.println("add--->" + p.age); //11
    }
}

class Person{
    // 年龄属性，成员变量中的实例变量。
    int age;
}
```

### 构造方法

当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参数的构造方法叫做缺省构造器。

当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。

建议将无参数构造方法手动的写出来，这样一定不会出问题。

无参数构造方法和有参数的构造方法都可以调用。

```java
Student x = new Student();

Student y = new Student(123);
```

构造方法支持方法重载吗？

- 构造方法是支持方法重载的。

- 在一个类当中构造方法可以有多个。

- 并且所有的构造方法名字都是一样的。

- 特点：在同一个类中，方法名相同，参数列表不同。

对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。

构造方法需要掌握的知识点：

1. 构造方法有什么作用？

2. 构造方法怎么定义，语法是什么？

3. 构造方法怎么调用，使用哪个运算符？

4. 什么是缺省构造器？

5. 怎么防止缺省构造器丢失？

6. 实例变量在类加载是初始化吗？实例变量在什么时候初始化？


构造方法

1、什么是构造方法，有什么用？

- 构造方法是用来创建对象，并且同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统会赋默认值。）

2、当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法。（而这个构造方法被称为缺省构造器。）

3、调用构造方法怎么调用呢？使用哪个运算符呢？使用new运算符来调用构造方法。`new 构造方法名(实际参数列表);`

4、构造方法的语法结构是？

```java
[修饰符列表] 构造方法名(形式参数列表){
    构造方法体;
    通常在构造方法体当中给属性赋值，完成属性的初始化。
}
```

注意：

1. 修饰符列表目前统一写：public。千万不要写public static。

2. 构造方法名和类名必须一致。

3. 构造方法不需要指定返回值类型，也不能写void，写上void表示普通方法，就不是构造方法了。

普通方法的语法结构是？

```java
[修饰符列表] 返回值类型 方法名(形式参数列表){
    方法体;
}
```

1、构造方法对应的英语单词：Constructor【构造器】

2、构造方法作用：

- 创建对象，并且创建对象的过程中给属性赋值（初始化。）

以后开发的时候最好自己写出来一个默认无参构造函数

```java

public class ConstructorTest01{
    public static void main(String[] args){

        // 调用Student类的无参数构造方法
        new Student();

        // 调用普通方法
        ConstructorTest01.doSome();
        doSome();

        // 创建Student类型的对象
        Student s1 = new Student();

        // 输出“引用”
        //只要输出结果不是null，说明这个对象一定是创建完成了。
        // 此处的输出结果大家目前是看不懂的，后期再说。
        System.out.println(s1); //Student@54bedef2

        // 这是调用另一个有参数的构造方法。
        Student s3 = new Student(100);
        System.out.println(s3); //Student@5caf905d
    }

    public static void doSome(){
        System.out.println("do some!!!!");
    }
}
```

## 封装、this和static

### 封装

有了封装，才有继承，有了继承，才能说多态。

封装的作用有两个：

- 第一个作用：保证内部结构的安全。

- 第二个作用：屏蔽复杂，暴露简单。

在代码级别上，封装有什么用？

- 一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。

- 类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。

怎么进行封装

- 第一步：属性私有化（使用private关键字进行修饰。）

- 第二步：对外提供简单的操作入口。

第一步：属性私有化

第二步：1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。

在强调一下：

- set和get方法都是实例方法，**不能带static**。

- 不带static的方法称为实例方法，实例方法的调用必须先new对象。

#### 封装过程

```java
public class Person{
    // private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。
    // 出了这个类，age属性就无法访问了。私有的。
    private int age; // 每一个人年龄值不同，对象级别的属性。

    // 写一个方法专门来完成读。(get)
    // 写一个方法专门来完成写。(set)
    // get和set方法应该带有static，还是不应该有static,get和set方法应该定义为实例方法吗？
    // get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）
    // 封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。
    /*
        [修饰符列表] 返回值类型 方法名(形式参数列表){
        }

        注意：
            java开发规范中有要求，set方法和get方法要满足以下格式。
                get方法的要求：
                    public 返回值类型 get+属性名首字母大写(无参){
                        return xxx;
                    }
                set方法的要求：
                    public void set+属性名首字母大写(有1个参数){
                        xxx = 参数;
                    }
            
            大家尽量按照java规范中要求的格式提供set和get方法。
            如果不按照这个规范格式来，那么你的程序将不是一个通用的程序。

    */
    // get方法
    public int getAge(){
        return age;
    }

    // set方法
    public void setAge(int nianLing){
        // 能不能在这个位置上设置关卡！！！！
        if(nianLing < 0 || nianLing > 150){
            System.out.println("对不起，年龄值不合法，请重新赋值！");
            return; //直接终止程序的执行。
        }
        //程序能够执行到这里，说明年龄一定是合法的。
        age = nianLing;
    }
}

```

#### static方法调用方式

```java
//带有static的方法
//没有static的方法
//分别怎么调用？
    //带有static的方法怎么调用？通过“类名.”的方式访问。

//对象被称为实例。
//实例相关的有：实例变量、实例方法。
//实例变量是对象变量。实例方法是对象方法。
//实例相关的都需要先new对象，通过“引用.”的方式去访问。
public class MethodTest{

    /*
    public MethodTest(){
    
    }
    */

    public static void main(String[] args){
        MethodTest.doSome();
        //类名. 可以省略（在同一个类中。）
        doSome();
        // 尝试使用“类名.”的方式访问“实例方法”
        // 错误的
        //MethodTest.doOther();
        
        // 创建对象
        MethodTest mt = new MethodTest();
        // 通过"引用."的方式访问实例方法。
        mt.doOther();

    }	

    // 带有static
    public static void doSome(){
        System.out.println("do some!");
    }

    //这个方法没有static，这样的方法被称为：实例方法。（对象方法，对象级别的方法）
    //这个没法解释，大家目前死记硬背。
    public void doOther(){
        System.out.println("do other....");
    }

}
```

#### 再探空指针异常

```java

/*
空指针异常导致的最本质的原因是？
    空引用访问“实例相关的数据”，会出现空指针异常。
    实例相关的包括：实例变量 + 实例方法。
*/
public class NullPointerTest{
    public static void main(String[] args){
        User u = new User();
        System.out.println(u.id); // 0
        u.doSome();

        // 引用变成空null
        u = null;

        // id的访问，需要对象的存在。
        //System.out.println(u.id); // 空指针异常

        // 一个实例方法的调用也必须有对象的存在。
        //u.doSome(); // 空指针异常。
    }
}


// 类 = 属性 + 方法
// 属性描述状态
// 方法描述行为动作
class User{

    // 实例变量
    int id;

    // 实例方法（对象相关的方法，对象级别的方法，应该是一个对象级别的行为。）
    // 方法模拟的是对象的行为动作。
    public void doSome(){
        System.out.println("do some!");
    }

    // 考试的行为，由于每一个人考试之后的分数不一样，所以考试行为应该必须有对象的参与。
    public void exam(){
        
    }
}
```

### static

static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。

当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。

#### 实例和静态

```java
/*
    static:
        1、static翻译为“静态”
        2、所有static关键字修饰的都是类相关的，类级别的。
        3、所有static修饰的，都是采用“类名.”的方式访问。
        4、static修饰的变量：静态变量
        5、static修饰的方法：静态方法

    变量的分类：
        变量根据声明的位置进行划分：
            在方法体当中声明的变量叫做：局部变量。
            在方法体外声明的变量叫做：成员变量。

        成员变量又可以分为：
            实例变量
            静态变量
*/

class VarTest{

    // 以下实例的，都是对象相关的，访问时采用“引用.”的方式访问。需要先new对象。
    // 实例相关的，必须先有对象，才能访问，可能会出现空指针异常。
    // 成员变量中的实例变量
    int i;

    // 实例方法
    public void m2(){
        // 局部变量
        int x = 200;
    }


    // 以下静态的，都是类相关的，访问时采用“类名.”的方式访问。不需要new对象。
    // 不需要对象的参与即可访问。没有空指针异常的发生。
    // 成员变量中的静态变量
    static int k;

    // 静态方法
    public static void m1(){
        // 局部变量
        int m = 100;
    }
    
}

/*
    什么时候变量声明为实例的，什么时候声明为静态的？
        如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议定义为类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销。

    一个对象一份的是实例变量。
    所有对象一份的是静态变量。
*/

// 定义一个类：中国人
class Chinese{

    // 身份证号
    // 每一个人的身份证号不同，所以身份证号应该是实例变量，一个对象一份。
    String idCard; 

    // 姓名
    // 姓名也是一个人一个姓名，姓名也应该是实例变量。
    String name;

    // 国籍
    // 重点重点五颗星：加static的变量叫做静态变量
    // 静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。
    // 静态变量存储在方法区。
    static String country = "中国";

    // 无参数
    public Chinese(){
    
    }

    // 有参数
    public Chinese(String s1,String s2){
        idCard = s1;
        name = s2;
    }
}



/*
    实例的：一定需要使用“引用.”来访问。

    静态的：
        建议使用“类名.”来访问，但使用“引用.”也行（不建议使用"引用."）。
        静态的如果使用“引用.”来访问会让程序员产生困惑：程序员以为是实例的呢。
    
    结论：
        空指针异常只有在什么情况下才会发生呢?只有在“空引用”访问“实例”相关的，都会出现空指针异常。
*/

/*
    关于方法来说，什么时候定义为实例方法？什么时候定义为静态方法？
        有没有参考标准。

        此方法一般都是描述了一个行为，如果说该行为必须由对象去触发。
        那么该方法定义为实例方法。

        参考标准：
            当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。

            我们以后开发中，大部分情况下，如果是工具类的话，工具类当中的方法
            一般都是静态的。(静态方法有一个优点，是不需要new对象，直接采用类名
            调用，极其方便。工具类就是为了方便，所以工具类中的方法一般都是static的。)

            什么是工具类？？？？？
                以后讲。（工具类就是为了方便编程而开发的一些类。）
    
    类 = 属性 + 方法
        属性描述的是：状态
        方法描述的是：行为动作
    
    一个方法代表了一个动作。

*/
```

#### 静态代码块

```java

/*
    1、使用static关键字可以定义：静态代码块
    2、什么是静态代码块，语法是什么？
        static {
            java语句;
            java语句;
        }
    3、static静态代码块在什么时候执行呢？
        类加载时执行。并且只执行一次。
        静态代码块有这样的特征/特点。

    4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。

    5、静态代码块一般是按照自上而下的顺序执行。

    6、静态代码块有啥作用，有什么用？
        第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）
        第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。这个时机叫做：类加载时机。

    具体的业务：
        项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。
    思考：这些记录日志的代码写到哪里呢？
        写到静态代码块当中。
        
*/
public class StaticTest06{

    // 静态代码块（特殊的时机：类加载时机。）
    static {
        System.out.println("A");
    }

    // 一个类当中可以编写多个静态代码块
    static {
        System.out.println("B");
    }

    // 入口
    public static void main(String[] args){
        System.out.println("Hello World!");
    }

    // 编写一个静态代码块
    static{
        System.out.println("C");
    }
}

/*
A
B
C
Hello World!
*/


/*
    栈：方法只要执行，会压栈。（局部变量）
    堆：new出来的对象都在堆中。垃圾回收器主要针对。（实例变量）
    方法区：类的信息，字节码信息，代码片段。（静态变量）

    方法的代码片段放在方法区，但是方法执行过程当中需要的内存在栈中。
*/
public class StaticTest07{
    
    // 静态变量在什么时候初始化？类加载时初始化。
    // 静态变量存储在哪里？方法区
    static int i = 100;

    // 静态代码块什么时候执行？类加载时执行。
    static {
        // 这里可以访问i吗？
        System.out.println("i = " + i);
    }

    // 实例变量
    int k = 111; // k变量是实例变量，在构造方法执行时内存空间才会开辟。

    static {
        //k变量可以访问吗？
        // static静态代码块在类加载时执行，并且只执行一次。
        // 类加载时，k变量空间还没有开辟出来呢。
        //错误: 无法从静态上下文中引用非静态 变量 k
        //System.out.println("k = " + k);

        // 这里可以访问name吗？
        //错误: 非法前向引用
        // 静态代码块和静态变量都在类加载的时候执行，时间相同，只能靠代码的顺序来决定谁先谁后。
        //System.out.println("name = " + name);
    }

    // 静态变量在静态代码块下面。
    static String name = "zhangsan";


    //入口(main方法执行之前实际上执行了很多代码)
    public static void main(String[] args){
        System.out.println("main begin");
        System.out.println("main over");
    }
}

/*
总结：
    到目前为止，你遇到的所有java程序，有顺序要求的是哪些？
        第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。
        第二：静态代码块1和静态代码块2是有先后顺序的。
        第三：静态代码块和静态变量是有先后顺序的。(代码的顺序)
*/
```

#### 实例语句块

```java
/*
1、除了静态代码块之外，还有一种语句块叫做：实例语句块
2、实例语句在类加载是并没有执行。
3、实例语句语法？
    {
        java语句;
        java语句;
        java语句;
    }
4、实例语句块在什么时候执行？
    只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。
    实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。
*/
public class InstanceCode{

    //入口
    public static void main(String[] args){
        System.out.println("main begin");
        new InstanceCode();
        new InstanceCode();

        new InstanceCode("abc");
        new InstanceCode("xyz");
    }


    //实例语句块
    {
        System.out.println("实例语句块执行！");	
    }

    // Constructor
    public InstanceCode(){
        System.out.println("无参数构造方法");
    }

    // Constructor
    public InstanceCode(String name){
        System.out.println("有参数的构造方法");
    }

}
```

#### 代码执行顺序

```java
//判断以下程序的执行顺序
public class CodeOrder{
    
    // 静态代码块
    static{
        System.out.println("A");
    }

    // 入口
    // A X Y C B Z
    public static void main(String[] args){
        System.out.println("Y");
        new CodeOrder();
        System.out.println("Z");
    }

    // 构造方法
    public CodeOrder(){
        System.out.println("B");
    }

    // 实例语句块
    {
        System.out.println("C");
    }

    // 静态代码块
    static {
        System.out.println("X");
    }

}
```

### this

- this是一个关键字，是一个引用，保存内存地址指向自身。
- this可以使用在实例方法中，也可以使用在构造方法中。
- this出现在实例方法中其实代表的是当前对象。
- this不能使用在静态方法中。
- this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。
- this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。

```java
/*
    this：
        1、this是一个关键字，全部小写。
        2、this是什么，在内存方面是怎样的？
            一个对象一个this。
            this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
            所以，严格意义上来说，this代表的就是“当前对象”
            this存储在堆内存当中对象的内部。

        3、this只能使用在实例方法中。谁调用这个实例方法，this就是谁。所以this代表的是：当前对象。

        4、“this.”大部分情况下是可以省略的。

        5、为什么this不能使用在静态方法中？this代表当前对象，静态方法中不存在当前对象。
*/

// 顾客类
class Customer{

    // 属性
    // 实例变量（必须采用“引用.”的方式访问）
    String name;   

    //构造方法
    public Customer(){
    
    }

    public Customer(String s){
        this.name = s;
    }

    // 顾客购物的方法
    // 实例方法
    public void shopping(){
        // 这里的this是谁？this是当前对象。
        // c1调用shopping(),this是c1
        // c2调用shopping(),this是c2
        //System.out.println(this.name + "正在购物!");

        // this. 是可以省略的。
        // this. 省略的话，还是默认访问“当前对象”的name。
        System.out.println(name + "正在购物!");
    }

    // 静态方法
    public static void doSome(){
        // this代表的是当前对象，而静态方法的调用不需要对象。矛盾了。
        // 错误: 无法从静态上下文中引用非静态 变量 this
        //System.out.println(this);
    }
}

class Student{

    // 实例变量，怎么访问？必须先new对象，通过“引用.”来访问。
    String name = "zhangsan";

    // 静态方法
    public static void m1(){
        //System.out.println(name);

        // this代表的是当前对象。
        //System.out.println(this.name);

        // 除非你这样
        Student s = new Student();
        System.out.println(s.name);

    }

    //为什么set和get方法是实例方法？this不能出现在静态方法中
    public static void setName(String s){
        name = s;
    }
    public String getName(){
        return name;
    }

    // 又回到上午的问题了？什么时候方法定义为实例方法，什么时候定义为静态方法？
    // 如果方法中直接访问了实例变量，该方法必须是实例方法。
}
```


![1592899792382](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592899792382.png)

```java

// 分析：i变量在main方法中能不能访问？？？？

public class ThisTest02{

    // 实例变量
    int i = 100; // 这个i变量是不是必须先new对象才能访问。

    // 静态变量
    static int k = 111;

    // 静态方法
    public static void main(String[] args){
        // 错误: 无法从静态上下文中引用非静态 变量 i
        // System.out.println(i);

        // 怎么样访问i
        ThisTest02 tt = new ThisTest02();
        System.out.println(tt.i);

        // 静态变量用“类名.”访问。
        System.out.println(ThisTest02.k);

        // 类名. 能不能省略？
        // 可以
        System.out.println(k);
    }
}
```

this什么时候可以省略？

```java

/*
1、this可以使用在实例方法中，不能使用在静态方法中。
2、this关键字大部分情况下可以省略，什么时候不能省略呢？
    在实例方法中，或者构造方法中，为了区分局部变量和实例变量，
    这种情况下：this. 是不能省略的。
*/
public class ThisTest03{
    public static void main(String[] args){

        Student s = new Student();
        s.setNo(111);
        s.setName("张三");
        System.out.println("学号：" + s.getNo());
        System.out.println("姓名：" + s.getName());
    }
}

// 分析一下：以下代码哪里写的不好。
// 学生类
class Student{
    //学号
    private int no;

    //姓名
    private String name;

    // setter and getter方法
    /*
    public void setNo(int i){
        no = i;
    }
    */
    /*
    public void setNo(int no){ // 就近原则。
        no = no; //这两个no都是局部变量no，和实例变量no没关系。
    }
    */
    public void setNo(int no){ 
        //no是局部变量
        //this.no 是指的实例变量。
        this.no = no; // this. 的作用是：区分局部变量和实例变量。
    }
    
    public String getName(){ // getName实际上获取的是“当前对象”的名字。
        //return this.name; // 严格来说，这里是有一个 this. 的。只不过这个 this. 是可以省略的。
        return name;
    }
}
```

this()的使用时机

```java
/*
    1、this除了可以使用在实例方法中，还可以用在构造方法中。
    2、新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：
        this(实际参数列表);
            通过一个构造方法1去调用构造方法2，可以做到代码复用。
            但需要注意的是：“构造方法1”和“构造方法2” 都是在同一个类当中。

    3、this() 这个语法作用是什么？
        代码复用。
    
    4、死记硬背：
        对于this()的调用只能出现在构造方法的第一行。
*/
public class ThisTest04{
    public static void main(String[] args){
        // 调用无参数构造方法
        Date d1 = new Date();
        d1.detail();

        // 调用有参数构造方法
        Date d2 = new Date(2008, 8, 8);
        d2.detail();
    }
}

/*
需求：
    1、定义一个日期类，可以表示年月日信息。
    2、需求中要求：
        如果调用无参数构造方法，默认创建的日期为：1970年1月1日。
        当然，除了调用无参数构造方法之外，也可以调用有参数的构造方法来创建日期对象。
*/
class Date{ // 以后写代码都要封装，属性私有化，对外提供setter and getter
    //年
    private int year;
    //月
    private int month;
    //日
    private int day;

    // 构造方法无参
    // 调用无参数构造方法，初始化的日期是固定值。
    public Date(){
        //错误: 对this的调用必须是构造器中的第一个语句
        this(1970, 1, 1);
    }
    // 构造方法有参数
    public Date(int year, int month, int day){
        this.year = year;
        this.month = month;
        this.day = day;
    }
}
```

this 复习
```java

public class Review{ // 类
    // 类加载机制中，是这样的：在程序执行之前，凡是需要加载的类全部加载到JVM当中。
    // 先完成加载才会执行main方法。
    static{
        System.out.println("Review类加载时执行！");
    }
    // 入口
    // 静态方法
    public static void main(String[] args){
        // 局部变量
        int i = 100;
        // 完成一个对象的一连串动作。
        // 一个学生在教室先学习，学习完成之后去餐厅吃饭。
        Student s1 = new Student();
        // 先学习，所有调用学习这个实例方法。
        s1.study();
        Student s2 = new Student();
    }
}

```

## 继承

继承的作用：
基本作用：子类继承父类，代码可以得到复用。（这个不是重要的作用，是基本作用。）
主要(重要)作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。

举例

```java

// 使用继承机制来解决代码复用问题。
// 继承也是存在缺点的：耦合度高，父类修改，子类受牵连。

// 银行账户类
// 账户的属性：账号、余额
class Account{ // 父类
    // 属性
    private String actno;
    private double balance;

    // 构造方法
    public Account(){
    
    }
    public Account(String actno, double balance){
        this.actno = actno;
        this.balance = balance;
    }

    // setter and getter
    public void setActno(String actno){
        this.actno = actno;
    }
    public String getActno(){
        return actno;
    }
    public void setBalance(double balance){
        this.balance = balance;
    }
    public double getBalance(){
        return balance;
    }
}

// 其它类型的账户：信用卡账户
// 账号、余额、信誉度
class CreditAccount extends Account{ //子类

    // 属性
    private double credit;

    // 构造方法
    public CreditAccount(){
    
    }

    public void doSome(){
        //错误: actno 在 Account 中是 private 访问控制
        //System.out.println(actno);
        // 间接访问
        //System.out.println(this.getActno());
        System.out.println(getActno());
    }

    // setter and getter方法
    public void setCredit(double credit){
        this.credit = credit;
    }
    public double getCredit(){
        return credit;
    }
    
}
```

### 相关特性

1. ①B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。
class A{}
class B extends A{}
我们平时聊天说的比较多的是：父类和子类。superclass 父类, subclass 子类

2. java 中的继承只支持单继承，**不支持多继承**，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：class B extends A,C{ } 这是错误的。

3. 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。

4.  java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)

5.  java 中的类没有显示的继承任何类，则**默认继承 Object类**，Object类是java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有Object类型中所有的特征。

6.  继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CeditAccount 类

子类继承父类之后，能使用子类对象调用父类方法吗？可以，因为子类继承了父类之后，这个方法就属于子类了。当然可以使用子类对象来调用。

在实际开发中，满足什么条件的时候，我可以使用继承呢？
凡是采用“is a”能描述的，都可以继承。
例如：
Cat is a Animal：猫是一个动物
Dog is a Animal：狗是一个动物
CreditAccount is a Account：信用卡账户是一个银行账户
....

假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，
那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够
使用is a来描述。

我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()的，我们进行了测试，发现：System.out.println(引用); 当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后输出toString()方法的执行结果。

## 方法覆盖和多态

### 方法覆盖

#### 何时使用

- 父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。

什么条件满足的时候构成方法覆盖？

- 第一：有继承关系的两个类
- 第二：具有相同方法名、返回值类型、形式参数列表
- 第三：访问权限不能更低。
- 第四：抛出异常不能更多。

```java
/*
    回顾一下方法重载！！！！
        什么时候考虑使用方法重载overload？
            当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样
            代码美观，并且方便编程。
        
        什么条件满足之后能够构成方法重载overload？
            条件一：在同一个类当中
            条件二：方法名相同
            条件三：参数列表不同（个数、顺序、类型）

    --------------------------------------------------------------------------------

    什么时候我们会考虑使用“方法覆盖”呢？
        子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时，
        子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。
    
    方法覆盖又叫做：方法重写（重新编写），英语单词叫做：Override、Overwrite，都可以。
    比较常见的：方法覆盖、方法重写、override

    重要结论：
        当子类对父类继承过来的方法进行“方法覆盖”之后，
        子类对象调用该方法的时候，一定执行覆盖之后的方法。

    当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？
        条件一：两个类必须要有继承关系。
        条件二：重写之后的方法和之前的方法具有：
                    相同的返回值类型、
                    相同的方法名、
                    相同的形式参数列表。
        条件三：访问权限不能更低，可以更高。（这个先记住。）
        条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。（这个先记住）
    
    这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）
        注意1：方法覆盖只是针对于方法，和属性无关。
        注意2：私有方法无法覆盖。
        注意3：构造方法不能被继承，所以构造方法也不能被覆盖。
        注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。

*/
public class OverrideTest02{
    public static void main(String[] args){
        Bird b = new Bird();
        b.move();
        b.sing(1000); //Animal sing....

        Cat c = new Cat();
        c.move();
    }
}

class Animal{
    public void move(){
        System.out.println("动物在移动！");
    }

    public void sing(int i){
        System.out.println("Animal sing....");
    }
}

class Bird extends Animal{

    // 对move方法进行方法覆盖，方法重写，override
    // 最好将父类中的方法原封不动的复制过来。（不建议手动编写）
    // 方法覆盖，就是将继承过来的那个方法给覆盖掉了。继承过来的方法没了。
    public void move(){
        System.out.println("鸟儿在飞翔！！！");
    }

    //protected表示受保护的。没有public开放。
    // 错误：正在尝试分配更低的访问权限; 以前为public
    /*
    protected void move(){
        System.out.println("鸟儿在飞翔！！！");
    }
    */

    //错误：被覆盖的方法未抛出Exception
    /*
    public void move() throws Exception{
        System.out.println("鸟儿在飞翔！！！");
    }
    */

    // 分析：这个sing()和父类中的sing(int i)有没有构成方法覆盖呢？
    // 没有，原因是，这两个方法根本就是两个完全不同的方法。
    // 可以说这两个方法构成了方法重载吗？可以。
    public void sing(){
        System.out.println("Bird sing.....");
    }
}
```


#### 关于Object类中toString()方法的覆盖

toString()方法存在的作用就是：将java对象转换成字符串形式。大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()方法输出的是一个java对象的内存地址。

至于toString()方法具体怎么进行覆盖？格式可以自己定义，或者听需求的。

```java
/*
    关于Object类中的toString()方法
        1、toString()方法的作用是什么？
            作用：将“java对象”转换成“字符串的形式”。

        2、Object类中toString()方法的默认实现是什么？
            public String toString() {
                return getClass().getName() + "@" + Integer.toHexString(hashCode());
            }
            toString: 方法名的意思是转换成String
            含义：调用一个java对象的toString()方法就可以将该java对象转换成字符串的表示形式。

        3、那么toString()方法给的默认实现够用吗？
*/
public class OverrideTest04{
    public static void main(String[] args){
        // 创建一个日期对象
        MyDate t1 = new MyDate();

        // 大家是否还记得：当输出一个引用的时候，println方法会自动调用引用的toString方法。
        System.out.println(t1);

        //创建学生对象
        Student s = new Student(1111, "zhangsan");
        // 重写toString()方法之前
        //System.out.println(s); //Student@87aac27
        // 重写toString()方法之后
        // 输出一个学生对象的时候，可能更愿意看到学生的信息，不愿意看到对象的内存地址。
        System.out.println(s.toString());
        System.out.println(s);//自动调用toString方法
    }
}

// 日期类
class MyDate {
    private int year;
    private int month;
    private int day;
    public MyDate(){
        this(1970,1,1);
    }
    // constructor
    ...
    // setters and getters 
    ...

    // 从Object类中继承过来的那个toString()方法已经无法满足我业务需求了。
    // 我在子类MyDate中有必要对父类的toString()方法进行覆盖/重写。
    // 我的业务要求是：调用toString()方法进行字符串转换的时候，
    // 希望转换的结果是：xxxx年xx月xx日，这种格式。
    // 重写一定要复制粘贴，不要手动编写，会错的。
    public String toString() {
        return year + "年" + month + "月" + day + "日";
    }
}

class Student{
    int no;
    String name;
    public Student(int no, String name){
        this.no = no;
        this.name = name;
    }
    // 重写  方法覆盖
    public String toString() {
        return "学号：" + no + "，姓名：" + name;
    }
}
```

#### 方法重载和方法覆盖的区别

方法重载发生在同一个类当中。
方法覆盖是发生在具有继承关系的父子类之间。
方法重载是一个类中，方法名相同，参数列表不同。
方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：方法名一致、参数列表一致、返回值类型一致。


### 多态

#### 多态的基础语法

向上转型和向下转型的概念

![1592956803661](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592956803661.png)

向上转型：子--->父 (upcasting)
又被称为自动类型转换：Animal a = new Cat();

向下转型：父--->子 (downcasting)
又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。

什么时候需要向下转型？
- 需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。

向下转型有风险吗？
- 容易出现ClassCastException（类型转换异常）

怎么避免这个风险？
- instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象
是否为某一种类型。

-> 养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。

不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。

```java
/*
    多态的基础语法：
        1、学习多态基础语法之前，我们需要普及两个概念：
            第一个：向上转型
                子 ---> 父（自动类型转换）
            第二个：向下转型
                父 ---> 子（强制类型转换，需要加强制类型转换符）

            注意：
                java中允许向上转型，也允许向下转型。

                *****（五颗星）无论是向上转型，还是向下转型，两种类型之间必须有继承关系，没有继承关系编译器报错。
                
                以后在工作过程中，和别人聊天的时候，要专业一些，说向上转型和向下转型，不要说自动类型转换，也不要说强制类型转换，因为自动类型转换和强制类型转换是使用在基本数据类型方面的，在引用类型转换这里只有向上和向下转型。
        
        2、多态指的是：
            父类型引用指向子类型对象。
            包括编译阶段和运行阶段。
            编译阶段：绑定父类的方法。
            运行阶段：动态绑定子类型对象的方法。
            多种形态。
        
        3、什么时候必须使用“向下转型”？
            不要随便做强制类型转换。当你需要访问的是子类对象中“特有”的方法。此时必须进行向下转型。
*/
public class Test01{

    public static void main(String[] args){

        Animal a1 = new Animal();
        a1.move(); //动物在移动！

        Cat c1 = new Cat();
        c1.move(); //cat走猫步！

        Bird b1 = new Bird();
        b1.move(); //鸟儿在飞翔！

        // 代码可以这样写吗？
        /*
            1、Animal和Cat之间有继承关系吗？有的。
            2、Animal是父类，Cat是子类。
            3、Cat is a Animal，这句话能不能说通？能。
            4、经过测试得知java中支持这样的一个语法：
                父类型的引用允许指向子类型的对象。
                Animal a2 = new Cat();
                a2就是父类型的引用。new Cat()是一个子类型的对象。允许a2这个父类型引用指向子类型的对象。
        */
        Animal a2 = new Cat();
        Animal a3 = new Bird();

        // 没有继承关系的两个类型之间存在转型吗？
        // 错误: 不兼容的类型: Dog无法转换为Animal
        // Animal a4 = new Dog();（Dog没有继承Animal）

        // 调用a2的move()方法
        /*
            什么是多态？
                多种形态，多种状态。
            分析：a2.move();
                java程序分为编译阶段和运行阶段。
                先来分析编译阶段：
                    对于编译器来说，编译器只知道a2的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()方法，找到了，绑定上move()方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）
                再来分析运行阶段：
                    运行阶段的时候，实际上在堆内存中创建的java对象是Cat对象，所以move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行Cat对象的move()方法。这个过程属于运行阶段绑定。（运行阶段绑定属于动态绑定。）

            多态表示多种形态：
                编译的时候一种形态。
                运行的时候另一种形态。
        */
        a2.move(); //cat走猫步！
        
        // 调用a3的move()方法
        a3.move(); //鸟儿在飞翔！！！

        // ======================================================================
        Animal a5 = new Cat(); // 底层对象是一只猫。

        // 分析这个程序能否编译和运行呢？
        // 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。
        // 只有编译通过的代码才能运行。没有编译，根本轮不到运行。
        // 错误: 找不到符号
        // why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法
        // 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）
        //a5.catchMouse(); 
        
        // 假设代码写到了这里，我非要调用catchMouse()方法怎么办？
        // 这个时候就必须使用“向下转型”了。（强制类型转换）
        // 以下这行代码为啥没报错？？？？
        // 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。
        Cat x = (Cat)a5;
        x.catchMouse(); //猫正在抓老鼠！！！！

        // 向下转型有风险吗？
        Animal a6 = new Bird(); //表面上a6是一个Animal，运行的时候实际上是一只鸟儿。
        /*
            分析以下程序，编译报错还是运行报错？？？
                编译器检测到a6这个引用是Animal类型，
                而Animal和Cat之间存在继承关系，所以可以向下转型。
                编译没毛病。

                运行阶段，堆内存实际创建的对象是：Bird对象。
                在实际运行过程中，拿着Bird对象转换成Cat对象就不行了。因为Bird和Cat之间没有继承关系。
            
            运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：
                java.lang.ClassCastException：类型转换异常。
            
            java.lang.NullPointerException：空指针异常。这个也非常重要。
        */
        //Cat y = (Cat)a6;
        //y.catchMouse();

        // 怎么避免ClassCastException异常的发生？？？
        /*	
            新的内容，运算符：
                instanceof （运行阶段动态判断）
            第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。
            第二：instanceof的语法：(引用 instanceof 类型)
            第三：instanceof运算符的运算结果只能是：true/false
            第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。
                假设(c instanceof Cat)为true表示:c引用指向的堆内存中的java对象是一个Cat。
                假设(c instanceof Cat)为false表示:c引用指向的堆内存中的java对象不是一个Cat。
            
            程序员要养成一个好习惯：
                任何时候，任何地点，对类型进行向下转型时，一定要使用instanceof 运算符进行判断。（java规范中要求的。）
                这样可以很好的避免：ClassCastException
        */
        System.out.println(a6 instanceof Cat); //false

        if(a6 instanceof Cat){ // 如果a6是一只Cat
            Cat y = (Cat)a6;  // 再进行强制类型转换
            y.catchMouse();
        }
    }
}
```

多种形态，多种状态，编译和运行有两个不同的状态。
编译期叫做静态绑定。
运行期叫做动态绑定。
Animal a = new Cat();
// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
a.move();

多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）

什么时候必须进行向下转型？调用子类对象上特有的方法时。


#### 为什么要用instanceof

```java
public class AnimalTest{
    
    // test方法是程序员B负责编写。
    // 这个test()方法的参数是一个Animal
    public void test(Animal a){ // 实例方法
        // 你写的这个方法别人会去调用。
        // 别人调用的时候可能给你test()方法传过来一个Bird
        // 当然也可能传过来一个Cat
        // 对于我来说，我不知道你调用的时候给我传过来一个啥。
        if(a instanceof Cat){
            Cat c = (Cat)a;
            c.catchMouse();
        }else if(a instanceof Bird){
            Bird b = (Bird)a;
            b.sing();
        }
    }

}
```

#### 多态在开发中的作用

```java
/*

    注意这里的分析：
        主人起初的时候只喜欢养宠物狗狗
        随着时间的推移，主人又喜欢上养“猫咪”
        在实际的开发中这就表示客户产生了新的需求。
        作为软件的开发人员来说，必须满足客户的需求。
        我们怎么去满足客户的需求呢？
            在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。
    
    思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？
        一定要记住：软件在扩展过程当中，修改的越少越好。
        修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。

        其实这里涉及到一个软件的开发原则：
            软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：
                其中有一条最基本的原则：OCP（开闭原则）

        什么是开闭原则？
            对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。
            在软件的扩展过程当中，修改的越少越好。


    高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。

    什么是软件扩展性？
        假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。
        这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。

    面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。
    因为面向具体编程会让软件的扩展力很差。

*/
```

非常重要：五颗星。

多态在开发中的作用是：降低程序的耦合度，提高程序的扩展力。

```java
public class Master{
public void feed(Dog d){}
public void feed(Cat c){}
}

//以上的代码中表示：Master和Dog以及Cat的关系很紧密（耦合度高）。导致扩展力很差。

public class Master{
public void feed(Pet pet){
pet.eat();
}
}
//以上的代表中表示：Master和Dog以及Cat的关系就脱离了，Master关注的是Pet类。
//这样Master和Dog以及Cat的耦合度就降低了，提高了软件的扩展性。
```

有了封装，有了这种整体的概念之后。
对象和对象之间产生了继承。
有了继承之后，才有了方法的覆盖和多态。

这里提到了一个软件开发原则：
七大原则最基本的原则：OCP（对扩展开放，对修改关闭）
目的是：降低程序耦合度，提高程序扩展力。
面向抽象编程，不建议面向具体编程。


#### 解释之前遗留的问题

私有方法无法覆盖。

方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）

总结两句话：私有不能覆盖。静态不谈覆盖。

在方法覆盖中，关于方法的返回值类型。
什么条件满足之后，会构成方法的覆盖呢？

1. 发生具有继承关系的两个类之间。
2. 父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。


```java
/*
    1、方法覆盖需要和多态机制联合起来使用才有意义。
        Animal a = new Cat();
        a.move();
        要的是什么效果？
            编译的时候move()方法是Animal的。
            运行的时候自动调用到子类重写move()方法上。

        假设没有多态机制，只有方法覆盖机制，你觉得有意义吗？
            没有多态机制的话，方法覆盖可有可无。

            没有多态机制，方法覆盖也可以没有，如果父类的方法无法满足
            子类业务需求的时候，子类完全可以定义一个全新的方法。

        方法覆盖和多态不能分开。

    2、静态方法存在方法覆盖吗？
        多态自然就和对象有关系了。
        而静态方法的执行不需要对象。
        所以，一般情况下，我们会说静态方法“不存在”方法覆盖。
        不探讨静态方法的覆盖。

*/
public class OverrideTest05{
    public static void main(String[] args){
        // 静态方法可以使用“引用.”来调用吗？可以
        // 虽然使用“引用.”来调用，但是和对象无关。
        Animal a = new Cat(); //多态
        // 静态方法和对象无关。
        // 虽然使用“引用.”来调用。但是实际运行的时候还是：Animal.doSome()
        a.doSome();
        
        Animal.doSome();
        Cat.doSome();
    }
}

```

“相同的返回值类型”可以修改一下吗？

- 对于返回值类型是基本数据类型来说，必须一致。
- 对于返回值类型是引用数据类型来说，重写之后返回值类型可以变的更小（但意义不大，实际开发中没人这样写。）。

## super

### 与this相比

- super能出现在实例方法和构造方法中。
- super的语法是：“super.”、“super()”
- super不能使用在静态方法中。
- super. 大部分情况下是可以省略的。


```java
/*
    1、super是一个关键字，全部小写。
    2、super和this对比着学习。
        this:
            this能出现在实例方法和构造方法中。
            this的语法是：“this.”、“this()”
            this不能使用在静态方法中。
            this. 大部分情况下是可以省略的。
            this.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。
                public void setName(String name){
                    this.name = name;
                }
            this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中
            其它的构造方法，目的是：代码复用。

        super:
            super能出现在实例方法和构造方法中。
            super的语法是：“super.”、“super()”
            super不能使用在静态方法中。
            super. 大部分情况下是可以省略的。
            super.什么时候不能省略呢？ 
            super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
            的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

    3、super()
        表示通过子类的构造方法调用父类的构造方法。
        模拟现实世界中的这种场景：要想有儿子，需要先有父亲。
    
    4、重要的结论：
        当一个构造方法第一行：
            既没有this()又没有super()的话，默认会有一个super();
            表示通过当前子类的构造方法调用父类的无参数构造方法。
            所以必须保证父类的无参数构造方法是存在的。
    
    5、注意：
        this()和super() 不能共存，它们都是只能出现在构造方法第一行。
    
    6、无论是怎样折腾，父类的构造方法是一定会执行的。（百分百的。）
    
*/
public class SuperTest01{
    public static void main(String[] args){
        // 创建子类对象
        /*
            A类的无参数构造方法！
            B类的无参数构造方法！
        */
        new B();
    }
}

class A{

    // 建议手动的将一个类的无参数构造方法写出来。
    public A(){
        //super(); // 这里也是默认有这一行代码的。
        System.out.println("A类的无参数构造方法！");
    }

    // 一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。
    // 一个类如果手动提供了一个构造方法，那么无参数构造系统将不再提供。
    public A(int i){
        //super();
        System.out.println("A类的有参数构造方法(int)");
    }
}

class B extends A{
    /*
    public B(){
        super();
        System.out.println("B类的无参数构造方法！");
    }
    */

    public B(){
        this("zhangsan");
        // 调用父类中有参数的构造方法
        //super(123);
        System.out.println("B类的无参数构造方法！");
    }

    public B(String name){
        super();
        System.out.println("B类的有参数构造方法(String)");
    }
}
```



```java
/*
    1、举个例子：在恰当的时间使用：super(实际参数列表);
    2、注意：在构造方法执行过程中一连串调用了父类的构造方法，
    父类的构造方法又继续向下调用它的父类的构造方法，但是实际上
    对象只创建了一个。

    3、思考：“super(实参)”到底是干啥的？
        super(实参)的作用是：初始化当前对象的父类型特征。
        并不是创建新对象。实际上对象只创建了1个。
    
    4、super关键字代表什么？
        super关键字代表的就是“当前对象”的那部分父类型特征。
        
    5、 super和this都不能出现在静态方法中。
*/

```

super的使用：
super.属性名   【访问父类的属性】
super.方法名(实参)   【访问父类的方法】
super(实参)   【调用父类的构造方法】


### 什么时候可以省略

super.什么时候不能省略呢？
- 父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。

super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

```java

/*
    1、“this.”和“super.”大部分情况下都是可以省略的。
    2、this. 什么时候不能省略？
        public void setName(String name){
            this.name = name;
        }
    3、super. 什么时候不能省略？
        父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。
*/
    public void shopping(){
        /*
            java是怎么来区分子类和父类的同名属性的？
                this.name：当前对象的name属性
                super.name：当前对象的父类型特征中的name属性。
        */
        System.out.println(this.name + "正在购物!"); // null 正在购物
        System.out.println(super.name + "正在购物!"); // 张三正在购物
        System.out.println(name + "正在购物!"); //null 正在购物
    }
}



/*
    在父和子中有同名的属性，或者说有相同的方法，
    如果此时想在子类中访问父中的数据，必须使用“super.”加以区分。

    super.属性名    【访问父类的属性】
    super.方法名(实参) 【访问父类的方法】
    super(实参)  【调用父类的构造方法】
*/



/*
    通过这个测试得出的结论：
        super 不是引用。super也不保存内存地址，super也不指向任何对象。
        super 只是代表当前对象内部的那一块父类型的特征。
*/
public class SuperTest06 {

    // 实例方法
    public void doSome(){
        // SuperTest06@2f92e0f4
        System.out.println(this);
        // 输出“引用”的时候，会自动调用引用的toString()方法。
        //System.out.println(this.toString());

        //编译错误: 需要'.'
        //System.out.println(super);
    }

    // this和super不能使用在static静态方法中。
    /*
    public static void doOther(){
        System.out.println(this);
        System.out.println(super.xxx);
    }
    */

    // 静态方法，主方法
    public static void main(String[] args){
        SuperTest06 st = new SuperTest06();
        st.doSome();

        // main方法是静态的
        // 错误的。
        /*
        System.out.println(this);
        System.out.println(super.xxxx);
        */
    }
}
```


### final关键字

```java
/*
    final
    1、final是java语言中的一个关键字。
    2、final表示最终的，不可变的。
    3、final可以修饰变量以及方法，还有类等。
    4、final修饰的变量？
    5、final修饰的方法？
    6、final修饰的类？

*/

class A{
}

//B类继承A类，相当于对A类的功能进行扩展。如果你不希望别人对A类型进行扩展。
//你可以给A类加final关键字，这样的话A类就无法继承了。
//错误 ：final修饰的类无法被继承
final class B extends A{

}

//--------------------------------------

class C{
    public final void f(){}
}

class D extends C{
    //public void f(){}
    // 错误：final修饰的方法无法被覆盖和重写
}

//----------------------------------------

class E{
    public static void main(String[] args){
        final int i = 10;
        //i = 20;
        //错误：final修饰的局部变量不能重新赋值（只能赋一次值）
    }
}

//-----------------------------------------

//final修饰的引用变量
/*
    引用是一个变量, 如果用final修饰了，那么他里面的地址就不能变了，但是地址里的东西还是可以变化的，就相当于C++中的 const int*
*/

/*
    final修饰的引用：
    该引用只能指向1个对象，并且它只能永远指向该对象，无法再指向其它对象。并且在该方法执行过程中，该引用指向对象之后，该对象不会被垃圾回收器回收。直到当前方法结束，才会释放空间。
*/

//-----------------------------------------

//final修饰的实例变量

/*
    也是变量，系统会赋上默认值的变量，加上之后，系统就不会自动赋值了，我们必须手动赋值。
    可以在声明的时候赋值（本质也是在构造方法里赋值）
    也能在构造方法里赋值（在构造方法里也不能重新赋值，只能赋值一次）
    只要在系统赋默认值之前赋值就行（构造方法里赋默认值）
*/

//常量：static final 修饰的变量称为常量。建议全部大写，每个单词之间用下划线链接
//永远不变的量建议声明为常量，
//常量和静态变量都是存储在方法区，并且都是在类加载的时候初始化

//常量一般都是public的，所以大多写为 public static final int PI = 3.14;
```

- final修饰的类无法继承。
- final修饰的方法无法覆盖。
- final修饰的变量只能赋一次值。
- final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用
- 指向的对象内部的数据是可以修改的。
- final修饰的实例变量必须手动初始化，不能采用系统默认值。
- final修饰的实例变量一般和static联合使用，称为常量。
- public static final double PI = 3.1415926;

### 抽象类

![1593007439866](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593007439866.png)

```java
/*

    类到对象是实例化。对象到类是抽象。

    抽象类：
        1、什么是抽象类？
            类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类。
            类本身是不存在的，所以抽象类无法创建对象《无法实例化》。

        2、抽象类属于什么类型？
            抽象类也属于引用数据类型。

        3、抽象类怎么定义？《能把基础语法先学会》
            语法：
                [修饰符列表] abstract class 类名{
                    类体;
                }

        4、抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。

        5、final和abstract不能联合使用，这两个关键字是对立的。

        6、抽象类的子类可以是抽象类。也可以是非抽象类。

        7、抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。super

        8、抽象类关联到一个概念：抽象方法。什么是抽象方法呢？
            抽象方法表示没有实现的方法，没有方法体的方法。例如：
                public abstract void doSome();
                抽象方法特点是：
                    特点1：没有方法体，以分号结尾。
                    特点2：前面修饰符列表中有abstract关键字。

        9、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。
*/
public class AbstractTest01{
    public static void main(String[] args){
        // 错误: Account是抽象的; 无法实例化
        //Account act = new Account();
    }
}

// 银行账户类
/*
final abstract class Account{}
错误: 非法的修饰符组合: abstract和final
*/

abstract class Account{
    /*
    public Account(){}
    public Account(String s){}
    */
    // 非抽象方法
    public void doOther(){}

    // 抽象方法
    public abstract void withdraw();
}

// 子类继承抽象类，子类可以实例化对象
/*
class CreditAccount extends Account{
    public CreditAccount(){
        super();
    }
}
*/

// 抽象类的子类可以是抽象类吗？可以
/*
abstract class CreditAccount extends Account{}
*/

/*
    抽象类：

        1、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。

        2、重要结论：重要结论五颗星*****（必须记住）
            一个非抽象的类继承抽象类，必须将抽象类中的所有抽象方法实现了。
            这是java语法上强行规定的，必须的，不然编译器就报错了。

            这里的覆盖或者说重写，也可以叫做实现。（对抽象的实现。）

*/
public class AbstractTest02{
    public static void main(String[] args){
        // 能不能使用多态?
        // 父类型引用指向子类型对象。
        Animal a = new Bird();  // 向上转型。（自动类型转换）

        // 这就是面向抽象编程。
        // 以后你都是调用的a.XXXX
        // a的类型是Animal，Animal是抽象的
        // 面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力。
        // 这种编程思想符合OCP原则。
        /*
            分析以下：
                编译的时候这个move()方法是谁的？
                运行的时候这个move()方法又是谁的？
        */
        a.move();

        // 多态（当对多态不是很理解的时候，以后写代码能用多态就用多态。慢慢就理解了。）
        Animal x = new Cat();
        x.move();
    }


// 动物类（抽象类）
abstract class Animal{

    // 抽象方法
    public abstract void move();
}

// 子类（非抽象的）
// 错误: Bird不是抽象的, 并且未覆盖Animal中的抽象方法move()
/*
class Bird extends Animal{
}
*/

class Bird extends Animal{
    // 需要将从父类中继承过来的抽象方法进行覆盖/重写，或者也可以叫做“实现”。
    // 把抽象的方法实现了。
    public void move(){
        System.out.println("鸟儿在飞翔！");
    }
}

class Cat extends Animal{
    public void move(){
        System.out.println("猫在走猫步！");
    }
}

// 如果Bird是抽象类的话，那么这个Animal中继承过来的抽象方法也可以不去重写/覆盖/实现。
/*
abstract class Bird extends Animal{
}
*/
```

- 抽象类怎么定义？在class前添加abstract关键字就行了。
- 抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。
- final和abstract不能联合使用，这两个关键字是对立的。
- 抽象类的子类可以是抽象类。也可以是非抽象类。
- 抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。
- 抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。
- 抽象方法怎么定义？public abstract void doSome();
- 一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。

面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。错误的。
Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们都不是抽象方法，例如：public native int hashCode();这个方法底层调用了C++写的动态链接库程序。前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。

### 接口

#### 基础语法

```java
/*
    接口：
        1、接口也是一种“引用数据类型”。编译之后也是一个class字节码文件。
        2、接口是完全抽象的。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。
        3、接口怎么定义，语法是什么？
            [修饰符列表] interface 接口名{}
        4、接口支持多继承，一个接口可以继承多个接口。
        5、接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法。接口中没有其它内容了。只有以上两部分。
        6、接口中所有的元素都是public修饰的。（都是公开的。）
        7、接口中的抽象方法定义时：public abstract修饰符可以省略。
        8、接口中的方法都是抽象方法，所以接口中的方法不能有方法体。
        9、接口中的常量的public static final可以省略。
*/
public class Test01{
    public static void main(String[] args){

        // 访问接口的常量。
        System.out.println(MyMath.PI);

        // 常量能重新赋值吗？
        //错误: 无法为最终变量PI分配值
        //MyMath.PI = 3.1415928;
    }
}

// 定义接口
interface A{

}

// 接口支持继承
interface B extends A{

}

// 一个接口可以继承多个接口（支持多继承）
interface C extends A, B{
}

// 我的数学接口
interface MyMath{

    // 常量
    //public static final double PI = 3.1415926;

    // public static final可以省略吗？
    double PI = 3.1415926;

    // 抽象方法
    //public abstract int sum(int a, int b);

    // 接口当中既然都是抽象方法，那么在编写代码的时候，public abstract可以省略吗？可以
    int sum(int a, int b);

    // 接口中的方法可以有方法体吗？
    // 错误: 接口抽象方法不能带有主体
    /*
    void doSome(){}
    */

    // 相减的抽象方法
    int sub(int a, int b);

}

```

- 接口是一种“引用数据类型”。
- 接口是完全抽象的。
- 接口怎么定义：[修饰符列表] interface 接口名{}
- 接口支持多继承。
- 接口中只有常量+抽象方法。
- 接口中所有的元素都是public修饰的
- 接口中抽象方法的public abstract可以省略。
- 接口中常量的public static final可以省略。
- 接口中方法不能有方法体。

```java
/*
    接口的基础语法：
        1、类和类之间叫做继承，类和接口之间叫做实现。
        别多想：你仍然可以将"实现"看做“继承”。
        继承使用extends关键字完成。
        实现使用implements关键字完成。

        2、五颗星（*****）：当一个非抽象的类实现接口的话，必须将接口中所有的
        抽象方法全部实现（覆盖、重写）。
*/

public class Test02{
    public static void main(String[] args){
        //错误: MyMath是抽象的; 无法实例化
        //new MyMath();

        // 能使用多态吗？可以。
        //Animal a = new Cat();

        // 父类型的引用指向子类型的对象
        MyMath mm = new MyMathImpl();
        // 调用接口里面的方法（面向接口编程。）
        int result1 = mm.sum(10, 20);
        System.out.println(result1);
    }
}

// 特殊的抽象类，完全抽象的，叫做接口。
interface MyMath{
    double PI = 3.1415926;
    int sum(int a, int b);
    int sub(int a, int b);
}

// 这样没问题
/*
abstract class MyMathImpl implements MyMath {}
*/

// 编写一个类（这个类是一个“非抽象”的类）
// 这个类的名字是随意的。
//错误: MyMathImpl不是抽象的, 并且未覆盖MyMath中的抽象方法sub(int,int)
/*
class MyMathImpl implements MyMath {}
*/

//修正
class MyMathImpl implements MyMath {

    //错误：正在尝试分配更低的访问权限; 以前为public
    /*
    int sum(int a, int b){
        return a + b;
    }
    */

    // 重写/覆盖/实现 接口中的方法（通常叫做实现。）
    public int sum(int a, int b){	return a + b;	}

    public int sub(int a, int b){	return a - b;	}
}

```

```java

/*
    接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？对于计算机来说，一个机箱上有多个接口，一个接口是接键盘的，一个接口是接鼠标的，一个接口是接电源的，一个接口是接显示器的.....

    重点（五颗星*****）：一个类可以同时实现多个接口。

    这种机制弥补了java中的哪个缺陷？
        java中类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中存在多继承，java中的接口弥补了单继承带来的缺陷。接口A和接口B虽然没有继承关系，但是写代码的时候，可以互转。编译器没意见。但是运行时可能出现：ClassCastException

    之前有一个结论：
        无论向上转型还是向下转型，两种类型之间必须要有继承关系，没有继承关系编译器会报错。（这句话不适用在接口方面。）

        最终实际上和之前还是一样，需要加：instanceof运算符进行判断。向下转型养成好习惯。转型之前先if+instanceof进行判断。
*/
public class Test03{
    public static void main(String[] args){
        // 多态该怎么用呢？
        // 都是父类型引用指向子类型对象
        A a = new D();
        //a.m2(); // 编译报错。A接口中没有m2()方法。
        B b = new D();
        C c = new D();

        // 这个编译没问题，运行也没问题。
        // 调用其他接口中的方法，你需要转型（接口转型。）
        B b2 = (B)a;
        b2.m2();

        // 直接向下转型为D可以吗？可以
        D d = (D)a;
        d.m2();

        M m = new E();
        // 经过测试：接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转。
        // 但是一定要注意，运行时可能会出现ClassCastException异常。
        // 编译没问题，运行有问题。
        //K k = (K)m;
        if(m instanceof K){
            K k = (K)m;
        }
    }
}

interface K{}

interface M{}

class E implements M{}

// --------------------------------------------------------------------

interface X{}
interface Y{}
interface Z extends X,Y{ //接口和接口支持多继承。}

//------------------------------------------------------------------

interface A{void m1();}
interface B{void m2();}
interface C{void m3();}

// 实现多个接口，其实就类似于多继承。
class D implements A,B,C{
    public void m1(){}
    public void m2(){}
    public void m3(){}
}
```

```java
/*
    继承和实现都存在的话，代码应该怎么写？
        extends 关键字在前。
        implements 关键字在后。
*/
public class Test04{
    public static void main(String[] args){
        // 创建对象（表面看Animal类没起作用！）
        Flyable f = new Cat(); //多态。
        f.fly();

        // 同一个接口
        Flyable f2 = new Pig();
        // 调用同一个fly()方法，最后的执行效果不同。
        f2.fly();

        Flyable f3 = new Fish();
        f3.fly();
    }
}

// 动物类：父类
class Animal{}

// 接口通常提取的是行为动作。
interface Flyablevoid fly();}

// 动物类子类：猫类
// Flyable是一个接口，是一对翅膀的接口，通过接口插到猫身上，让猫变的可以飞翔。
class Cat extends Animal implements Flyable{
    public void fly(){
        System.out.println("飞猫起飞，翱翔太空的一只猫，很神奇，我想做一只猫！！");
    }
}

// 蛇类，如果你不想让它飞，可以不实现Flyable接口
// 没有实现这个接口表示你没有翅膀，没有给你插翅膀，你肯定不能飞。
class Snake extends Animal{
}

// 想飞就插翅膀这个接口。
class Pig extends Animal implements Flyable{
    public void fly(){
        System.out.println("我是一只会飞的猪！！！");
    }
}

// 鱼（默认实际上是存在继承的，默认继承Object。）
/*
class Fish extends Object implements Flyable{
}
*/
class Fish implements Flyable{ //没写extends，也是有的，默认继承Object。
    public void fly(){
        System.out.println("我是六眼飞鱼（流言蜚语）！！！");
    }
}
```

- 一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。
- 一个类可以实现多个接口。
- extends和implements可以共存，extends在前，implements在后。
- 使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。

#### 在开发中的作用(解耦合)

```java
// 顾客
public class Customer{
    // 顾客手里有一个菜单
    // Customer has a FoodMenu!（这句话什么意思：顾客有一个菜单）
    // 记住：以后凡是能够使用 has a 来描述的，统一以属性的方式存在。
    // 实例变量，属性
    // 面向抽象编程，面向接口编程。降低程序的耦合度，提高程序的扩展力。
    private FoodMenu foodMenu;

    // 如果以下这样写，就表示写死了（焊接了。没有可插拔了。）
    // 中餐厨师
    //ChinaCooker cc;

    // 西餐厨师
    //AmericCooker ac

    // 构造方法
    public Customer(){
    }
    public Customer(FoodMenu foodMenu){
        this.foodMenu = foodMenu;
    }

    // setter and getter
    public void setFoodMenu(FoodMenu foodMenu){
        this.foodMenu = foodMenu;
    }
    public FoodMenu getFoodMenu(){
        return foodMenu;
    }

    // 提供一个点菜的方法
    public void order(){
        // 先拿到菜单才能点菜
        // 调用get方法拿菜单。
        //FoodMenu fm = this.getFoodMenu();
        // 也可以不调用get方法，因为在本类中私有的属性是可以访问
        foodMenu.shiZiChaoJiDan();
        foodMenu.yuXiangRouSi();
    }
}

/*
    Cat is a Animal，但凡满足is a的表示都可以设置为继承。
    Customer has a FoodMenu，但凡是满足has a的表示都以属性的形式存在。
*/

//西餐厨师
// 实现菜单上的菜
// 厨师是接口的实现者。
public class AmericCooker implements FoodMenu{

    // 西红柿炒蛋
    public void shiZiChaoJiDan(){
        System.out.println("西餐师傅做的西红柿炒鸡蛋！");
    }

    // 鱼香肉丝
    public void yuXiangRouSi(){
        System.out.println("西餐师傅做的鱼香肉丝！");
    }
}

//中餐厨师
// 实现菜单上的菜
// 厨师是接口的实现者。
public class ChinaCooker implements FoodMenu{

    // 西红柿炒蛋
    public void shiZiChaoJiDan(){
        System.out.println("中餐师傅做的西红柿炒鸡蛋，东北口味！");
    }

    // 鱼香肉丝
    public void yuXiangRouSi(){
        System.out.println("中餐师傅做的鱼香肉丝，东北口味！");
    }
}


/*
    接口：菜单，抽象的
*/
public interface FoodMenu{

    // 西红柿炒蛋
    void shiZiChaoJiDan();

    // 鱼香肉丝
    void yuXiangRouSi();

}

public class Test{
    public static void main(String[] args){

        // 创建厨师对象
        //FoodMenu cooker1 = new ChinaCooker();
        FoodMenu cooker1 = new AmericCooker();

        // 创建顾客对象
        Customer customer = new Customer(cooker1);

        // 顾客点菜
        customer.order();
    }

```

注意：接口在开发中的作用，类似于多态在开发中的作用。

多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。

接口在开发中的作用？
接口是不是完全的？是。
而我们以后正好要求，面向抽象编程。面向抽象编程这句话以后可以修改为：面向接口编程。有了接口就有了可插拔。可插拔表示扩展力很强。不是焊接死的。
主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来。这叫做高扩展性。（低耦合度。）

接口有什么用？扩展性好。可插拔。
接口是一个抽象的概念。

总结一句话：三个字“解耦合”
面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）

接口可以解耦合，解开的是谁和谁的耦合 ? 任何一个接口都有调用者和实现者。接口可以将调用者和实现者解耦合。调用者面向接口调用。实现者面向接口编写实现。

以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，
模块和模块之间采用接口衔接。降低耦合度。

#### 类型之间的关系

```java

/*
is a（继承）、has a（关联）、like a（实现）
is a：
    Cat is a Animal（猫是一个动物）
    凡是能够满足is a的表示“继承关系”
A extends B
*/

/*
has a：
    I has a Pen（我有一支笔）
    凡是能够满足has a关系的表示“关联关系”
    关联关系通常以“属性”的形式存在。
A{
B b;
}
*/

/*
like a：
    Cooker 1ike a Foodienu（厨师像一个菜单一样）凡是能够满足likea关系的表示实现关系”
    实现关系通常是：类实现接口。
A implements B
*/
```


#### 抽象类和接口的区别

在这里我们只说一下抽象类和接口在语法上的区别。
至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会/学习。

抽象类是半抽象的。
接口是完全抽象的。

抽象类中有构造方法。
接口中没有构造方法。

接口和接口之间支持多继承。
类和类之间只能单继承。

一个类可以同时实现多个接口。
一个抽象类只能继承一个类（单继承）。

接口中只允许出现常量和抽象方法。

这里先透露一个信息：
以后接口使用的比抽象类多。一般抽象类使用的还是少。
接口一般都是对“行为”的抽象。

### package和import

```java
/*
    关于java语言中的package和import机制：

        1、为什么要使用package？
            package是java中包机制。包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。（按照功能划分的，不同的软件包具有不同的功能。）

        2、package怎么用？
            package是一个关键字，后面加包名。例如：	package com.bjpowernode.javase.chapter17;  		注意：package语句只允许出现在java源代码的第一行。

        3、包名有没有命名规范？有
            一般都采用公司域名倒序的方式（因为公司域名具有全球唯一性。）
            包名命名规范：
                公司域名倒序 + 项目名 + 模块名 + 功能名

        4、对于带有package的java程序怎么编译？怎么运行？

            采用之前的编译和运行不行了。
            类名不再是：HelloWorld了。
            类名是：com.bjpowernode.javase.chapter17.HelloWorld

            编译：
                javac -d . HelloWorld.java
                解释一下：
                    javac 负责编译的命令
                    -d		带包编译
                    .		代表编译之后生成的东西放到当前目录下（点代表当前目录）
                    HelloWorld.java  被编译的java文件名。

            运行：
                java com.bjpowernode.javase.chapter17.HelloWorld

        5、关于import的使用。

            import什么时候使用？
                A类中使用B类。
                A和B类都在同一个包下。不需要import。
                A和B类不在同一个包下。需要使用import。
                java.lang.*;这个包下的类不需要使用import导入。

            import怎么用？
                import语句只能出现在package语句之下，class声明语句之上。
                import语句还可以采用星号的方式。(导入所有类)
*/
package com.bjpowernode.javase.chapter17;
import com.bjpowernode.javase.chapter17.*;

public class HelloWorld{
    public static void main(String[] args){
        System.out.println("Hello World!");
    }
}

//-------------------Scanner解释---------------------

//import java.util.Scanner;
import java.util.*;

public class Test03{
    public static void main(String[] args){

        // 为什么要这样写？
        // Test03类和Scanner类不在同一个包下。
        // java.util就是Scanner类的包名。
        //java.util.Scanner s = new java.util.Scanner(System.in);

        Scanner s = new Scanner(System.in);
        String str = s.next();
        System.out.println("您输入的字符串是--->" + str);
    }
}
```

- package出现在java源文件第一行。
- 带有包名怎么编译？javac -d . xxx.java
- 怎么运行？java 完整类名

补充：以后说类名的时候，如果带着包名描述，表示完整类名。
如果没有带包，描述的话，表示简类名。
java.util.Scanner 完整类名。
Scanner 简类名

import什么时候不需要？
java.lang不需要。
同包下不需要。
其它一律都需要。

怎么用？
import 完整类名;
import 包名.*;

import java.util.Scanner; // 完整类名。

// 同学的疑问：这样是不是效率比较低。
// 这个效率不低，因为编译器在编译的时候，会自动把*变成具体的类名。
import java.util.*;

// 想省懒劲你不能太省了。
import java.*; 这是不允许的，因为在java语言中规定，这里的*只代表某些类的名字。

### objective类

目前为止我们只需要知道这几个方法即可：

- protected Object clone()   // 负责对象克隆的。
- int hashCode()// 获取对象哈希值的一个方法。
- boolean equals(Object obj)  // 判断两个对象是否相等
- String toString()  // 将对象转换成字符串形式
- protected void finalize()  // 垃圾回收器负责调用的方法

#### toString()

```java
/*
    关于Object类中的toString()方法

        1、源代码长什么样？
            public String toString() {
                return this.getClass().getName() + "@" + Integer.toHexString(hashCode());
            }
            源代码上toString()方法的默认实现是：
                类名@对象的内存地址转换为十六进制的形式

        2、SUN公司设计toString()方法的目的是什么？
            toString()方法的作用是什么？
                toString()方法的设计目的是：通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”

        3、其实SUN公司开发java语言的时候，建议所有的子类都去重写toString()方法。toString()方法应该是一个简洁的、详实的、易阅读的.
*/
public class Test01{
    public static void main(String[] args){
        MyTime t1 = new MyTime(1970, 1, 1);
        // 一个日期对象转换成字符串形式的话，我可能还是希望能看到具体的日期信息。
        String s1 = t1.toString();

        //MyTime类重写toString()方法之前
        //System.out.println(s1); // MyTime@28a418fc

        //MyTime类重写toString()方法之后
        System.out.println(s1); // 1970年1月1日


        // 注意：输出引用的时候，会自动调用该引用的toString()方法。
        System.out.println(t1);
    }
}
class MyTime{
    int year;
    int month;
    int day;

    public MyTime(){

    }

    public MyTime(int year, int month, int day){
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // 重写toString()方法
    // 这个toString()方法怎么重写呢？
    // 越简洁越好，可读性越强越好。
    // 向简洁的、详实的、易阅读的方向发展
    public String toString(){
        //return this.year + "年" + this.month + "月" + this.day + "日";
        return this.year + "/" + this.month + "/" + this.day;
    }
}
```

- 以后所有类的toString()方法是需要重写的。
- 重写规则，越简单越明了就好。
- System.out.println(引用); 这里会自动调用“引用”的toString()方法。
- ring类是SUN写的，toString方法已经重写了。

#### equals()

```java
/*
    关于Object类中的equals方法
        1、equals方法的源代码
            public boolean equals(Object obj) {
                return (this == obj);
            }
            以上这个方法是Object类的默认实现。

        2、SUN公司设计equals方法的目的是什么？
            以后编程的过程当中，都要通过equals方法来判断两个对象是否相等。equals方法是判断两个对象是否相等的。

        3、我们需要研究一下Object类给的这个默认的equals方法够不够用！！！！
                在Object类中的equals方法当中，默认采用的是“==”判断两个java对象是否相等。而“==”判断的是两个java对象的内存地址，我们应该判断两个java对象的内容是否相等。所以老祖宗的equals方法不够用，需要子类重写equals。

        4、判断两个java对象是否相等，不能使用“==”，因为“==”比较的是两个对象的内存地址。
*/
public class Test02{
    public static void main(String[] args){

        // 判断两个基本数据类型的数据是否相等直接使用“==”就行。
        int a = 100;int b = 100;
        // 这个“==”是判断a中保存的100和b中保存的100是否相等。
        System.out.println(a == b); //true（相等） false(不相等)

        // 判断两个java对象是否相等，我们怎么办？能直接使用“==”吗？
        // 创建一个日期对象是：2008年8月8日。
        MyTime t1 = new MyTime(2008, 8, 8); //MyTime t1 = 0x1234;
        // 创建了一个新的日期对象，但表示的日期也是：2008年8月8日。
        MyTime t2 = new MyTime(2008, 8, 8); //MyTime t2 = 0x3698;

        //测试以下，比较两个对象是否相等，能不能使用“==”？？？
        // 这里的“==”判断的是：t1中保存的对象内存地址和t2中保存的对象内存地址是否相等。
        System.out.println(t1 == t2); // false

        // 重写Object equals方法之前（比较的是对象内存地址）
        // 重写Object equals方法之后（比较的是内容。）
        boolean flag = t1.equals(t2);
        System.out.println(flag); //true

        // 再创建一个新的日期
        MyTime t3 = new MyTime(2008, 8, 9);
        // 两个日期不相等，就是false。
        System.out.println(t1.equals(t3)); // false

        // 我们这个程序有bug吗？可以运行，但是效率怎么样？低（怎么改造。）
        MyTime t4 = null;
        System.out.println(t1.equals(t4)); //false
    }
}

class MyTime { //extends Object{
    int year;int month;int day;

    public MyTime(){}
    public MyTime(int year, int month, int day){
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // 默认的equals方法
    /*
    public boolean equals(Object obj) {
        return (this == obj);
    }
    */


    // 重写Object类的equals方法
    // 怎么重写？复制粘贴。相同的返回值类型、相同的方法名、相同的形式参数列表。
    // equals到底应该怎么重写？你自己定，你认为两个对象什么相等的时候表示相等，你就怎么重写。
    public boolean equals(Object obj) {
        // 当年相同，月相同，并且日也相同的时候，表示两个日期相同。两个对象相等。
        // 获取第一个日期的年月日
        int year1 = this.year;
        int month1 = this.month;
        int day1 = this.day;

        // 获取第二个日期的年月日
        //int year2 = obj.year;
        //int month2 = obj.month;
        //int day2 = obj.day;

        if(obj instanceof MyTime){
            MyTime t = (MyTime)obj;
            int year2 = t.year;
            int month2 = t.month;
            int day2 = t.day;
            if(year1 == year2 && month1 == month2 && day1 == day2){
                return true;
            }
        }
        // 程序能够执行到此处表示日期不相等。
        return false;
    }

    //改良。

    public boolean equals(Object obj) {
        // 如果obj是空，直接返回false
        if(obj == null){
            return false;
        }
        // 如果obj不是一个MyTime，没必要比较了 ，直接返回false
        if(!(obj instanceof MyTime)){
            return false;
        }
        // 如果this和obj保存的内存地址相同，没必要比较了，直接返回true。
        // 内存地址相同的时候指向的堆内存的对象肯定是同一个。
        if(this == obj){
            return true;
        }
        // 程序能够执行到此处说明什么？
        // 说明obj不是null，obj是MyTime类型。
        MyTime t = (MyTime)obj;
        return this.year == t.year && this.month == t.month && this.day == t.day ;
    }

//===最终版本===
    public boolean equals(Object obj) {
        if(obj == null || !(obj instanceof MyTime)){
            return false;
        }
        if(this == obj){
            return true;
        }
        MyTime t = (MyTime)obj;
        return this.year == t.year && this.month == t.month && this.day == t.day ;
    }

}

/*
class Person{
    private String idCard;
}
*/


/*
    java语言当中的字符串String有没有重写toString方法，有没有重写equals方法。

    总结：
        1、String类已经重写了equals方法，比较两个字符串不能使用==，必须使用equals。equals是通用的。

        2、String类已经重写了toString方法。

    大结论：
        java中什么类型的数据可以使用“==”判断java中基本数据类型比较是否相等，使用==

        java中什么类型的数据需要使用equals判断java中所有的引用数据类型统一使用equals方法来判断是否相等。

        这是规矩。
*/
public class Test03{
    public static void main(String[] args){

        // 大部分情况下，采用这样的方式创建字符串对象
        String s1 = "hello";
        String s2 = "abc";

        // 实际上String也是一个类。不属于基本数据类型。
        // 既然String是一个类，那么一定存在构造方法。
        String s3 = new String("Test1");
        String s4 = new String("Test1");
        // new两次，两个对象内存地址，s3保存的内存地址和s4保存的内存地址不同。
        // == 判断的是内存地址。不是内容。
        System.out.println(s3 == s4); // false

        // 比较两个字符串能不能使用双等号？
        // 不能，必须调用equals方法。
        // String类已经重写equals方法了。
        System.out.println(s3.equals(s4)); // true

        // String类有没有重写toString方法呢？
        String x = new String("动力节点");
        // 如果String没有重写toString()方法，输出结果：java.lang.String@十六进制的地址
        // 经过测试：String类已经重写了toString()方法。
        System.out.println(x.toString()); //动力节点
        System.out.println(x); //动力节点
    }
}

class Student{
    // 学号
    int no; //基本数据类型，比较时使用：==
    // 所在学校
    String school; //引用数据类型，比较时使用：equals方法。

    public Student(){}
    public Student(int no,String school){
        this.no = no;
        this.school = school;
    }

    // 重写toString方法
    public String toString(){
        return "学号" + no + "，所在学校名称" + school;
    }

    // 重写equals方法
    // 需求：当一个学生的学号相等，并且学校相同时，表示同一个学生。
    // 思考：这个equals该怎么重写呢？
    // equals方法的编写模式都是固定的。架子差不多。
    public boolean equals(Object obj){
        if(obj == null || !(obj instanceof Student)) return false;
        if(this == obj) return true;
        Student s = (Student)obj;
        return this.no == s.no && this.school.equals(s.school);

        //字符串用双等号比较可以吗？
        // 不可以
        //return this.no == s.no && this.school == s.school;
    }
}

// equals方法重写的时候要彻底。

public class Test05{
    public static void main(String[] args){

        // 多态（自动类型转换。）
        Object o1 = new String("hello world!");
        Object o2 = new User();
        Object o3 = new Address();

        User u1 = new User("zhangsan", new Address("北京","大兴区","11111"));
        User u2 = new User("zhangsan", new Address("北京","大兴区","11111"));

        System.out.println(u1.equals(u2)); // true

        User u3 = new User("zhangsan", new Address("北京","朝阳区","11112"));
        System.out.println(u1.equals(u3)); // false
    }
}

class User{
    // 用户名
    String name;
    // 用户的住址
    Address addr;

    public User(){
    }
    public User(String name, Address addr){
        this.name = name;
        this.addr = addr;
    }

    // 重写equals方法
    // 重写规则：当一个用户的用户名和家庭住址都相同，表示同一个用户。
    // 这个equals判断的是User对象和User对象是否相等。
    public boolean equals(Object obj){
        // 用户名和用户名相同，住址和住址相同的时候，认定是同一个用户。
        if(obj == null || !(obj instanceof User)) return false;
        if(this == obj) return true;

        User u = (User)obj;
        if(this.name.equals(u.name) && this.addr.equals(u.addr)){
            return true;
        }
        return false;
    }
}

class Address{
    String city;
    String street;
    String zipcode;

    public Address(){

    }
    public Address(String city,String street,String zipcode){
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }

    // 注意：这里并没有重写equals方法。
    // 这里的equals方法判断的是：Address对象和Address对象是否相等。
    public boolean equals(Object obj){
        if(obj == null || !(obj instanceof Address)) return false;
        if(this == obj) return true;
        // 怎么算是家庭住址相同呢？
        // 城市相同，街道相同，邮编相同，表示相同。
        Address a = (Address)obj;
        if(this.city.equals(a.city)
            && this.street.equals(a.street)
            && this.zipcode.equals(a.zipcode)){
            return true;
        }
        return false;
    }
}
```

- 以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。
- 重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。
- 基本数据类型比较实用：==
- 对象和对象比较：调用equals方法
- String类是SUN编写的，所以String类的equals方法重写了。
- 以后判断两个字符串是否相等，最好不要使用==，要调用字符串对象的equals方法。
- 注意：重写equals方法的时候要彻底。

#### finalize()【非重点】【jdk9之后就没了】

```java
/*
    关于Object类中的finalize()方法。（非重点  非重点  非重点  了解即可。）

        1、在Object类中的源代码：
            protected void finalize() throws Throwable { }

            GC：负责调用finalize()方法。

        2、finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。

        3、这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。
        不像equals toString，equals和toString()方法是需要你写代码调用的。
        finalize()只需要重写，重写完将来自动会有程序来调用。

        4、finalize()方法的执行时机：
            当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用
            finalize()方法。

        5、finalize()方法实际上是SUN公司为java程序员准备的一个时机，垃圾销毁时机。
        如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法当中。

        6、静态代码块的作用是什么？
            static {
                ....
            }
            静态代码块在类加载时刻执行，并且只执行一次。
            这是一个SUN准备的类加载时机。

            finalize()方法同样也是SUN为程序员准备的一个时机。
            这个时机是垃圾回收时机。

        7、提示：
            java中的垃圾回收器不是轻易启动的，
            垃圾太少，或者时间没到，种种条件下，
            有可能启动，也有可能不启动。
*/
public class Test06{
    public static void main(String[] args){
        /*
        // 创建对象
        Person p = new Person();

            // 有一段代码可以建议垃圾回收器启动。
            if(i % 2 == 0){
                System.gc(); // 建议启动垃圾回收器。（只是建议，可能不启动，也可能启动。启动的概率高了一些。）
            }

    }
}

// 项目开发中有这样的业务需求：所有对象在JVM中被释放的时候，请记录一下释放时间！！！
// 记录对象被释放的时间点，这个负责记录的代码写到哪里？
// 写到finalize()方法中。
class Person{

    // 重写finalize()方法
    // Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用：p.finalize();
    protected void finalize() throws Throwable {
        // this代表当前对象
        System.out.println(this + "即将被销毁！");
    }
}
```

这个方法是protected修饰的，在Object类中这个方法的源代码是？
protected void finalize() throws Throwable { }

#### hashCode

```java
/*
    hashCode方法：
        在Object中的hashCode方法是怎样的？
            public native int hashCode();

            这个方法不是抽象方法，带有native关键字，底层调用C++程序。

        hashCode()方法返回的是哈希码：
            实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。
            所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。
*/
public class Test07{
    public static void main(String[] args){
        Object o = new Object();
        int hashCodeValue = o.hashCode();

        // 对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。
        System.out.println(hashCodeValue); //798154996

        MyClass mc = new MyClass();
        int hashCodeValue2 = mc.hashCode();
        System.out.println(hashCodeValue2); //1392838282

        MyClass mc2 = new MyClass();
        System.out.println(mc2.hashCode()); // 523429237
    }
}

class MyClass
{
}
```

#### 匿名内部类

```java
/*
    匿名内部类：

        1、什么是内部类？
            内部类：在类的内部又定义了一个新的类。被称为内部类。

        2、内部类的分类：
            静态内部类：类似于静态变量
            实例内部类：类似于实例变量
            局部内部类：类似于局部变量

        3、使用内部类编写的代码，可读性很差。能不用尽量不用。

        4、匿名内部类是局部内部类的一种。
            因为这个类没有名字而得名，叫做匿名内部类。

        5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。
        并不代表以后都要这样写。因为匿名内部类有两个缺点：
            缺点1：太复杂，太乱，可读性差。
            缺点2：类没有名字，以后想重复使用，不能用。

        6、不理解算了，你只要记住这种写法就行。
*/

class Test01{

    // 静态变量
    static String country;
    // 该类在类的内部，所以称为内部类
    // 由于前面有static，所以称为“静态内部类”
    static class Inner1{
    }

    // 实例变量
    int age;
    // 该类在类的内部，所以称为内部类
    // 没有static叫做实例内部类。
    class Inner2{
    }

    // 方法
    public void doSome(){
        // 局部变量
        int i = 100;
        // 该类在类的内部，所以称为内部类
        // 局部内部类。
        class Inner3{
        }
    }

    public void doOther(){
        // doSome()方法中的局部内部类Inner3，在doOther()中不能用。
    }

    // main方法，入口
    public static void main(String[] args){
        // 调用MyMath中的mySum方法。
        MyMath mm = new MyMath();
        /*
        Compute c = new ComputeImpl();
        mm.mySum(c, 100, 200);
        */

        //合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）
        //mm.mySum(new ComputeImpl(), 100, 200);

        // 使用匿名内部类，表示这个ComputeImpl这个类没名字了。
        // 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。
        // 后面的{} 代表了对接口的实现。
        // 不建议使用匿名内部类，为什么？
        // 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。
        mm.mySum(new Compute(){
            public int sum(int a, int b){
                return a + b;
            }
        }, 200, 300);
    }
}

// 负责计算的接口
interface Compute{
    // 抽象方法
    int sum(int a, int b);
}

// 数学类
class MyMath{
    // 数学求和方法
    public void mySum(Compute c, int x, int y){
        int retValue = c.sum(x, y);
        System.out.println(x + "+" + y + "=" + retValue);
    }
}

```



### 访问控制权限

访问控制权限都有哪些？4个。

- private私有 只能在本类中访问
- public 公开 任何地方都能访问
- protected受保护 只能在本类、同包、子类中访问。
- 默认 只能在本类，以及同包下访问。

|访问控制修饰符| 本类| 同包| 子类 |任意位置|
|-------------|-----|-----|---|----|
|public|可以|可以|可以|可以|
|protected|可以|可以|可以|不行|
|private|可以|不行|不行|不行|
|默认|可以|可以|不行|不行|

这个不要死记硬背，自己下去之后编写代码自己测试。

范围从大到小排序：public > protected > 默认 > private

访问控制权限修饰符可以修饰什么？

- 属性（4个都能用）
- 方法（4个都能用）
- 类（public和默认能用，其它不行。）
- 接口（public和默认能用，其它不行。）


# 数组和常用类

## 数组

Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object

数组实际上是一个容器，可以同时容纳多个元素。（数组是一个数据的集合。）数组：字面意思是“一组数据”

数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据

数组是存储在堆当中的

数组当中如果存储的是“java对象”的话，实际上存储的是对象的“引用（内存地址）”，数组中不能直接存储java对象。

数组长度不可变

所有的数组对象都有length**属性**(java自带的)，用来获取数组中元素的个数。

java中的数组要求数组中元素的类型统一。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。

数组在内存方面存储的时候，数组中的元素内存地址(存储的每一个元素都是有规则的挨着排列的)是连续的。内存地址连续。  这是数组存储元素的特点（特色）。数组实际上是一种简单的数据结构。

所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。   （数组中首元素的内存地址作为整个数组对象的内存地址。）

数组中每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标是：length - 1

> 数组这种数据结构的优点和缺点是什么？
>
> **优点**：查询/查找/检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构。
>
> **缺点**：
> 1.由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。（注意：对于数组中最后一个元素的增删，是没有效率影响的。）
> 2.数组不能存储大数据量。为什么？   因为很难在内存空间上找到一块特别大的连续的内存空间。
>
> 为什么检索效率高？
>
> 1.每一个元素的内存地址在空间存储上是连续的。
> 2.每一个元素类型相同，所以占用空间大小一样。
> 3.知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标上元素的内存地址。直接通过内存地址定位 元素，所以数组的检索效率是最高的。

```java
public class ArrayTest01 {
    public static void main(String[] args) {
        // 声明一个int类型的数组，使用静态初始化的方式
        int[] a = {1, 100, 10, 20, 55, 689};

        // 下标为6表示第7个元素，第7个元素没有，下标越界了。会出现什么异常呢？
        //System.out.println(a[6]); //ArrayIndexOutOfBoundsException
    }
}
```

什么时候采用静态初始化方式，什么时候使用动态初始化方式呢？

- 当你创建数组的时候，确定数组中存储哪些具体的元素时，采用静态初始化方式。
- 当你创建数组的时候，不确定将来数组中存储哪些数据，你可以采用动态初始化的方式，预先分配内存空间。

```java
public class ArrayTest02 {
    public static void main(String[] args) {
        // 采用动态初始化的方式
        int[] a = new int[4]; // 创建长度为4的int数组，数组中每个元素的默认值是0
        Object[] objs = new Object[3]; // 3个长度，动态初始化，所以每个元素默认值是null

        // 采用静态初始化的方式
        String[] strs2 = {"abc", "def", "xyz"};
        for (int i = 0; i < strs2.length; i++) {
            System.out.println(strs2[i]);
        }

        Object[] objects = {new Object(), new Object(), new Object()};

        }
    }
}



// 当一个方法的参数是一个数组的时候，我们还可以采用这种方式传递参数

public class ArrayTest04 {
    public static void main(String[] args) {
        // 静态初始化一维数组
        int[] a = {1,2,3};
        printArray(a);
        
        // 没有这种语法。
        //printArray({1,2,3});
        
        // 如果直接传递一个静态数组的话，语法必须这样写。
        printArray(new int[]{1,2,3});

        // 动态初始化一维数组
        int[] a2 = new int[4];
        printArray(a2);

        printArray(new int[3]);
    }
}

```

### main方法的String[] 参数

```java
/*
1、main方法上面的“String[] args”有什么用？
    分析以下：谁负责调用main方法（JVM）
    JVM调用main方法的时候，会自动传一个String数组过来。
 */
public class ArrayTest05 {
    // 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。
    public static void main(String[] args) {
        // JVM默认传递过来的这个数组对象的长度？默认0
        // 通过测试得出：args不是null。
        System.out.println("JVM给传递过来的String数组参数，它这个数组的长度是？" + args.length);
    }
}
```

### 引用数据类型

```java
/**
 * 一维数组的深入，数组中存储的类型为：引用数据类型
 * 对于数组来说，实际上只能存储java对象的“内存地址”。数组中存储的每个元素是“引用”。
 */
public class ArrayTest07 {
    public static void main(String[] args) {

        // 创建一个Animal类型的数组，数组当中存储Cat和Bird
        Cat c = new Cat();
        Bird b = new Bird();
        Animal[] anis = {c, b};

        //Animal[] anis = {new Cat(), new Bird()}; // 该数组中存储了两个对象的内存地址。
        for (int i = 0; i < anis.length; i++){
            // 这个取出来的可能是Cat，也可能是Bird，不过肯定是一个Animal
            // 如果调用的方法是父类中存在的方法不需要向下转型。直接使用父类型引用调用即可。
            //anis[i]
            //Animal an = anis[i];
            //an.move();

            //Animal中没有sing()方法。
            //anis[i].sing();

            // 调用子对象特有方法的话，需要向下转型！！！
            if(anis[i] instanceof Cat){
                Cat cat = (Cat)anis[i];
                cat.catchMouse();
            }else if(anis[i] instanceof Bird){
                Bird bird = (Bird)anis[i];
                bird.sing();
            }
        }
    }
}
```

### 数组的扩容和拷贝

关于一维数组的扩容。

在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？扩容。

java中对数组的扩容是：先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。

结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。

可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。

```java
public class ArrayTest08 {
    public static void main(String[] args) {
        // java中的数组是怎么进行拷贝的呢？
        //System.arraycopy(5个参数);

        // 拷贝源（从这个数组中拷贝）
        int[] src = {1, 11, 22, 3, 4};

        // 拷贝目标（拷贝到这个目标数组上）
        int[] dest = new int[20]; // 动态初始化一个长度为20的数组，每一个元素默认值0

        System.arraycopy(src, 0, dest, 0, src.length);


        // 数组中如果存储的元素是引用，可以拷贝吗？当然可以。
        String[] strs = {"hello", "world!", "study", "java", "oracle", "mysql", "jdbc"};
        String[] newStrs = new String[20];
        System.arraycopy(strs, 0, newStrs, 0, strs.length);

        System.out.println("================================");
        Object[] objs = {new Object(), new Object(), new Object()};
        Object[] newObjs = new Object[5];
        // 思考一下：这里拷贝的时候是拷贝对象，还是拷贝对象的地址。（地址。）
        System.arraycopy(objs, 0, newObjs, 0, objs.length);
    }
}

```

### 二维数组

```java
public class ArrayTest11 {
    public static void main(String[] args) {

        // 二维数组
        String[][] array = {
                {"java", "oracle", "c++", "python", "c#"},
                {"张三", "李四", "王五"},
                {"lucy", "jack", "rose"}
        };

        // 合并代码
        for(int i = 0; i < array.length; i++){ // 外层循环3次。（负责纵向。）
            for(int j = 0; j < array[i].length; j++){
                System.out.print(array[i][j] + " ");
            }
            System.out.println();
        }
    }
}


/*
动态初始化二维数组。
 */
public class ArrayTest12 {
    public static void main(String[] args) {
        // 3行4列。
        // 3个一维数组，每一个一维数组当中4个元素。
        int[][] array = new int[3][4];

        // 静态初始化
        int[][] a = {{1,2,3,4},{4,5,6,76},{1,23,4}};
        printArray(a);

        // 可以这样写。
        printArray(new int[][]{{1,2,3,4},{4,5,6,76},{1,23,4}});
    }

    public static void printArray(int[][] array){
        // 遍历二维数组。
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                System.out.print(array[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

**每次都重写toString和equals方法 ！！！！**

- 第一：空间存储上，内存地址是连续的。
- 第二：每个元素占用的空间大小相同。
- 第三：知道首元素的内存地址。
- 第四：通过下标可以计算出偏移量。

优点：检索效率高。直接通过内存地址定位，效率非常高。
缺点：随机增删效率较低，数组无法存储大数据量。
注意：数组最后一个元素的增删效率不受影响。

### 排序和查找

```java
import java.util.Arrays;

/**
 * 使用以下数组工具类：java.util.Arrays;
 */
public class ArraysTest01 {
    public static void main(String[] args) {

        int[] arr = {112,3,4,56,67,1};

        // 工具类当中的方法大部分都是静态的。
        Arrays.sort(arr);

        // 遍历输出
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

import java.util.Arrays;

/**
 * 好消息：
 *  SUN公司已经为我们程序员写好了一个数组工具类。
 *  java.util.Arrays;
 */
public class ArraysTest02 {
    public static void main(String[] args) {
        // java.util.Arrays; 工具类中有哪些方法，我们开发的时候要参考API帮助文档
        // 不要死记硬背。
        int[] arr = {3,6,4,5,12,1,2,32,5,5};
        // 排序
        Arrays.sort(arr);
        // 输出
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
        // 二分法查找（建立在排序基础之上。）
        int index = Arrays.binarySearch(arr, 5);

        System.out.println(index == -1 ? "该元素不存在" : "该元素下标是：" + index);
    }
}

```

## 常用类

### String类

##### 基础认知

`java.lang.String`

String表示字符串类型，属于引用数据类型，不属于基本数据类型。

在java中随便使用双引号括起来的都是String对象。例："abc"，"def"，"hello world!"，这是3个String对象。

java中规定，双引号括起来的字符串，是不可变的，也就是说"abc"自出生到最终死亡，不可变，不能变成"abcd"，也不能变成"ab"

在JDK当中双引号括起来的字符串，例如："abc" "def"都是直接存储在“方法区”的“字符串常量池”当中的。为什么SUN公司把字符串存储在一个“字符串常量池”当中呢。因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了`方法区的字符串常量池`当中。

```java
public class StringTest01 {
    public static void main(String[] args) {
        // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。
        String s1 = "abcdef";
        String s2 = "abcdef" + "xy";

        // 分析：这是使用new的方式创建的字符串对象。这个代码中的"xy"是从哪里来的？
        // 凡是双引号括起来的都在字符串常量池中有一份。
        // new对象的时候一定在堆内存当中开辟空间。
        String s3 = new String("xy");

        // i变量中保存的是100这个值。
        int i = 100;
        // s变量中保存的是字符串对象的内存地址。
        // s引用中保存的不是"abc"，是0x1111
        // 而0x1111是"abc"字符串对象在“字符串常量池”当中的内存地址。
        String s = "abc";
    }
}
```

```java

public class StringTest02 {
    public static void main(String[] args) {
        String s1 = "hello";
        // "hello"是存储在方法区的字符串常量池当中
        // 所以这个"hello"不会新建。（因为这个对象已经存在了。）
        String s2 = "hello";
        // 分析结果是true还是false？
        // == 双等号比较的是不是变量中保存的内存地址？是的。
        System.out.println(s1 == s2); // true

        String x = new String("xyz");
        String y = new String("xyz");
        // 分析结果是true还是false？
        // == 双等号比较的是不是变量中保存的内存地址？是的。
        System.out.println(x == y); //false

        // 通过这个案例的学习，我们知道了，字符串对象之间的比较不能使用“==”
        // "=="不保险。应该调用String类的equals方法。
        // String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。
        System.out.println(x.equals(y)); // true

        String k = new String("testString");
        //String k = null;
        // "testString"这个字符串可以后面加"."呢？
        // 因为"testString"是一个String字符串对象。只要是对象都能调用方法。
        System.out.println("testString".equals(k)); // 建议使用这种方式，因为这个可以避免空指针异常。
        System.out.println(k.equals("testString")); // 存在空指针异常的风险。不建议这样写。
    }
}
```

分析以下程序，一共创建了几个对象

```java
public class StringTest03 {
    public static void main(String[] args) {
        String s1 = new String("hello");
        String s2 = new String("hello");
    }
}
```

一共3个对象：

- 方法区字符串常量池中有1个："hello"堆内存当中有两个String对象，一共3个。

##### 构造方法

关于String类中的构造方法。

- 第一个：String s = new String("");
- 第二个：String s = ""; 最常用
- 第三个：String s = new String(char数组);
- 第四个：String s = new String(char数组,起始下标,长度);
- 第五个：String s = new String(byte数组);
- 第六个：String s = new String(byte数组,起始下标,长度)

```java
public class StringTest04 {
    public static void main(String[] args) {

        // 创建字符串对象最常用的一种方式
        String s1 =  "hello world!";
        // s1这个变量中保存的是一个内存地址。
        // 按说以下应该输出一个地址。
        // 但是输出一个字符串，说明String类已经重写了toString()方法。
        System.out.println(s1);//hello world!
        System.out.println(s1.toString()); //hello world!

        // 这里只掌握常用的构造方法。
        byte[] bytes = {97, 98, 99}; // 97是a，98是b，99是c
        String s2 = new String(bytes);

        // 前面说过：输出一个引用的时候，会自动调用toString()方法，默认Object的话，会自动输出对象的内存地址。
        // 通过输出结果我们得出一个结论：String类已经重写了toString()方法。
        // 输出字符串对象的话，输出的不是对象的内存地址，而是字符串本身。
        System.out.println(s2.toString()); //abc
        System.out.println(s2); //abc

        // String(字节数组,数组元素下标的起始位置,长度)
        // 将byte数组中的一部分转换成字符串。
        String s3 = new String(bytes, 1, 2);
        System.out.println(s3); // bc

        // 将char数组全部转换成字符串
        char[] chars = {'我','是','中','国','人'};
        String s4 = new String(chars);
        System.out.println(s4);
        // 将char数组的一部分转换成字符串
        String s5 = new String(chars, 2, 3);
        System.out.println(s5);

        String s6 = new String("helloworld!");
        System.out.println(s6); //helloworld!
    }
}

```

##### 常用方法

```java
public class StringTest05 {
    public static void main(String[] args) {

        // String类当中常用方法。
        //1（掌握）.char charAt(int index)
        char c = "中国人".charAt(1); // "中国人"是一个字符串String对象。只要是对象就能“点.”
        System.out.println(c); // 国

        // 2（了解）.int compareTo(String anotherString)
        // 字符串之间比较大小不能直接使用 > < ，需要使用compareTo方法。
        int result = "abc".compareTo("abc");
        System.out.println(result); //0（等于0） 前后一致  10 - 10 = 0

        int result2 = "abcd".compareTo("abce");
        System.out.println(result2); //-1（小于0） 前小后大 8 - 9 = -1

        int result3 = "abce".compareTo("abcd");
        System.out.println(result3); // 1（大于0） 前大后小 9 - 8 = 1

        // 拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。
        System.out.println("xyz".compareTo("yxz")); // -1

        // 3（掌握）.boolean contains(CharSequence s)
        // 判断前面的字符串中是否包含后面的子字符串。
        System.out.println("HelloWorld.java".contains(".java")); // true

        // 4（掌握）. boolean endsWith(String suffix)
        // 判断当前字符串是否以某个子字符串结尾。
        System.out.println("test.txt".endsWith(".java")); // false
        System.out.println("test.txt".endsWith(".txt")); // true

        // 5（掌握）.boolean equals(Object anObject)
        // 比较两个字符串必须使用equals方法，不能使用“==”
        // equals方法有没有调用compareTo方法？ 老版本可以看一下。JDK13中并没有调用compareTo()方法。
        // equals只能看出相等不相等。
        // compareTo方法可以看出是否相等，并且同时还可以看出谁大谁小。
        System.out.println("abc".equals("abc")); // true

        // 6（掌握）.boolean equalsIgnoreCase(String anotherString)
        // 判断两个字符串是否相等，并且同时忽略大小写。
        System.out.println("ABc".equalsIgnoreCase("abC")); // true

        // 7（掌握）.byte[] getBytes()
        // 将字符串对象转换成字节数组
        byte[] bytes = "abcdef".getBytes();
        for(int i = 0; i < bytes.length; i++){
            System.out.println(bytes[i]);
        }

        // 8（掌握）.int indexOf(String str)
        // 判断某个子字符串在当前字符串中第一次出现处的索引（下标）。
System.out.println("oraclejavac++.netc#phppythonjavaoraclec++".indexOf("java")); // 6

        // 9（掌握）.boolean isEmpty()
        // 判断某个字符串是否为“空字符串”。底层源代码调用的应该是字符串的length()方法。
        //String s = "";
        String s = "a";
        System.out.println(s.isEmpty());

        // 10（掌握）. int length()
        // 面试题：判断数组长度和判断字符串长度不一样
        // 判断数组长度是length属性，判断字符串长度是length()方法。
        System.out.println("abc".length()); // 3
        System.out.println("".length()); // 0

        // 11（掌握）.int lastIndexOf(String str)
        // 判断某个子字符串在当前字符串中最后一次出现的索引（下标）
        System.out.println("oraclejavac++javac#phpjavapython".lastIndexOf("java")); //22

        // 12（掌握）. String replace(CharSequence target, CharSequence replacement)
        // 替换。
        // String的父接口就是：CharSequence
        String newString = "http://www.baidu.com".replace("http://", "https://");
        System.out.println(newString); //https://www.baidu.com
        // 把以下字符串中的“=”替换成“:”
        String newString2 = "name=zhangsan&password=123&age=20".replace("=", ":");
        System.out.println(newString2); //name:zhangsan&password:123&age:20

        // 13（掌握）.String[] split(String regex)
        // 拆分字符串
        String[] ymd = "1980-10-11".split("-"); //"1980-10-11"以"-"分隔符进行拆分。

        // 14（掌握）、boolean startsWith(String prefix)
        // 判断某个字符串是否以某个子字符串开始。
        System.out.println("http://www.baidu.com".startsWith("http")); // true

        // 15（掌握）、 String substring(int beginIndex) 参数是起始下标。
        // 截取字符串
        System.out.println("http://www.baidu.com".substring(7)); //www.baidu.com

        // 16（掌握）、String substring(int beginIndex, int endIndex)
        // beginIndex起始位置（包括）
        // endIndex结束位置（不包括）
        System.out.println("http://www.baidu.com".substring(7, 10)); //www

        // 17(掌握)、char[] toCharArray()
        // 将字符串转换成char数组
        char[] chars = "我是中国人".toCharArray();
        for(int i = 0; i < chars.length; i++){
            System.out.println(chars[i]);
        }

        // 18（掌握）、String toLowerCase()
        // 转换为小写。
        System.out.println("ABCDefKXyz".toLowerCase());

        // 19（掌握）、String toUpperCase();
        System.out.println("ABCDefKXyz".toUpperCase());

        // 20（掌握）. String trim();
        // 去除字符串前后空白
        System.out.println("           hello      world             ".trim());

        // 21（掌握）. String中只有一个方法是静态的，不需要new对象
        // 这个方法叫做valueOf
        // 作用：将“非字符串”转换成“字符串”
        //String s1 = String.valueOf(true);
        //String s1 = String.valueOf(100);
        //String s1 = String.valueOf(3.14);

        // 这个静态的valueOf()方法，参数是一个对象的时候，会自动调用该对象的toString()方法吗？
        String s1 = String.valueOf(new Customer());
        //System.out.println(s1); // 没有重写toString()方法之前是对象内存地址 com.bjpowernode.javase.string.Customer@10f87f48
        System.out.println(s1); //我是一个VIP客户！！！！

        // 我们是不是可以研究一下println()方法的源代码了？
        System.out.println(100);
        System.out.println(3.14);
        System.out.println(true);

        Object obj = new Object();
        // 通过源代码可以看出：为什么输出一个引用的时候，会调用toString()方法!!!!
        //　本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出。
        System.out.println(obj);

        System.out.println(new Customer());
    }
}

class Customer {
    // 重写toString()方法
    @Override
    public String toString() {
        return "我是一个VIP客户！！！！";
    }
}
```

如果以后需要进行大量字符串的拼接操作，建议使用JDK中自带的：

- java.lang.StringBuffer
- java.lang.StringBuilder

如何优化StringBuffer的性能？

- 在创建StringBuffer的时候尽可能给定一个初始化容量。
- 最好减少底层数组的扩容次数。预估计一下，给一个大一些初始化容量。
- 关键点：给一个合适的初始化容量。可以提高程序的执行效率。

```java
public class StringBufferTest02 {
    public static void main(String[] args) {

        // 创建一个初始化容量为16个byte[] 数组。（字符串缓冲区对象）
        StringBuffer stringBuffer = new StringBuffer();

        // 拼接字符串，以后拼接字符串统一调用 append()方法。
        // append是追加的意思。
        stringBuffer.append("a");
        stringBuffer.append(3.14);
        stringBuffer.append(true);
        // append方法底层在进行追加的时候，如果byte数组满了，会自动扩容。
        stringBuffer.append(100L);

        System.out.println(stringBuffer.toString());

        // 指定初始化容量的StringBuffer对象（字符串缓冲区对象）
        StringBuffer sb = new StringBuffer(100);
        sb.append("hello");
        System.out.println(sb);
    }
}
```

面试题：String为什么是不可变的？

- 我看过源代码，String类中有一个byte[]数组，这个byte[]数组采用了final修饰，因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可再指向其它对象，所以String是不可变的！"abc" 无法变成 "abcd"

StringBuilder/StringBuffer为什么是可变的呢？

- 我看过源代码，StringBuffer/StringBuilder内部实际上是一个byte[]数组，    这个byte[]数组没有被final修饰，StringBuffer/StringBuilder的初始化容量我记得应该是16，当存满之后会进行扩容，底层调用了数组拷贝的方法System.arraycopy()...是这样扩容的。所以StringBuilder/StringBuffer适合于使用字符串的频繁拼接操作。

```java
package com.bjpowernode.javase.stringbuffer;

public class StringBufferTest04 {
    public static void main(String[] args) {

        // 字符串不可变是什么意思？
        // 是说双引号里面的字符串对象一旦创建不可变。
        String s = "abc"; //"abc"放到了字符串常量池当中。"abc"不可变。

        // s变量是可以指向其它对象的。
        // 字符串不可变不是说以上变量s不可变。说的是"abc"这个对象不可变。
        s = "xyz";//"xyz"放到了字符串常量池当中。"xyz"不可变。
    }
}
```

java.lang.StringBuilder

StringBuffer和StringBuilder的区别？

- StringBuffer中的方法都有：synchronized关键字修饰。表示StringBuffer在多线程环境下运行是安全的。
- StringBuilder中的方法都没有：synchronized关键字修饰，表示StringBuilder在多线程环境下运行是不安全的。
 
```java
public class StringBuilderTest01 {
    public static void main(String[] args) {

        // 使用StringBuilder也是可以完成字符串的拼接。
        StringBuilder sb = new StringBuilder();
        sb.append(100);
        sb.append(true);
        sb.append("hello");
        sb.append("kitty");
        System.out.println(sb);
    }
}
```

### 基本数据类型对应的包装类

包装类存在有什么用？方便编程。

八种包装类的类名是什么？

- Byte
- Short
- Integer
- Long
- Float
- Double
- Boolean
- Character

所有数字的父类Number
照葫芦画瓢：学习Integer，其它的模仿Integer。

**这里只写Integer的包装类，其他照葫芦画瓢**

```java
/*
1、java中为8种基本数据类型又对应准备了8种包装类型。8种包装类属于引用数据类型，父类是Object。
2、思考：为什么要再提供8种包装类呢？因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。
 */
public class IntegerTest01 {
    //入口
    public static void main(String[] args) {
        // 有没有这种需求：调用doSome()方法的时候需要传一个数字进去。
        // 但是数字属于基本数据类型，而doSome()方法参数的类型是Object。
        // 可见doSome()方法无法接收基本数据类型的数字。那怎么办呢？可以传一个数字对应的包装类进去。
    }

    public static void doSome(Object obj){
        //System.out.println(obj);
        System.out.println(obj.toString());
    }
}
```

|基本数据类型|包装类型|
|-----|-----|
 |   byte         |           java.lang.Byte（父类Number）|
|    short        |           java.lang.Short（父类Number）|
|    int            |         java.lang.Integer（父类Number）|
|    long         |           java.lang.Long（父类Number）|
|    float          |         java.lang.Float（父类Number）|
|    double       |           java.lang.Double（父类Number）|
 |   boolean     |            java.lang.Boolean（父类Object）|
  |  char             |       java.lang.Character（父类Object）|

以上八种包装类中，重点以java.lang.Integer为代表进行学习，其它的类型照葫芦画瓢就行。

八种包装类中其中6个都是数字对应的包装类，他们的父类都是Number，可以先研究一下Number中公共的方法：Number是一个抽象类，无法实例化对象。
Number类中有这样的方法：
- byte byteValue() 以 byte 形式返回指定的数值。
- abstract  double doubleValue()以 double 形式返回指定的数值。
- abstract  float floatValue()以 float 形式返回指定的数值。
- abstract  int intValue()以 int 形式返回指定的数值。
- abstract  long longValue()以 long 形式返回指定的数值。
- short shortValue()以 short 形式返回指定的数值。

这些方法其实所有的数字包装类的子类都有，这些方法是负责拆箱的。

```java
public class IntegerTest02 {
    public static void main(String[] args) {

        // 123这个基本数据类型，进行构造方法的包装达到了：基本数据类型向引用数据类型的转换。
        // 基本数据类型 -(转换为)->引用数据类型（装箱）
        Integer i = new Integer(123);

        // 将引用数据类型--(转换为)-> 基本数据类型
        float f = i.floatValue();
        System.out.println(f); //123.0

        // 将引用数据类型--(转换为)-> 基本数据类型（拆箱）
        int retValue = i.intValue();
        System.out.println(retValue); //123
    }
}

/*
关于Integer类的构造方法，有两个：
    Integer(int)
    Integer(String)
*/


/**
 * 好消息：在java5之后，引入了一种新特性，自动装箱和自动拆箱
 *  自动装箱：基本数据类型自动转换成包装类。
 *  自动拆箱：包装类自动转换成基本数据类型。
 *
 * 有了自动拆箱之后，Number类中的方法就用不着了！
 *
 * 自动装箱和自动拆箱的好处？
 *      方便编程。
 */
public class IntegerTest05 {
    public static void main(String[] args) {

        // 900是基本数据类型
        // x是包装类型
        // 基本数据类型 --(自动转换)--> 包装类型：自动装箱
        Integer x = 900;

        // x是包装类型
        // y是基本数据类型
        // 包装类型 --(自动转换)--> 基本数据类型：自动拆箱
        int y = x;

        // z是一个引用，z是一个变量，z还是保存了一个对象的内存地址。
        Integer z = 1000; // 等同于：Integer z = new Integer(1000);
        // 分析为什么这个没有报错呢？
        // +两边要求是基本数据类型的数字，z是包装类，不属于基本数据类型，这里会进行自动拆箱。将z转换成基本数据类型
        // 在java5之前你这样写肯定编译器报错。
        System.out.println(z + 1);

        Integer a = 1000; // Integer a = new Integer(1000); a是个引用，保存内存地址指向对象。
        Integer b = 1000; // Integer b = new Integer(1000); b是个引用，保存内存地址指向对象。
        // == 比较的是对象的内存地址，a和b两个引用中保存的对象内存地址不同。
        // == 这个运算符不会触发自动拆箱机制。（只有+ - * /等运算的时候才会。）
        System.out.println(a == b); //false
    }
}

/*
这个题目是Integer非常重要的面试题。
 */
public class IntegerTest06 {
    public static void main(String[] args) {

        Integer a = 128;
        Integer b = 128;
        System.out.println(a == b); //false

        /*
        java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，
        放到了一个方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要
        再new了，直接从整数型常量池当中取出来。

        原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的。
         */
        Integer x = 127;
        Integer y = 127;
        // == 永远判断的都是两个对象的内存地址是否相同。
        System.out.println(x == y); //true
    }
}
```

**总结一下以前遇到的经典的异常**

```java
/*
总结一下之前所学的经典异常？
    空指针异常：NullPointerException
    类型转换异常：ClassCastException
    数组下标越界异常：ArrayIndexOutOfBoundsException
    数字格式化异常：NumberFormatException

Integer类当中有哪些常用的方法呢？
 */
public class IntegerTest07 {
    public static void main(String[] args) {

        // 手动装箱
        Integer x = new Integer(1000);

        // 手动拆箱。
        int y = x.intValue();
        Integer a = new Integer("123");

        // 编译的时候没问题，一切符合java语法，运行时会不会出问题呢？
        // 不是一个“数字”可以包装成Integer吗？不能。运行时出现异常。
        // java.lang.NumberFormatException
        //Integer a = new Integer("中文");

        // 重点方法
        // static int parseInt(String s)
        // 静态方法，传参String，返回int
        //网页上文本框中输入的100实际上是"100"字符串。后台数据库中要求存储100数字，此时java程序需要将"100"转换成100数字。
        int retValue = Integer.parseInt("123"); // String -转换-> int
        //int retValue = Integer.parseInt("中文"); // NumberFormatException
        System.out.println(retValue + 100);

        // 照葫芦画瓢
        double retValue2 = Double.parseDouble("3.14");
        System.out.println(retValue2 + 1); //4.140000000000001（精度问题）

        float retValue3 = Float.parseFloat("1.0");
        System.out.println(retValue3 + 1); //2.0

        // -----------------------------------以下内容作为了解，不需要掌握---------------------------------------
        // static String toBinaryString(int i)
        // 静态的：将十进制转换成二进制字符串。
        String binaryString = Integer.toBinaryString(3);
        System.out.println(binaryString); //"11" 二进制字符串

        // static String toHexString(int i)
        // 静态的：将十进制转换成十六进制字符串。
        String hexString = Integer.toHexString(16);
        System.out.println(hexString); // "10"

        // 十六进制：1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a
        hexString = Integer.toHexString(17);
        System.out.println(hexString); // "11"

        //static String toOctalString(int i)
        // 静态的：将十进制转换成八进制字符串。
        String octalString = Integer.toOctalString(8);
        System.out.println(octalString); // "10"

        System.out.println(new Object()); //java.lang.Object@6e8cf4c6

        // valueOf方法作为了解
        //static Integer valueOf(int i)
        // 静态的：int-->Integer
        Integer i1 = Integer.valueOf(100);
        System.out.println(i1);

        // static Integer valueOf(String s)
        // 静态的：String-->Integer
        Integer i2 = Integer.valueOf("100");
        System.out.println(i2);
    }
}

```

Integer String int三种类型互相转换

![1593166561323](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1593166561323.png)

### 日期类

```java
import java.text.SimpleDateFormat;
import java.util.Date;

/*
java中对日期的处理
    这个案例最主要掌握：
        知识点1：怎么获取系统当前时间
        知识点2：String ---> Date
        知识点3：Date ---> String
 */
public class DateTest01 {
    public static void main(String[] args) throws Exception {

        // 获取系统当前时间（精确到毫秒的系统当前时间） 直接调用无参数构造方法就行。
        Date nowTime = new Date();

        // java.util.Date类的toString()方法已经被重写了。
        // 输出的应该不是一个对象的内存地址，应该是一个日期字符串。
        //System.out.println(nowTime); //Thu Mar 05 10:51:06 CST 2020

        // 日期可以格式化吗？
        // 将日期类型Date，按照指定的格式进行转换：Date --转换成具有一定格式的日期字符串-->String
        // SimpleDateFormat是java.text包下的。专门负责日期格式化的。
        /*
        yyyy 年(年是4位)
        MM 月（月是2位）
        dd 日
        HH 时
        mm 分
        ss 秒
        SSS 毫秒（毫秒3位，最高999。1000毫秒代表1秒）
        注意：在日期格式中，除了y M d H m s S这些字符不能随便写之外，剩下的符号格式自己随意组织。
         */
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
        String nowTimeStr = sdf.format(nowTime);
        System.out.println(nowTimeStr);

        // 假设现在有一个日期字符串String，怎么转换成Date类型？
        // String --> Date
        String time = "2008-08-08 08:08:08 888";
        //SimpleDateFormat sdf2 = new SimpleDateFormat("格式不能随便写，要和日期字符串格式相同");
        // 注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一致。不然会出现异常：java.text.ParseException
        SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
        Date dateTime = sdf2.parse(time);
        System.out.println(dateTime); //Fri Aug 08 08:08:08 CST 2008
    }
}


/*
获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。
1秒 = 1000毫秒

简单总结一下System类的相关属性和方法：
    System.out 【out是System类的静态变量。】
    System.out.println() 【println()方法不是System类的，是PrintStream类的方法。】
    System.gc() 建议启动垃圾回收器
    System.currentTimeMillis() 获取自1970年1月1日到系统当前时间的总毫秒数。
    System.exit(0) 退出JVM。
 */
public class DateTest02 {
    public static void main(String[] args) {
        // 获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。
        long nowTimeMillis = System.currentTimeMillis();
        System.out.println(nowTimeMillis); //1583377912981

        // 统计一个方法耗时
        // 在调用目标方法之前记录一个毫秒数
        long begin = System.currentTimeMillis();
        print();
        // 在执行完目标方法之后记录一个毫秒数
        long end = System.currentTimeMillis();
        System.out.println("耗费时长"+(end - begin)+"毫秒");
    }

    // 需求：统计一个方法执行所耗费的时长
    public static void print(){
        for(int i = 0; i < 1000000000; i++){
            System.out.println("i = " + i);
        }
    }
}


public class DateTest03 {
    public static void main(String[] args) {

        // 这个时间是什么时间？
        // 1970-01-01 00:00:00 001
        Date time = new Date(1); // 注意：参数是一个毫秒

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
        String strTime = sdf.format(time);
        // 北京是东8区。差8个小时。
        System.out.println(strTime); // 1970-01-01 08:00:00 001

        // 获取昨天的此时的时间。
        Date time2 = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24);
        String strTime2 = sdf.format(time2);
        System.out.println(strTime2); //2020-03-04 11:44:14 829

        // 获取“去年的今天”的时间
        // 自己玩。
    }
}

```

获取系统当前时间

- Date d = new Date();
- 日期格式化：Date --> String
- yyyy-MM-dd HH:mm:ss SSS
- SimpleDateFormat sdf = new SimpleDate("yyyy-MM-dd HH:mm:ss SSS");
- String s = sdf.format(new Date());
- String --> Date
- SimpleDateFormat sdf = new SimpleDate("yyyy-MM-dd HH:mm:ss");
- Date d = sdf.parse("2008-08-08 08:08:08");
- 获取毫秒数
- long begin = System.currentTimeMillis();
- Date d = new Date(begin - 1000 * 60 * 60 * 24);

### 数字类

```java

import java.math.BigDecimal;
import java.text.DecimalFormat;

/*
关于数字的格式化。（了解）
 */
public class DecimalFormatTest01 {
    public static void main(String[] args) {
        // java.text.DecimalFormat专门负责数字格式化的。
        //DecimalFormat df = new DecimalFormat("数字格式");

        /*
        数字格式有哪些？
            # 代表任意数字
            , 代表千分位
            . 代表小数点
            0 代表不够时补0

            ###,###.##
                表示：加入千分位，保留2个小数。
         */
        DecimalFormat df = new DecimalFormat("###,###.##");
        //String s = df.format(1234.56);
        String s = df.format(1234.561232);
        System.out.println(s); // "1,234.56"

        DecimalFormat df2 = new DecimalFormat("###,###.0000"); //保留4个小数位，不够补上0
        String s2 = df2.format(1234.56);
        System.out.println(s2); // "1,234.5600"

    }
}

/*
1、BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）
这是SUN提供的一个类。专门用在财务软件当中。

2、注意：财务软件中double是不够的。咱们之前有一个学生去用友面试，经理就问了这样一个问题：
    你处理过财务数据吗？用的哪一种类型？
        千万别说double，说java.math.BigDecimal
 */
public class BigDecimalTest01 {
    public static void main(String[] args) {

        // 这个100不是普通的100，是精度极高的100
        BigDecimal v1 = new BigDecimal(100);
        // 精度极高的200
        BigDecimal v2 = new BigDecimal(200);
        // 求和
        // v1 + v2; // 这样不行，v1和v2都是引用，不能直接使用+求和。
        BigDecimal v3 = v1.add(v2); // 调用方法求和。
        System.out.println(v3); //300

        BigDecimal v4 = v2.divide(v1);
        System.out.println(v4); // 2
    }
}

```

- DecimalFormat数字格式化

###,###.## 表示加入千分位，保留两个小数。
###,###.0000 表示加入千分位，保留4个小数，不够补0

- - BigDecimal

财务软件中通常使用BigDecimal

### 随机数

```java

/**
 * 随机数
 */
public class RandomTest01 {
    public static void main(String[] args) {
        // 创建随机数对象
        Random random = new Random();

        // 随机产生一个int类型取值范围内的数字。
        int num1 = random.nextInt();

        System.out.println(num1);

        // 产生[0~100]之间的随机数。不能产生101。
        // nextInt翻译为：下一个int类型的数据是101，表示只能取到100.
        int num2 = random.nextInt(101); //不包括101
        System.out.println(num2);
    }
}


```

- 怎么产生int类型随机数。

Random r = new Random();
int i = r.nextInt();

- 怎么产生某个范围之内的int类型随机数。

Random r = new Random();
int i = r.nextInt(101); // 产生[0-100]的随机数。

### 枚举

```java
public class SwitchTest {
    public static void main(String[] args) {
        // switch语句支持枚举类型
        // switch也支持String、int
        // 低版本的JDK，只支持int
        // 高版本的JDK，支持int、String、枚举。
        // byte short char也可以，因为存在自动类型转换。
        switch (Season.SPRING) {
            // 必须省略Season.
            case SPRING:
                System.out.println("春天");
                break;
            case SUMMER:
                System.out.println("夏天");
                break;
            case AUTUMN:
                System.out.println("秋天");
                break;
            case WINTER:
                System.out.println("冬天");
                break;
        }

    }
}


package com.bjpowernode.javase.enum2; // 标识符，关键字不能做标识符。enum是关键字。
/*
这个案例没有使用java中的枚举，分析以下程序，在设计方面有什么缺陷？
    以下代码可以编译，也可以运行。这些都没有问题。
    就是设计上你觉得有什么缺陷？

 */
public class EnumTest01 {
    public static void main(String[] args) {

        //System.out.println(10 / 0); //java.lang.ArithmeticException: / by zero
        /*
        int retValue = divide(10, 2);
        System.out.println(retValue == 1 ? "计算成功" : "计算失败"); // 1

        int retValue2 = divide(10, 0);
        System.out.println(retValue2 == 0 ? "计算失败" : "计算成功"); // 0
         */

        boolean success = divide(10, 0);
        System.out.println(success ? "计算成功" : "计算失败");
    }

    /**
     * 需求（这是设计者说的！）：以下程序，计算两个int类型数据的商，计算成功返回1，计算失败返回0
     * @param a int类型的数据
     * @param b int类型的数据
     * @return 返回1表示成功，返回0表示失败！
     */
    /*
    public static int divide(int a, int b){
        try {
            int c = a / b;
            // 程序执行到此处表示以上代码没有发生异常。表示执行成功！
            return 1;
        } catch (Exception e){
            // 程序执行到此处表示以上程序出现了异常！
            // 表示执行失败！
            return 0;
        }
    }
     */

    // 设计缺陷？在这个方法的返回值类型上。返回一个int不恰当。
    // 既然最后的结果只是成功和失败，最好使用布尔类型。因为布尔类型true和false正好可以表示两种不同的状态。
    /*
    public static int divide(int a, int b){
        try {
            int c = a / b;
            // 返回10已经偏离了需求，实际上已经出错了，但是编译器没有检查出来。
            // 我们一直想追求的是：所有的错误尽可能让编译器找出来，所有的错误越早发现越好！
            return 10;
        } catch (Exception e){
            return 0;
        }
    }
    */

    // 这种设计不错。
    public static boolean divide(int a, int b){
        try {
            int c = a / b;
            return true;
        } catch (Exception e){
            return false;
        }
    }

    /*
    思考：以上的这个方法设计没毛病，挺好，返回true和false表示两种情况，
    但是在以后的开发中，有可能遇到一个方法的执行结果可能包括三种情况，
    四种情况，五种情况不等，但是每一个都是可以数清楚的，一枚一枚都是可以
    列举出来的。这个布尔类型就无法满足需求了。此时需要使用java语言中的
    枚举类型。
     */

}

// 采用枚举的方式改造程序
/*
总结：
    1、枚举是一种引用数据类型
    2、枚举类型怎么定义，语法是？
        enum 枚举类型名{
            枚举值1,枚举值2
        }
    3、结果只有两种情况的，建议使用布尔类型。
    结果超过两种并且还是可以一枚一枚列举出来的，建议使用枚举类型。
        例如：颜色、四季、星期等都可以使用枚举类型。
 */
public class EnumTest02 {
    public static void main(String[] args) {
        Result r = divide(10, 2);
        System.out.println(r == Result.SUCCESS ? "计算成功" : "计算失败");
    }

    /**
     * 计算两个int类型数据的商。
     * @param a int数据
     * @param b int数据
     * @return Result.SUCCESS表示成功，Result.FAIL表示失败！
     */
    public static Result divide(int a, int b){
        try {
            int c = a / b;
            return Result.SUCCESS;
        } catch (Exception e){
            return Result.FAIL;
        }
    }
}

// 枚举：一枚一枚可以列举出来的，才建议使用枚举类型。
// 枚举编译之后也是生成class文件。
// 枚举也是一种引用数据类型。
// 枚举中的每一个值可以看做是常量。
enum Result{
    // SUCCESS 是枚举Result类型中的一个值
    // FAIL 是枚举Result类型中的一个值
    // 枚举中的每一个值，可以看做是“常量”
    SUCCESS, FAIL
}

```

- 枚举是一种引用数据类型。
- 枚举编译之后也是class文件。
- 枚举类型怎么定义？
- enum 枚举类型名{

枚举值,枚举值2,枚举值3
}

- 当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来

的时候，建议返回值类型设计为枚举类型。


# 集合

## 集合

什么是集合？有什么用？

- 数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。

集合为什么说在开发中使用较多？

- 集合是一个容器，是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来。

注意：

- 集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）
- 集合在java中本身是一个容器，是一个对象。
- 集合中任何时候存储的都是“引用”。

在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如：数组、二叉树、链表、哈希表...以上这些都是常见的数据结构。

new ArrayList(); 创建一个集合，底层是数组。
new LinkedList(); 创建一个集合对象，底层是链表。
new TreeSet(); 创建一个集合对象，底层是二叉树。
.....

集合在java JDK中哪个包下？

- java.util.*;所有的集合类和集合接口都在java.util包下。

为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！

在java中集合分为两大类：
- 一类是单个方式存储元素：单个方式存储元素，这一类集合中超级父接口：java.util.Collection;
- 一类是以键值对儿的方式存储元素以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;

![1595553406932](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553406932.png)

![1595553421651](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1595553421651.png)

重点：

- 第一个重点：把集合继承结构图背会。
- 第二个重点：把Collection接口中常用方法测试几遍。
- 第三个重点：把迭代器弄明白。
- 第四个重点：Collection接口中的remove方法和contains方法底层都会调用equals，
这个弄明白。

总结：所有实现类

- ArrayList 底层是数组
- LinkedList 底层是双向链表
- Vector 底层是数组，线程安全，效率比较低，使用较少
- HashSet 底层是HashMap，放在HashSet集合中的元素等同于放到HashMap集合key部分了
- TreeSet 底层是TreeMap，放在TreeSet集合中的元素等同于放到TreeMap集合的key部分了
- HashMap 底层是哈希表
- HashTable 底层也是哈希表，不过是线程安全的，效率较低，使用较少
- Properties 是线程安全的，并且k和v只能存储字符串String
- TreeMap 底层是二叉树。TreeMap集合的key可以自动按照大小顺序排序


List 集合存储元素特点

- 有序可重复
- 有序：存进去的顺序和取出得到顺序相同，每一个元素都有下标
- 可重复：存进去1， 可以再存储一个1

Set(Map) 集合存储元素特点

- 无序不可重复
- 无序：存进去的顺序和去除的顺序不一定相同，另外Set集合中没有下标
- 不可重复：存进去1，不能再存储1了

SortedSet（SortedMap） 集合存储元素特点

- 无序不可重复但是可以排序
- 可排序：可以按照大小顺序排列

Map集合的Key就是一个Set集合，往Set中放数据就相当于放到了map的key部分

### Collection

关于java.util.Collection接口中常用的方法。

Collection中能存放什么元素？
- 没有使用“泛型”之前，Collection中可以存储Object的所有子类型，且**可以不同**，因为存的是地址
- 使用了“泛型”之后，Collection中只能存储某个具体的类型。
- Collection中什么都能存只要是Object的子类型就行。
- 集合中不能直接存储基本数据类型,也不能存java对象，只是存储java对象的内存地址。

Collection中的常用方法

- boolean add(Object e) 向集合中添加元素(自动装箱)
- int size()  获取集合中元素的个数
- void clear() 清空集合
- boolean contains(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false
- boolean remove(Object o) 删除集合中的某个元素。
- boolean isEmpty()  判断该集合中元素的个数是否为0
- Object[] toArray()  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】

#### 迭代器

```java
public class CollectionTest02 {
    public static void main(String[] args) {
        // 注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。
        // 在Map集合中不能用。在所有的Collection以及子类中使用。
        // 创建集合对象
        Collection c = new ArrayList(); // 后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。
        // 添加元素
        c.add("abc");
        c.add(new Object());
        // 对集合Collection进行遍历/迭代
        // 第一步：获取集合对象的迭代器对象Iterator
        Iterator it = c.iterator();
        // 第二步：通过以上获取的迭代器对象开始迭代/遍历集合。
        /*
            以下两个方法是迭代器对象Iterator中的方法：
                boolean hasNext()如果仍有元素可以迭代，则返回 true。
                Object next() 返回迭代的下一个元素。
         */
        while(it.hasNext()){
            Object obj = it.next();
            System.out.println(obj);
        }
    //等价于：
        while(it2.hasNext()){
            System.out.println(it2.next());
        }
        // 一直取，不判断，会出现异常：java.util.NoSuchElementException
    }
}

```

#### contains

深入Collection集合的contains方法：

boolean contains(Object o)
判断集合中是否包含某个对象o
如果包含返回true， 如果不包含返回false。

contains方法是用来判断集合中是否包含某个元素的方法，那么它在底层是怎么判断集合中是否包含某个元素的呢？
调用了equals方法进行比对。equals方法返回true，就表示包含这个元素。

```java
public class CollectionTest04 {
    public static void main(String[] args) {
        // 创建集合对象
        Collection c = new ArrayList();

        // 向集合中存储元素
        String s1 = new String("abc"); // s1 = 0x1111
        c.add(s1); // 放进去了一个"abc"

        String s2 = new String("def"); // s2 = 0x2222
        c.add(s2);

        // 集合中元素的个数
        System.out.println("元素的个数是：" + c.size()); // 2

        // 新建的对象String
        String x = new String("abc"); // x = 0x5555
        // c集合中是否包含x？结果猜测一下是true还是false？
        System.out.println(c.contains(x));
    }
}

//包含，因为底层调用了String的equals方法，比较的是内容，内容一样所以是true
//和字符串常量值

```

结论：**放在集合中的元素一定要重写equals方法**

#### remove

- 当集合的结构发生改变时，迭代器必须重新获取，如果还是用以前老的迭代器，会出现异常：java.util.ConcurrentModificationException
- 在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：c.remove(o); 迭代过程中不能这样。会出现：java.util.ConcurrentModificationException
- 在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素不要使用集合自带的remove方法删除元素。

```java
public class CollectionTest06 {
    public static void main(String[] args) {
        // 创建集合
        Collection c = new ArrayList();

        // 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。
        // 一定要注意：集合结构只要发生改变，迭代器必须重新获取。
        // 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException
        Iterator it = c.iterator();

        // 添加元素
        c.add(1); // Integer类型
        c.add(2);

        // 获取迭代器
        //Iterator it = c.iterator();
        /*while(it.hasNext()){
            // 编写代码时next()方法返回值类型必须是Object。
            // Integer i = it.next();
            Object obj = it.next();
            System.out.println(obj);
        }*/

        Collection c2 = new ArrayList();
        c2.add("abc");
        c2.add("def");
        c2.add("xyz");

        Iterator it2 = c2.iterator();
        while(it2.hasNext()){
            Object o = it2.next();
            // 删除元素
            // 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器
            // 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException
            // 出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）
            //c2.remove(o); // 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）
            // 使用迭代器来删除可以吗？
            // 迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。
            it2.remove(); // 删除的一定是迭代器指向的当前元素。
            System.out.println(o);
        }

        System.out.println(c2.size()); //0
    }
}

```


### List

List集合存储元素特点：有序可重复

- 有序：List集合中的元素有下标。
- 从0开始，以1递增。
- 可重复：存储一个1，还可以再存储1.

List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法：
以下只列出List接口特有的常用的方法：

- void add(int index, Object element)
- Object set(int index, Object element)
- Object get(int index)
- int indexOf(Object o)
- int lastIndexOf(Object o)
- Object remove(int index)

以上几个方法不需要死记硬背，可以自己编写代码测试一下，理解一下, 以后开发的时候，还是要翻阅帮助文档。

迭代器迭代元素的过程中不能使用集合对象的remove方法删除元素，要使用迭代器Iterator的remove方法来删除元素，防止出现异常： ConcurrentModificationException

怎么得到一个线程安全的List：
Collections.synchronizedList(list);


```java

public class ListTest01 {
    public static void main(String[] args) {
        // 创建List类型的集合。
        List myList = new ArrayList();

        // 添加元素
        myList.add("A"); // 默认都是向集合末尾添加元素。
        myList.add("B");

        //在列表的指定位置插入指定元素（第一个参数是下标）
        // 这个方法使用不多，因为对于ArrayList集合来说效率比较低。
        myList.add(1, "KING");

        // 迭代
        Iterator it = myList.iterator();
        while(it.hasNext()){
            Object elt = it.next();
            System.out.println(elt);
        }

        // 根据下标获取元素
        Object firstObj = myList.get(0);
        System.out.println(firstObj);

        // 因为有下标，所以List集合有自己比较特殊的遍历方式
        // 通过下标遍历。【List集合特有的方式，Set没有。】
        for(int i = 0; i < myList.size(); i++){
            Object obj = myList.get(i);
            System.out.println(obj);
        }

        // 获取指定对象第一次出现处的索引。
        System.out.println(myList.indexOf("C")); // 3

        // 获取指定对象最后一次出现处的索引。
        System.out.println(myList.lastIndexOf("C")); // 4

        // 删除下标为0的元素
        myList.remove(0);

        // 修改指定位置的元素
        myList.set(2, "Soft");

        // 遍历集合
        for(int i = 0; i < myList.size(); i++){
            Object obj = myList.get(i);
            System.out.println(obj);
        }
    }
}

```

#### ArrayList

- 默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）扩容为原容量1.5倍。
- 集合底层是一个Object[]数组。
- 构造方法：
    - new ArrayList();
    - new ArrayList(20);
- ArrayList集合的扩容：        增长到原容量的1.5倍。
- ArrayList集合底层是数组，怎么优化？
    - 尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。
- 数组优点：
    - 检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）
- 数组缺点：
    - 随机增删元素效率比较低。
    - 另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）
- 向数组末尾添加元素，效率很高，不受影响。
- 面试官经常问的一个问题？ 这么多的集合中，你用哪个集合最多？
    - 答：ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们检索/查找某个元素的操作比较多。
- ArrayList集合是非线程安全的。（不是线程安全的集合。）
- ArrayList之所以检索效率比较高，不是单纯因为下标的原因。是因为底层数组发挥的作用。
- LinkedList集合照样有下标，但是检索/查找某个元素的时候效率比较低，因为只能从头节点开始一个一个遍历。

怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？
使用集合工具类：java.util.Collections;

java.util.Collection 是集合接口。

java.util.Collections 是集合工具类。

#### LinkedList

链表的优点：
    由于链表上的元素在空间存储上内存地址不连续。所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。在以后的开发中，如果遇到**随机增删集合中元素**的业务比较多时，建议使用LinkedList。

链表的缺点：
    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索/查找的效率较低。

- LinkedList集合底层也是有下标的。
- LinkedList集合有初始化容量吗？没有。
- 最初这个链表中没有任何元素。first和last引用都是null。


ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）
LinkedList：把随机增删发挥到极致。
加元素都是往末尾添加，所以ArrayList用的比LinkedList多。

#### Vector

Vector初始化容量是10.

扩容为原容量的2倍。

底层是数组。

Vector底层是线程安全的。

Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。

### 泛型

#### 使用泛型

- JDK5.0之后推出的新特性：泛型
- 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）
- 使用了泛型好处是什么？
    - 第一：集合中存储的元素类型统一了。
    - 第二：从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”！
- 泛型的缺点是什么？
    - 导致集合中存储的元素缺乏多样性！
    - 大多数业务中，集合中元素的类型还是统一的。所以这种泛型特性被大家所认可。

 ```java
public class GenericTest01 {
    public static void main(String[] args) {

        // 使用泛型List<Animal>之后，表示List集合中只允许存储Animal类型的数据。
        // 用泛型来指定集合中存储的数据类型。
        List<Animal> myList = new ArrayList<Animal>();

        // 指定List集合中只能存储Animal，那么存储String就编译报错了。
        // 这样用了泛型之后，集合中元素的数据类型更加统一了。
        Cat c = new Cat(); Bird b = new Bird();
        myList.add(c); myList.add(b);

        // 获取迭代器
        // 这个表示迭代器迭代的是Animal类型。
        Iterator<Animal> it = myList.iterator();
        while(it.hasNext()){
            // 使用泛型之后，每一次迭代返回的数据都是Animal类型。
            //Animal a = it.next();
            // 这里不需要进行强制类型转换了。直接调用。
            //a.move();

            // 调用子类型特有的方法还是需要向下转换的！
            Animal a = it.next();
            if(a instanceof Cat) {
                Cat x = (Cat)a;
                x.catchMouse();
            }
            if(a instanceof Bird) {
                Bird y = (Bird)a;
                y.fly();
            }
        }
    }
}

class Animal {
    // 父类自带方法
    public void move(){
        System.out.println("动物在移动！");
    }
}

class Cat extends Animal {
    // 特有方法
    public void catchMouse(){
        System.out.println("猫抓老鼠！");
    }
}

class Bird extends Animal {
    // 特有方法
    public void fly(){
        System.out.println("鸟儿在飞翔！");
    }
}

 ```


#### 钻石表达式（自动类型推断）

```java

public class GenericTest02 {
    public static void main(String[] args) {

        // ArrayList<这里的类型会自动推断>()，前提是JDK8之后才允许。
        // 自动类型推断，钻石表达式！
        List<Animal> myList = new ArrayList<>();

        myList.add(new Animal());
        myList.add(new Cat());
        myList.add(new Bird());

        // 遍历
        Iterator<Animal> it = myList.iterator();
        while(it.hasNext()){
            Animal a = it.next();
            a.move();
            //调用子类中的方法还是要转型
        }

        List<String> strList = new ArrayList<>();

        // 遍历
        Iterator<String> it2 = strList.iterator();
        while(it2.hasNext()){
            // 直接通过迭代器获取了String类型的数据
            String s = it2.next();
            // 直接调用String类的substring方法截取字符串。
            String newString = s.substring(7);
            System.out.println(newString);
        }
    }
}

```

#### 自定义泛型

//不太明白这个

自定义泛型可以吗？可以

- 自定义泛型的时候，<> 尖括号中的是一个标识符，随便写。
- java源代码中经常出现的是： <E>和<T>
- E是Element单词首字母。
- T是Type单词首字母。

```java
public class GenericTest03<标识符随便写> {

    public void doSome(标识符随便写 o){
        System.out.println(o);
    }

    public static void main(String[] args) {

        // new对象的时候指定了泛型是：String类型
        GenericTest03<String> gt = new GenericTest03<>();

        gt.doSome("abc");

        // =============================================================
        GenericTest03<Integer> gt2 = new GenericTest03<>();
        gt2.doSome(100);

        // 类型不匹配
        //gt2.doSome("abc");

        MyIterator<String> mi = new MyIterator<>();
        String s1 = mi.get();

        MyIterator<Animal> mi2 = new MyIterator<>();
        Animal a = mi2.get();

        // 不用泛型就是Object类型。
        /*GenericTest03 gt3 = new GenericTest03();
        gt3.doSome(new Object());*/
    }
}

class MyIterator<T> {
    public T get(){
        return null;
    }
}
```

### Map

- Map和Collection没有继承关系。
- Map集合以key和value的方式存储数据：键值对
    + key和value都是引用数据类型。
    + key和value都是存储对象的内存地址。
    + key起到主导的地位，value是key的一个附属品。
- Map接口中常用方法：
    + V put(K key, V value) 向Map集合中添加键值对
    + V get(Object key) 通过key获取value
    + void clear()    清空Map集合
    + boolean containsKey(Object key) 判断Map中是否包含某个key
    + boolean containsValue(Object value) 判断Map中是否包含某个value
    + boolean isEmpty()   判断Map集合中元素个数是否为0
    + V remove(Object key) 通过key删除键值对
    + int size() 获取Map集合中键值对的个数。
    + Collection<V> values() 获取Map集合中所有的value，返回一个Collection
    + Set<K> keySet() 获取Map集合所有的key（所有的键是一个set集合）
    + Set<Map.Entry<K,V>> entrySet()  将Map集合转换成Set集合

    假设现在有一个Map集合，如下所示：
    map1集合对象
    key             value
    ----------------------------
    1               zhangsan
    2               lisi
    3               wangwu
    4               zhaoliu

Set set = map1.entrySet();
set集合对象
1=zhangsan 【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry<K,V>】
2=lisi【Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】
3=wangwu
4=zhaoliu ---> 这个东西是个什么？ Map.Entry

#### 使用方式：

```java
public class MapTest01 {
    public static void main(String[] args) {
        // 创建Map集合对象
        Map<Integer, String> map = new HashMap<>();
        // 向Map集合中添加键值对
        map.put(1, "zhangsan"); // 1在这里进行了自动装箱。
        map.put(2, "lisi");
        map.put(3, "wangwu");
        // 通过key获取value
        String value = map.get(2);
        System.out.println(value);
        // 获取键值对的数量
        System.out.println("键值对的数量：" + map.size());
        // 通过key删除key-value
        map.remove(2);
        // 判断是否包含某个key
        // contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。
        System.out.println(map.containsKey(new Integer(4))); // true
        // 判断是否包含某个value
        System.out.println(map.containsValue(new String("wangwu"))); // true

        // 获取所有的value
        Collection<String> values = map.values();
        // foreach
        for(String s : values){
            System.out.println(s);
        }

        // 清空map集合
        map.clear();
        System.out.println("键值对的数量：" + map.size());
        // 判断是否为空
        System.out.println(map.isEmpty()); // true
    }
}

```

#### 遍历方式

```java
public class MapTest02 {
    public static void main(String[] args) {

        // 第一种方式：获取所有的key，通过遍历key，来遍历value
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "zhangsan");
        map.put(2, "lisi");
        map.put(3, "wangwu");
        map.put(4, "zhaoliu");
        // 遍历Map集合
        // 获取所有的key，所有的key是一个Set集合
        Set<Integer> keys = map.keySet();
        // 遍历key，通过key获取value
        // 迭代器可以
        /*Iterator<Integer> it = keys.iterator();
        while(it.hasNext()){
            // 取出其中一个key
            Integer key = it.next();
            // 通过key获取value
            String value = map.get(key);
            System.out.println(key + "=" + value);
        }*/
        // foreach也可以
        for(Integer key : keys){
            System.out.println(key + "=" + map.get(key));
        }

        // 第二种方式：Set<Map.Entry<K,V>> entrySet()
        // 以上这个方法是把Map集合直接全部转换成Set集合。
        // Set集合中元素的类型是：Map.Entry
        Set<Map.Entry<Integer,String>> set = map.entrySet();
        // 遍历Set集合，每一次取出一个Node
        // 迭代器
        /*Iterator<Map.Entry<Integer,String>> it2 = set.iterator();
        while(it2.hasNext()){
            Map.Entry<Integer,String> node = it2.next();
            Integer key = node.getKey();
            String value = node.getValue();
            System.out.println(key + "=" + value);
        }*/

        // foreach
        // 这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。
        // 这种方式比较适合于大数据量。
        for(Map.Entry<Integer,String> node : set){
            System.out.println(node.getKey() + "--->" + node.getValue());
        }
    }
}
```

### 哈希表（散列表）

HashMap集合：
- HashMap集合底层是哈希表/散列表的数据结构。
- 哈希表是一个怎样的数据结构呢？
    - 哈希表是一个数组和单向链表的结合体。
    - 数组：在查询方面效率很高，随机增删方面效率很低。
    - 单向链表：在随机增删方面效率较高，在查询方面效率很低。
    - 哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。"中庸"
- HashMap集合底层的源代码：
    ```java
        public class HashMap{
            // HashMap底层实际上就是一个数组。（一维数组）
            Node<K,V>[] table;
            // 静态的内部类HashMap.Node
            static class Node<K,V> {
                final int hash; // 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）
                final K key; // 存储到Map集合中的那个key
                V value; // 存储到Map集合中的那个value
                Node<K,V> next; // 下一个节点的内存地址。
            }
        }
    ```
- 哈希表/散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）
- 最主要掌握的是：
    - map.put(k,v)
    - v = map.get(k)
    - 以上这两个方法的实现原理，是必须掌握的。
- HashMap集合的key部分特点：
    - 无序，不可重复。
    - 为什么无序？ 因为不一定挂到哪个单向链表上。
    - 不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。
    - 放在HashMap集合key部分的元素其实就是放到HashSet集合中了。
    - 所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。
- 哈希表HashMap使用不当时无法发挥性能！
- 假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们称为：散列分布不均匀。
    - 什么是散列分布均匀？
    - 假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。
    - 假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？
    - 不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。散列分布均匀需要你重写hashCode()方法时有一定的技巧。
- 重点：放在HashMap集合key部分的元素,以及放在HashSet集合中的元素,需要同时重写hashCode和equals方法.
- HashMap集合的默认初始化容量是16，默认加载因子是0.75, 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。
- 重点，记住：HashMap集合初始化容量**必须是2的倍数**，这也是官方推荐的，这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。

这里有个图

测试:
```java
public class HashMapTest01 {
    public static void main(String[] args) {
        // 测试HashMap集合key部分的元素特点
        // Integer是key，它的hashCode和equals都重写了。
        Map<Integer,String> map = new HashMap<>();
        map.put(1111, "zhangsan");
        map.put(6666, "lisi");
        map.put(7777, "wangwu");
        map.put(2222, "zhaoliu");
        map.put(2222, "king"); //key重复的时候value会自动覆盖。

        System.out.println(map.size()); // 4

        // 遍历Map集合
        Set<Map.Entry<Integer,String>> set = map.entrySet();
        for(Map.Entry<Integer,String> entry : set){
            // 验证结果：HashMap集合key部分元素：无序不可重复。
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
    }
}
```

#### 必须重写hashcode和equals

- 向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！
equals方法有可能调用，也有可能不调用。
    - 拿put(k,v)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。
    - 拿get(k)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。

- 注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。
    - 并且equals方法返回如果是true，hashCode()方法返回的值必须一样。equals方法返回true表示两个对象相同，在同一个单向链表上比较。那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。所以hashCode()方法的返回值也应该相同。
    
- hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。

- 对于哈希表数据结构来说：如果o1和o2的hash值相同，一定是放到同一个单向链表上。 如果o1和o2的hash值不同，但由于哈希算法执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”。

- HashMap集合key部分允许null吗？  允许  但是要注意：HashMap集合的key null值只能有一个。

- 终极结论：放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要**同时重写hashCode方法和equals方法**。


#### HashMap和Hashtable的区别。

Hashtable和HashMap一样，底层都是哈希表数据结构。

HashMap：
- 初始化容量16，扩容2倍。非线程安全。key和value可以为null。
- HashMap集合的key和value都是可以为null的。

Hashtable：
- 初始化容量11，默认加载因子是：0.75f，扩容2倍+1。线程安全。key和value都不能是null。
- Hashtable的key和value都是不能为null的。

Hashtable方法都带有synchronized：线程安全的。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。


### Properties

目前只需要掌握Properties属性类对象的相关方法即可。
Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。
Properties被称为属性类对象。
Properties是线程安全的。

```java
public class PropertiesTest01 {
    public static void main(String[] args) {

        // 创建一个Properties对象
        Properties pro = new Properties();

        // 需要掌握Properties的两个方法，一个存，一个取。
        pro.setProperty("url", "jdbc:mysql://localhost:3306/bjpowernode");
        pro.setProperty("driver","com.mysql.jdbc.Driver");

        // 通过key获取value
        String url = pro.getProperty("url");
        String driver = pro.getProperty("driver");


        System.out.println(url);
        System.out.println(driver);

    }
}
```

### TreeMap/TreeSet


TreeSet集合存储元素特点：

- 无序不可重复的，但是存储的元素可以自动按照大小顺序排序！称为：可排序集合。
- 无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。
- TreeSet集合底层实际上是一个TreeMap
- TreeMap集合底层是一个二叉树。
- 放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。
- 无法对自定义类型排序castException
- 可以不写equals方法，因为底层调用了comparable方法进行比较了

#### 自定义排序规则

TreeMap的key或者TreeSet集合中的元素要想排序，有两种实现方式：

- 第一种：实现java.lang.Comparable接口。
- 第二种：单独编写一个比较器Comparator接口。

##### 第一种

```java
public class TreeSetTest04 {
    public static void main(String[] args) {
        Customer c1 = new Customer(32);
        Customer c2 = new Customer(20);
        // 创建TreeSet集合
        TreeSet<Customer> customers = new TreeSet<>();
        // 添加元素
        customers.add(c1);
        customers.add(c2);
        // 遍历
        for (Customer c : customers){
            System.out.println(c);
        }
    }
}

// 放在TreeSet集合中的元素需要实现java.lang.Comparable接口。
// 并且实现compareTo方法。equals可以不写。
class Customer implements Comparable<Customer>{

    int age;
    public Customer(int age){
        this.age = age;
    }

    // 需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！
    // k.compareTo(t.key)
    // 拿着参数k和集合中的每一个k进行比较，返回值可能是>0 <0 =0
    // 比较规则最终还是由程序员指定的：例如按照年龄升序。或者按照年龄降序。
    @Override
    public int compareTo(Customer c) { // c1.compareTo(c2);
        return c.age - this.age;
    }

    public String toString(){
        return "Customer[age="+age+"]";
    }
//----------------------------------------------------------------
 /*
先按照年龄升序，如果年龄一样的再按照姓名升序。
 */
    @Override
    public int compareTo(Vip v) {
        // 写排序规则，按照什么进行比较。
        if(this.age == v.age){
            // 年龄相同时按照名字排序。
            // 姓名是String类型，可以直接比。调用compareTo来完成比较。
            return this.name.compareTo(v.name);
        } else {
            // 年龄不一样
            return this.age - v.age;
        }
    }

}
```

##### 第二种

使用比较器的方式

最终的结论：放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式
    - 第一种：放在集合中的元素实现java.lang.Comparable接口。
    - 第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。

Comparable和Comparator怎么选择呢？
- 当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。
- 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。

- Comparator接口的设计符合OCP原则。


```java
public class TreeSetTest06 {
    public static void main(String[] args) {
        // 创建TreeSet集合的时候，需要使用这个比较器。
        // TreeSet<WuGui> wuGuis = new TreeSet<>();//这样不行，没有通过构造方法传递一个比较器进去。

        // 给构造方法传递一个比较器。
        //TreeSet<WuGui> wuGuis = new TreeSet<>(new WuGuiComparator());

        // 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）
        TreeSet<WuGui> wuGuis = new TreeSet<>(new Comparator<WuGui>() {
            @Override
            public int compare(WuGui o1, WuGui o2) {
                return o1.age - o2.age;
            }
        });

        wuGuis.add(new WuGui(1000));
        wuGuis.add(new WuGui(800));
        wuGuis.add(new WuGui(810));

        for(WuGui wuGui : wuGuis){
            System.out.println(wuGui);
        }
    }
}

// 乌龟
class WuGui{

    int age;

    public WuGui(int age){
        this.age = age;
    }

    @Override
    public String toString() {
        return "小乌龟[" +
                "age=" + age +
                ']';
    }
}

// 单独在这里编写一个比较器
//比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）

class WuGuiComparator implements Comparator<WuGui> {

    @Override
    public int compare(WuGui o1, WuGui o2) {
        // 指定比较规则
        // 按照年龄排序
        return o1.age - o2.age;
    }
}

```


#### 自平衡二叉树



图片



### Collections工具类

synchronizedList方法

sort方法（要求集合中元素实现Comparable接口。）

```java

/*
java.util.Collection 集合接口
java.util.Collections 集合工具类，方便集合的操作。
 */
public class CollectionsTest {
    public static void main(String[] args) {

        // ArrayList集合不是线程安全的。
        List<String> list = new ArrayList<>();

        // 变成线程安全的
        Collections.synchronizedList(list);

        // 排序
        list.add("abf");
        list.add("abx");

        Collections.sort(list);
        for(String s : list){
            System.out.println(s);
        }

        List<WuGui2> wuGuis = new ArrayList<>();
        wuGuis.add(new WuGui2(1000));
        wuGuis.add(new WuGui2(8000));
        // 注意：对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口。
        Collections.sort(wuGuis);
        for(WuGui2 wg : wuGuis){
            System.out.println(wg);
        }

        // 对Set集合怎么排序呢？
        Set<String> set = new HashSet<>();
        set.add("king");
        set.add("kingsoft");
        // 将Set集合转换成List集合
        List<String> myList = new ArrayList<>(set);
        Collections.sort(myList);
        for(String s : myList) {
            System.out.println(s);
        }

        // 这种方式也可以排序。
        //Collections.sort(list集合, 比较器对象);
    }
}

class WuGui2 implements Comparable<WuGui2>{
    int age;
    public WuGui2(int age){
        this.age = age;
    }

    @Override
    public int compareTo(WuGui2 o) {
        return this.age - o.age;
    }

    @Override
    public String toString() {
        return "WuGui2{" +
                "age=" + age +
                '}';
    }
}

```

# 异常

## 异常处理

### 是什么

```java
/*
1、什么是异常，java提供异常处理机制有什么用？
    以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常
    java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，
    java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对
    程序进行修改，让程序更加的健壮。

    什么是异常：程序执行过程中的不正常情况。
    异常的作用：增强程序的健壮性。

2、以下程序执行控制台出现了：
    Exception in thread "main" java.lang.ArithmeticException: / by zero
	    at com.bjpowernode.javase.exception.ExceptionTest01.main(ExceptionTest01.java:14)
	这个信息被我们称为：异常信息。这个信息是JVM打印的。
 */
public class ExceptionTest01 {
    public static void main(String[] args) {
        int a = 10;
        int b = 0;
        // 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException("/ by zero");
        // 并且JVM将new的异常对象抛出，打印输出信息到控制台了。
        int c = a / b;
        System.out.println(a + "/" + b + "=" + c);

        // 此处运行也会创建一个：ArithmeticException类型的异常对象。
        //System.out.println(100 / 0);

        // 我观察到异常信息之后，对程序进行修改，更加健壮。
    }
}


/*
java语言中异常是以什么形式存在的呢？
    1、异常在java中以类的形式存在，每一个异常类都可以创建异常对象。
    2、异常对应的现实生活中是怎样的？
        火灾(异常类)：
            2008年8月8日,小明家着火了（异常对象）

        类是：模板。
        对象是：实际存在的个体。

        钱包丢了（异常类）：
            2008年1月8日，小明的钱包丢了（异常对象）
 */
public class ExceptionTest02 {
    public static void main(String[] args) {

		// 通过“异常类”创建“异常对象”
        NullPointerException npe = new NullPointerException("空指针异常发生了！");

        //java.lang.NullPointerException: 空指针异常发生了！
        System.out.println(npe);
    }
}

public class ExceptionTest03 {
    public static void main(String[] args) {
    /*
        程序执行到此处发生了ArithmeticException异常，底层new了一个ArithmeticException异常对象，然后抛出了，由于是main方法调用了100 / 0，所以这个异常ArithmeticException抛给了main方法，main方法没有处理，将这个异常自动抛给了JVM。JVM最终终止程序的执行。
        ArithmeticException 继承 RuntimeException，属于运行时异常。
        在编写程序阶段不需要对这种异常进行预先的处理。
     */
        System.out.println(100 / 0);
        // 这里的HelloWorld没有输出，没有执行。
        System.out.println("Hello World!");
    }
}

/*
以下代码报错的原因是什么？
    因为doSome()方法声明位置上使用了：throws ClassNotFoundException
    而ClassNotFoundException是编译时异常。必须编写代码时处理，没有处理
    编译器报错。
 */
public class ExceptionTest04 {
    public static void main(String[] args) {
        // main方法中调用doSome()方法
        // 因为doSome()方法声明位置上有：throws ClassNotFoundException
        // 我们在调用doSome()方法的时候必须对这种异常进行预先的处理。
        // 如果不处理，编译器就报错。
        //编译器报错信息： Unhandled exception: java.lang.ClassNotFoundException
        //doSome();
    }

    /**
     * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException
     * 这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常。
     * 叫做类没找到异常。这个异常直接父类是：Exception，所以ClassNotFoundException属于编译时异常。
     * @throws ClassNotFoundException
     */
    public static void doSome() throws ClassNotFoundException{
        System.out.println("doSome!!!!");
    }

}


```

- java中异常的作用是：增强程序健壮性。
- java中异常以类和对象的形式存在。

Object
Object下有Throwable（可抛出的）
Throwable下有两个分支：

- Error（不可处理，直接退出JVM）
- Exception（可处理的）
	- Exception下有两个分支：
	- Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。
	- RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）


编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。

编译时异常因为什么而得名？
因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。因为异常的发生就是new异常对象。
编译时异常和运行时异常的区别？编译时异常一般发生的概率比较高。
举个例子：
你看到外面下雨了，倾盆大雨的。你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。“拿一把伞”就是对“生病异常”发生之前的一种处理方式。

对于一些发生概率较高的异常，需要在运行之前对其进行预处理。

运行时异常一般发生的概率比较低。
举个例子：
小明走在大街上，可能会被天上的飞机轮子砸到。被飞机轮子砸到也算一种异常。但是这种异常发生概率较低。在出门之前你没必要提前对这种发生概率较低的异常进行预处理。如果你预处理这种异常，你将活的很累。

假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。

假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？首先，如果这样的话，程序肯定是绝对的安全的。
但是程序员编写程序太累，代码到处都是处理异常的代码。

编译时异常还有其他名字：
- 受检异常：CheckedException
- 受控异常
运行时异常还有其它名字：
- 未受检异常：UnCheckedException
- 非受控异常

再次强调：所有异常都是发生在运行阶段的。

### 怎样处理


```java
public class ExceptionTest05 {
    // 第一种处理方式：在方法声明的位置上继续使用：throws，来完成异常的继续上抛。抛给调用者。上抛类似于推卸责任。（继续把异常传递给调用者。）

	/*
		public static void main(String[] args) throws ClassNotFoundException {
			doSome();
		}
     */

    // 第二种处理方式：try..catch进行捕捉。
    // 捕捉等于把异常拦下了，异常真正的解决了。（调用者是不知道的。）
    public static void main(String[] args) {
        try {
            doSome();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static void doSome() throws ClassNotFoundException{
        System.out.println("doSome!!!!");
    }
}


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/*
处理异常的第一种方式：
    在方法声明的位置上使用throws关键字抛出，谁调用我这个方法，我就抛给谁。抛给调用者来处理。
    这种处理异常的态度：上报。

处理异常的第二种方式：
    使用try..catch语句对异常进行捕捉。这个异常不会上报，自己把这个事儿处理了。异常抛到此处为止，不再上抛了。

注意：
    只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。try..catch捕捉异常之后，后续代码可以执行。

在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？
    如果希望调用者来处理，选择throws上报。
    其它情况使用捕捉的方式。
 */
public class ExceptionTest06 {
    // 一般不建议在main方法上使用throws，因为这个异常如果真正的发生了，一定会抛给JVM。JVM只有终止。
    // 异常处理机制的作用就是增强程序的健壮性。怎么能做到，异常发生了也不影响程序的执行。所以
    // 一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续上抛了。
    /*
    public static void main(String[] args) throws FileNotFoundException {
        System.out.println("main begin");
        m1();
        System.out.println("main over");
    }
     */
    public static void main(String[] args) {

        // 100 / 0这是算术异常，这个异常是运行时异常，你在编译阶段，可以处理，也可以不处理。编译器不管。
        //System.out.println(100 / 0); // 不处理编译器也不管
        // 你处理也可以。

        System.out.println("main begin");
        try {
            // try尝试
            m1();
            // 以上代码出现异常，直接进入catch语句块中执行。
            System.out.println("hello world!");
        } catch (FileNotFoundException e){ // catch后面的好像一个方法的形参。
            // 这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。
            // catch是捕捉异常之后走的分支。
            // 在catch分支中干什么？处理异常。
            System.out.println("文件不存在，可能路径错误，也可能该文件被删除了！");
            System.out.println(e); //java.io.FileNotFoundException: D:\course\01-课\学习方法.txt (系统找不到指定的路径。)
        }

        // try..catch把异常抓住之后，这里的代码会继续执行。
        System.out.println("main over");
    }

    private static void m1() throws FileNotFoundException {
        System.out.println("m1 begin");
        m2();
        // 以上代码出异常，这里是无法执行的。
        System.out.println("m1 over");
    }

    // 抛别的不行，抛ClassCastException说明你还是没有对FileNotFoundException进行处理
    //private static void m2() throws ClassCastException{

    // 抛FileNotFoundException的父对象IOException，这样是可以的。因为IOException包括FileNotFoundException
    //private static void m2() throws IOException {

    // 这样也可以，因为Exception包括所有的异常。
    //private static void m2() throws Exception{

    // throws后面也可以写多个异常，可以使用逗号隔开。
    //private static void m2() throws ClassCastException, FileNotFoundException{
    private static void m2() throws FileNotFoundException {
        System.out.println("m2 begin");
        // 编译器报错原因是：m3()方法声明位置上有：throws FileNotFoundException
        // 我们在这里调用m3()没有对异常进行预处理，所以编译报错。
        // m3();

        m3();
        // 以上如果出现异常，这里是无法执行的！
        System.out.println("m2 over");
    }

    private static void m3() throws FileNotFoundException {
        /*
        编译报错的原因是什么？
            第一：这里调用了一个构造方法：FileInputStream(String name)
            第二：这个构造方法的声明位置上有：throws FileNotFoundException
            第三：通过类的继承结构看到：FileNotFoundException父类是IOException，IOException的父类是Exception，最终得知，FileNotFoundException是编译时异常。

            错误原因？编译时异常要求程序员编写程序阶段必须对它进行处理，不处理编译器就报错。
         */
        //new FileInputStream("D:\\course\\01-开课\\学习方法.txt");

        // 第一种处理方式：在方法声明的位置上使用throws继续上抛。
        // 一个方法体当中的代码出现异常之后，如果上报的话，此方法结束。
        new FileInputStream("D:\\course\\01-课\\学习方法.txt");
        System.out.println("如果以上代码出异常，这里会执行吗??不会！！！");
    }
}

```

第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。抛给上一级。

第二种方式：使用try..catch语句进行异常的捕捉。这件事发生了，谁也不知道，因为我给抓住了。

举个例子：
我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，“损失1000元”这可以看做是一个异常发生了。我有两种处理方式，第一种方式：我把这件事告诉我的领导【异常上抛】第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】

张三 --> 李四 ---> 王五 --> CEO

思考：
异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。

注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。

### 深入理解try cache机制

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/*
深入try..catch
    1、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。
    2、catch可以写多个。建议catch的时候，精确的一个一个处理。这样有利于程序的调试。
    3、catch写多个的时候，从上到下，必须遵守从小到大。
 */
public class ExceptionTest07 {

    public static void main(String[] args) {

        // 编译报错。

        try {
            //创建输入流
            FileInputStream fis = new FileInputStream("\JavaSE进阶-01-面向对象.pdf");
            //读文件
            fis.read();
        } catch(IOException e){
            System.out.println("读文件报错了！");
        } catch(FileNotFoundException e) {
            System.out.println("文件不存在！");
        }

//-------------------------------------------------


        // JDK8的新特性！
        try {
            //创建输入流
            FileInputStream fis = new FileInputStream("\JavaSE进阶-01-面向对象.pdf");
            // 进行数学运算
            System.out.println(100 / 0); // 这个异常是运行时异常，编写程序时可以处理，也可以不处理。
        } catch(FileNotFoundException | ArithmeticException | NullPointerException e) {
			//可以使用或符号进行声明异常类型
            System.out.println("文件不存在？数学异常？空指针异常？都有可能！");
        }
    }
}
```

### 异常对象的常用方法

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;

/*
异常对象有两个非常重要的方法：

    获取异常简单的描述信息：
        String msg = exception.getMessage();

    打印异常追踪的堆栈信息：
        exception.printStackTrace();
 */
public class ExceptionTest08 {
    public static void main(String[] args) {
        // 这里只是为了测试getMessage()方法和printStackTrace()方法。
        // 这里只是new了异常对象，但是没有将异常对象抛出。JVM会认为这是一个普通的java对象。
        NullPointerException e = new NullPointerException("空指针异常");
        // 获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。
        String msg = e.getMessage(); //msg = 空指针异常

        // 打印异常堆栈信息
        // java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。
        e.printStackTrace();

    }
}


/*
异常对象的两个方法：
    String msg = e.getMessage();
    e.printStackTrace(); // 一般都是使用这个。

我们以后查看异常的追踪信息，我们应该怎么看，可以快速的调试程序呢？
    异常信息追踪信息，从上往下一行一行看。
    但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的。)。
    主要的问题是出现在自己编写的代码上。
 */
public class ExceptionTest09 {
    public static void main(String[] args) {
        try {
            m1();
        } catch (FileNotFoundException e) {
            // 获取异常的简单描述信息
            String msg = e.getMessage();
            System.out.println(msg); //C:\jetns-agent.jar (系统找不到指定的文件。)

            //在实际的开发中，建议使用这个。养成好习惯！
            // 这行代码要写上，不然出问题你也不知道！
            //打印异常堆栈追踪信息！
            //e.printStackTrace();
            /*
				java.io.FileNotFoundException: C:\jetns-agent.jar (系统找不到指定的文件。)
                at com.bjpowernode.javase.exception.ExceptionTest09.m3(ExceptionTest09.java:31)
                at com.bjpowernode.javase.exception.ExceptionTest09.m2(ExceptionTest09.java:27)
                at com.bjpowernode.javase.exception.ExceptionTest09.m1(ExceptionTest09.java:23)
                at com.bjpowernode.javase.exception.ExceptionTest09.main(ExceptionTest09.java:14)
                因为31行出问题导致了27行
                27行出问题导致23行
                23行出问题导致14行。
                应该先查看31行的代码。31行是代码错误的根源。
             */
        }

        // 这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机》
        System.out.println("Hello World!");
    }

    private static void m1() throws FileNotFoundException {
        m2();
    }

    private static void m2() throws FileNotFoundException {
        m3();
    }

    private static void m3() throws FileNotFoundException {
        new FileInputStream("C:\\jetns-agent.jar");
    }
}

```

### finally子句的使用

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/*
关于try..catch中的finally子句：
    1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。（除非退出JVM）
        finally子句必须和try一起出现，不能单独编写。

    2、finally语句通常使用在哪些情况下呢？
        通常在finally语句块中完成资源的释放/关闭。
		因为finally中的代码比较有保障。
		即使try语句块中的代码出现异常，finally中代码也会正常执行。
 */

public class ExceptionTest10 {
    public static void main(String[] args) {
        FileInputStream fis = null; // 声明位置放到try外面。这样在finally中才能用。

		try {
            // 创建输入流对象
            fis = new FileInputStream("D:\\course\\02-JavaSE\\document\\JavaSE进阶讲义\\JavaSE进阶-01-面向对象.pdf");
            // 开始读文件....

            String s = null;
            // 这里一定会出现空指针异常！
            s.toString();
            System.out.println("hello world!");

            // 流使用完需要关闭，因为流是占用资源的。
            // 即使以上程序出现异常，流也必须要关闭！
            // 放在这里有可能流关不了。
            //fis.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch(IOException e){
            e.printStackTrace();
        } catch(NullPointerException e) {
            e.printStackTrace();
        } finally {
            System.out.println("hello Finally ！");
            // 流的关闭放在这里比较保险。
            // finally中的代码是一定会执行的。
            // 即使try中出现了异常！
            if (fis != null) { // 避免空指针异常！
                try {
                    // close()方法有异常，采用捕捉的方式。
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}


/*
finally语句：
    放在finally语句块中的代码是一定会执行的（除非退出JVM）【再次强调！！！】
 */
public class ExceptionTest11 {
    public static void main(String[] args) {
        /*
        try和finally，没有catch可以吗？可以。
            try不能单独使用。
            try finally可以联合使用。
        以下代码的执行顺序：
            先执行try...
            再执行finally...
            最后执行 return （return语句只要执行方法必然结束。）
         */
        try {
            System.out.println("try...");
            return;
        } finally {
            // finally中的语句会执行。能执行到。
            System.out.println("finally...");
        }
        // 这里不能写语句，因为这个代码是无法执行到的。
        //System.out.println("Hello World!");
    }
}


public class ExceptionTest12 {
    public static void main(String[] args) {
        try {
            System.out.println("try...");
            // 退出JVM
            System.exit(0); // 退出JVM之后，finally语句中的代码就不执行了！
        } finally {
            System.out.println("finally...");
        }
    }
}


//----------------面试题

/*
【面试题】【特殊情况】
 */
public class ExceptionTest13 {
    public static void main(String[] args) {
        int result = m();
        System.out.println(result); //100
    }

    /*
    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：
        java中有一条这样的规则：
            方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）
        java中还有一条语法规则：
            return语句一旦执行，整个方法必须结束（亘古不变的语法！）
     */
    public static int m(){
        int i = 100;
        try {
            // 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100
            // return语句还必须保证是最后执行的。一旦执行，整个方法结束。
            return i;
        } finally {
            i++;
        }
    }
}

/*
反编译之后的效果
public static int m(){
    int i = 100;
    int j = i;
    i++;
    return j;
}
 */

```

### finally finalize final

```java
/*
final finally finalize有什么区别？
    final 关键字
        final修饰的类无法继承
        final修饰的方法无法覆盖
        final修饰的变量不能重新赋值。

    finally 关键字
        和try一起联合使用。
        finally语句块中的代码是必须执行的。

    finalize 标识符
        是一个Object类中的方法名。
        这个方法是由垃圾回收器GC负责调用的。
 */
public class ExceptionTest14 {
    public static void main(String[] args) {

        // final是一个关键字。表示最终的。不变的。
        final int i = 100;
        //i = 200;

        // finally也是一个关键字，和try联合使用，使用在异常处理机制中
        // 在fianlly语句块中的代码是一定会执行的。
        try {

        } finally {
            System.out.println("finally....");
        }

        // finalize()是Object类中的一个方法。作为方法名出现。
        // 所以finalize是标识符。
        // finalize()方法是JVM的GC垃圾回收器负责调用。
        Object obj;
    }
}

// final修饰的类无法继承
final class A {
    // 常量。
    public static final double MATH_PI = 3.1415926;
}

class B {
    // final修饰的方法无法覆盖
    public final void doSome(){

    }
}
```

### 自定义异常

```java
/*
1、SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，
这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们
程序员可以自己定义吗？
    可以。

2、Java中怎么自定义异常呢？
    两步：
        第一步：编写一个类继承Exception或者RuntimeException.
        第二步：提供两个构造方法，一个无参数的，一个带有String参数的。

    死记硬背。
 */
public class MyException extends Exception{ // 编译时异常
    public MyException(){

    }
    public MyException(String s){
        super(s);
    }
}

/*
public class MyException extends RuntimeException{ // 运行时异常

}
 */


public class ExceptionTest15 {
    public static void main(String[] args) {

        // 创建异常对象（只new了异常对象，并没有手动抛出）
        MyException e = new MyException("用户名不能为空！");

        // 打印异常堆栈信息
        e.printStackTrace();

        // 获取异常简单描述信息
        String msg = e.getMessage();
        System.out.println(msg);
    }
}
```

### 例题

```java
/*
	编写程序，使用一维数组，模拟栈数据结构。
	【有删减】
 */
public class MyStack {

    private Object[] elements;



    /**
     * 压栈的方法
     * @param obj 被压入的元素
     */
    public void push(Object obj) throws MyStackOperationException {
        if(index >= elements.length - 1){
            // 手动抛出异常！
            throw new MyStackOperationException("压栈失败，栈已满！");
        }

	}
    /**
     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。
     * @return
     */
    public void pop() throws MyStackOperationException {
        if(index < 0){
            throw new MyStackOperationException("弹栈失败，栈已空！");
        }
        // 程序能够执行到此处说明栈没有空。

    }

/**
 * 栈操作异常：自定义异常！
 */
public class MyStackOperationException extends Exception{ // 编译时异常！

    public MyStackOperationException(){

    }

    public MyStackOperationException(String s){
        super(s);
    }

}

```

# IO

## IO流

IDEA的默认当前路径是在哪？工程的根目录

有多种分类方式：

- 一种方式是按照流的方向进行分类：以内存作为参照物
	- 往内存中去，叫做输入(Input)。或者叫做读(Read)。
	- 从内存中出来，叫做输出(Output)。或者叫做写(Write)。

- 另一种方式是按照读取数据方式不同进行分类：
- 有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等....
假设文件file1.txt，采用字节流的话是这样读的：
a中国bc张三fe
第一次读：一个字节，正好读到'a'
第二次读：一个字节，正好读到'中'字符的一半。
第三次读：一个字节，正好读到'中'字符的另外一半。

- 有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。
假设文件file1.txt，采用字符流的话是这样读的：
a中国bc张三fe
第一次读：'a'字符（'a'字符在windows系统中占用1个字节。）
第二次读：'中'字符（'中'字符在windows系统中占用2个字节。）

流的分类

- 输入流、输出流
- 字节流、字符流

java中所有的流都是在：java.io.*;下。

java中主要还是研究：
怎么new流对象。调用流对象的哪个方法是读，哪个方法是写。

java IO流这块有四大家族：
四大家族的首领：
四大家族的首领都是抽象类。(abstract class)

- java.io.InputStream  字节输入流
- java.io.OutputStream 字节输出流

- java.io.Reader字符输入流
- java.io.Writer字符输出流

所有的**流**都实现了：
java.io.Closeable接口，都是可关闭的，都有close()方法。
流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。

所有的**输出流**都实现了：
java.io.Flushable接口，都是可刷新的，都有flush()方法。
养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下。这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道！）刷新的作用就是清空管道。
**注意：如果没有flush()可能会导致丢失数据。**

注意：在java中只要“类名”以Stream结尾的都是字节流。以“Reader/Writer”结尾的都是字符流。

java.io包下需要掌握的流有16个：

文件专属：
java.io.FileInputStream（掌握）
java.io.FileOutputStream（掌握）
java.io.FileReader
java.io.FileWriter

转换流：（将字节流转换成字符流）
java.io.InputStreamReader
java.io.OutputStreamWriter

缓冲流专属：
java.io.BufferedReader
java.io.BufferedWriter
java.io.BufferedInputStream
java.io.BufferedOutputStream

数据流专属：
java.io.DataInputStream
java.io.DataOutputStream

标准输出流：
java.io.PrintWriter
java.io.PrintStream（掌握）

对象专属流：
java.io.ObjectInputStream（掌握）
java.io.ObjectOutputStream（掌握）

java.io.File类。
File类的常用方法。

java io这块还剩下什么内容：
第一：ObjectInputStream ObjectOutputStream的使用。
第二：IO流+Properties集合的联合使用。

### FileInputStream

1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。

2、字节的方式，完成输入的操作，完成读的操作（硬盘---> 内存）

最终版：背模板

```java
public class FileInputStreamTest04 {
    public static void main(String[] args) {
        FileInputStream fis = null; //定义一个 null 的流对象
        try {
            fis = new FileInputStream("chapter23/src/tempfile3"); //流对象赋值
            // 准备一个byte数组
            byte[] bytes = new byte[4];
            /*while(true){
                int readCount = fis.read(bytes);
                if(readCount == -1){
                    break;
                }
                // 把byte数组转换成字符串，读到多少个转换多少个。
                System.out.print(new String(bytes, 0, readCount));
            }*/

            int readCount = 0;
            while((readCount = fis.read(bytes)) != -1) {
                System.out.print(new String(bytes, 0, readCount)); //取已经更新了的字符串输出
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```


FileInputStream类的其它常用方法：
- int available()：返回流当中剩余的没有读到的字节数量
- long skip(long n)：跳过几个字节不读。

```java
public class FileInputStreamTest05 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("tempfile");
            System.out.println("总字节数量：" + fis.available());
            // 读1个字节
            //int readByte = fis.read();
            // 还剩下可以读的字节数量是：5
            //System.out.println("剩下多少个字节没有读：" + fis.available());
            // 这个方法有什么用？
            //byte[] bytes = new byte[fis.available()];
            // 这种方式不太适合太大的文件，因为byte[]数组不能太大。
            // 不需要循环了。
            // 直接读一次就行了。
            //int readCount = fis.read(bytes); // 6
            //System.out.println(new String(bytes)); // abcdef

            // skip跳过几个字节不读取，这个方法也可能以后会用！
            fis.skip(3);
            System.out.println(fis.read()); //100

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```


### FileOutputStream

```java

public class FileOutputStreamTest01 {
    public static void main(String[] args) {
        FileOutputStream fos = null;
        try {
            // 文件不存在的时候会自动新建！
            // 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。

            // 以追加的方式在文件末尾写入。不会清空原文件内容。 加个true
            fos = new FileOutputStream("chapter23/src/tempfile3", true);
            // 开始写。
            byte[] bytes = {97, 98, 99, 100};
            // 将byte数组全部写出！
            fos.write(bytes); // abcd
            // 将byte数组的一部分写出！
            fos.write(bytes, 0, 2); // 再写出ab

            // 字符串
            String s = "我是一个中国人，我骄傲！！！";
            // 将字符串转换成byte数组。
            byte[] bs = s.getBytes();
            // 写
            fos.write(bs);

            // 写完之后，最后一定要刷新
            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```


### FileReader

- 文件字符输入流，只能读取普通文本。
- 读取文本内容时，比较方便，快捷。

```java
public class FileReaderTest {
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            // 创建文件字符输入流
            reader = new FileReader("tempfile");

            //准备一个char数组
            char[] chars = new char[4];
            // 往char数组中读
            // 开始读
            char[] chars = new char[4]; // 一次读取4个*字符*
            int readCount = 0;
            while((readCount = reader.read(chars)) != -1) {
                System.out.print(new String(chars,0,readCount));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

### FileWriter

- 文件字符输出流。写。
- 只能输出普通文本，普通文本，不能输出图片声音等文件
- 能用记事本编辑的都是普通文件
- word不是普通文本

```java
public class FileWriterTest {
    public static void main(String[] args) {
        FileWriter out = null;
        try {
            // 创建文件字符输出流对象
            out = new FileWriter("file", true); // true 表示追加

            // 开始写。
            char[] chars = {'我','是','中','国','人'};
            out.write(chars);
            out.write(chars, 2, 3); //“中国人”

            out.write("我是一名java软件工程师！");
            // 写出一个换行符。
            out.write("\n");

            // 刷新
            out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

### BufferedReader

- 这个流没有前面那些快
- 带有缓冲区的字符输入流。
- 使用这个流的时候**不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲**。

```java
public class BufferedReaderTest01 {
    public static void main(String[] args) throws Exception{

        FileReader reader = new FileReader("Copy02.java");
        // 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。
        // 外部负责包装的这个流，叫做：包装流（处理流）
        // 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。
        BufferedReader br = new BufferedReader(reader);

        // br.readLine()方法读取一个文本行，但不带换行符。
        String s = null;
        while((s = br.readLine()) != null){ //一行一行地读
            System.out.print(s);
        }

        // 关闭流
        // 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）
        br.close();
    }
}
```

### BufferedWriter

```java
public class BufferedWriterTest {
    public static void main(String[] args) throws Exception{
        // 带有缓冲区的字符输出流
        //BufferedWriter out = new BufferedWriter(new FileWriter("copy"));

        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("copy", true)));
        // 开始写。
        out.write("hello world!");
        // 刷新
        out.flush();
        // 关闭最外层
        out.close();
    }
}
```

### 转换流(少用)

#### InputStreamReader

把字节流转换为字符流

```java
public class BufferedReaderTest02 {
    public static void main(String[] args) throws Exception{

        /*// 字节流
        FileInputStream in = new FileInputStream("Copy02.java");

        // 通过转换流转换（InputStreamReader将字节流转换成字符流。）
        // in是节点流。reader是包装流。
        InputStreamReader reader = new InputStreamReader(in);

        // 这个构造方法只能传一个字符流。不能传字节流。
        // reader是节点流。br是包装流。
        BufferedReader br = new BufferedReader(reader);*/

        // 合并
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("Copy02.java")));

        String line = null;
        while((line = br.readLine()) != null){
            System.out.println(line);
        }

        // 关闭最外层
        br.close();
    }
}

```

### 数据流（了解）

- java.io.DataOutputStream：数据专属的流。
- 这个流可以将数据连同数据的类型一并写入文件。
- 注意：这个文件不是普通文本文档。（这个文件使用记事本**打不开**。）

写入文件之后，相当于“加密了”。
用普通的记事本文件打开是乱码，在“解密”的时候，必须按照**一样的顺序**读入流中

```java
public class DataOutputStreamTest {
    public static void main(String[] args) throws Exception{
        // 创建数据专属的字节输出流
        // 抽象类不能创建对象，所以创建文件流
        DataOutputStream dos = new DataOutputStream(new FileOutputStream("data"));
        // 写数据
        byte b = 100;
        short s = 200;
        int i = 300;
        long l = 400L;
        float f = 3.0F;
        double d = 3.14;
        boolean sex = false;
        char c = 'a';
        // 写
        dos.writeByte(b); // 把数据以及数据的类型一并写入到文件当中。
        dos.writeShort(s);
        dos.writeInt(i);
        dos.writeLong(l);
        dos.writeFloat(f);
        dos.writeDouble(d);
        dos.writeBoolean(sex);
        dos.writeChar(c);

        // 刷新
        dos.flush();
        // 关闭最外层
        dos.close();
    }
}

```

- DataInputStream:数据字节输入流。
- DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。
- 读的顺序需要和写的顺序一致。才可以正常取出数据。

```java
public class DataInputStreamTest01 {
    public static void main(String[] args) throws Exception{
        DataInputStream dis = new DataInputStream(new FileInputStream("data"));
        // 开始读
        byte b = dis.readByte();
        short s = dis.readShort();
        int i = dis.readInt();
        long l = dis.readLong();
        float f = dis.readFloat();
        double d = dis.readDouble();
        boolean sex = dis.readBoolean();
        char c = dis.readChar();

        System.out.println(b);
        System.out.println(s);
        System.out.println(i + 1000);
        System.out.println(l);
        System.out.println(f);
        System.out.println(d);
        System.out.println(sex);
        System.out.println(c);

        dis.close();
    }
}
```

### 标准输出流

```java
/*
java.io.PrintStream：标准的字节输出流。默认输出到控制台。
 */
public class PrintStreamTest {
    public static void main(String[] args) throws Exception{

        // 联合起来写
        System.out.println("hello world!");

        // 分开写
        PrintStream ps = System.out;
        ps.println("hello zhangsan");

        // 标准输出流不需要手动close()关闭。
        // 可以改变标准输出流的输出方向吗？ 可以
        /*
        // 这些是之前System类使用过的方法和属性。
        System.gc();
        System.currentTimeMillis();
        PrintStream ps2 = System.out;
        System.exit(0);
        System.arraycopy(....);
         */

        // 标准输出流不再指向控制台，指向“log”文件。
        PrintStream printStream = new PrintStream(new FileOutputStream("log"));
        // 修改输出方向，将输出方向修改到"log"文件。
        System.setOut(printStream);
        // 再输出
        System.out.println("hello world");//这些就输出在log文件中了（日志框架）
    }
}

```

记录日志：

```java
/*
日志工具
 */
public class Logger {
    /*
    记录日志的方法。
     */
    public static void log(String msg) {
        try {
            // 指向一个日志文件
            PrintStream out = new PrintStream(new FileOutputStream("log.txt", true));
            // 改变输出方向
            System.setOut(out);
            // 日期当前时间
            Date nowTime = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
            String strTime = sdf.format(nowTime);

            System.out.println(strTime + ": " + msg);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 对象流

java.io.NotSerializableException:
- Student对象不支持序列化

- 参与序列化和反序列化的对象，必须实现Serializable接口。

- 注意：通过源代码发现，Serializable接口只是一个标志接口：
    - public interface Serializable {}这个接口当中什么代码都没有。
    - 那么它起到一个什么作用呢？
        - 起到标识的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。
        Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成
        一个序列化版本号。

- 序列化版本号有什么用呢？
    java.io.InvalidClassException:
        com.bjpowernode.java.bean.Student;
        local class incompatible:
            stream classdesc serialVersionUID = -684255398724514298（十年后）,
            local class serialVersionUID = -3463447116624555755（十年前）

- java语言中是采用什么机制来区分类的？
	+ 第一：首先通过类名进行比对，如果类名不一样，肯定不是同一个类。
	+ 第二：如果类名一样，再怎么进行类的区别？靠序列化版本号进行区分。

- 小鹏编写了一个类：com.bjpowernode.java.bean.Student implements Serializable
- 胡浪编写了一个类：com.bjpowernode.java.bean.Student implements Serializable
- 不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了:对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）

请思考？

- 这种自动生成序列化版本号有什么缺陷？
- 这种自动生成的序列化版本号缺点是：一旦代码确定之后，不能进行后续的修改，
- 因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java
- 虚拟机会认为这是一个全新的类。（这样就不好了！）

最终结论：

- 凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。
- private static final long serialVersionUID = -123456789;(自己指定)
- IDEA生成

```java

//序列化

//一个一个存，存多个对象报错，只能通过序列化集合

public class ObjectOutputStreamTest01 {
    public static void main(String[] args) throws Exception{
        // 创建java对象
        Student s = new Student(1111, "zhangsan");
        // 序列化
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students"));

        // 序列化对象
        oos.writeObject(s);

        // 刷新
        oos.flush();
        // 关闭
        oos.close();
    }
}

/*
一次序列化多个对象呢？
    可以，可以将对象放到集合当中，序列化集合。
提示：
    参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口。
 */
public class ObjectOutputStreamTest02 {
    public static void main(String[] args) throws Exception{
        List<User> userList = new ArrayList<>();
        userList.add(new User(1,"zhangsan"));
        userList.add(new User(2, "lisi"));
        userList.add(new User(3, "wangwu"));
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("users"));

        // 序列化一个集合，这个集合对象中放了很多其他对象。
        oos.writeObject(userList);

        oos.flush();
        oos.close();
    }
}

//反序列化

public class ObjectInputStreamTest01 {
    public static void main(String[] args) throws Exception{
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("students"));
        // 开始反序列化，读
        Object obj = ois.readObject();
        // 反序列化回来是一个学生对象，所以会调用学生对象的toString方法。
        System.out.println(obj);
        ois.close();
    }
}

/*
反序列化集合
 */
public class ObjectInputStreamTest02 {
    public static void main(String[] args) throws Exception{
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("users"));
        //Object obj = ois.readObject();
        //System.out.println(obj instanceof List);
        List<User> userList = (List<User>)ois.readObject();
        for(User user : userList){
            System.out.println(user);
        }
        ois.close();
    }
}


```

transient 关键字，指定的变量不参加序列化

### IO + properties 联合使用

IO+Properties的联合应用。

非常好的一个设计理念：
- 以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启。就可以拿到动态的信息。

- 类似于以上机制的这种文件被称为配置文件。并且当配置文件中的内容格式是： key=value 的时候，我们把这种配置文件叫做属性配置文件。

java规范中有要求：
- 属性配置文件建议以.properties结尾，但这不是必须的。
- 这种以.properties结尾的文件在java中被称为：属性配置文件。
- 其中Properties是专门存放属性配置文件内容的一个类。
- 最好不要有空格
- 在属性配置文件中， # 为注释，重复的值会覆盖

```java
public class IoPropertiesTest01 {
    public static void main(String[] args) throws Exception{
        /*
        Properties是一个Map集合，key和value都是String类型。
        想将userinfo文件中的数据加载到Properties对象当中。
         */
        // 新建一个输入流对象
        FileReader reader = new FileReader("chapter23/userinfo.properties");

        // 新建一个Map集合
        Properties pro = new Properties();

        // 调用Properties对象的load方法将文件中的数据加载到Map集合中。
        pro.load(reader); // 文件中的数据顺着管道加载到Map集合中，其中等号=左边做key，右边做value

        // 通过key来获取value呢？
        String username = pro.getProperty("username");
        System.out.println(username);
    }
}
```


### 文件复制

#### FileInputStream + FileOutputStream

- 使用FileInputStream + FileOutputStream完成文件的拷贝。
- 拷贝的过程应该是一边读，一边写。
- 使用以上的字节流拷贝文件的时候，文件类型随意，万能的。**什么样的文件都能拷贝。**

```java
public class Copy01 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            // 创建一个输入流对象
            fis = new FileInputStream("D:\\course\\02-JavaSE\\video\\chapter01\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi");
            // 创建一个输出流对象
            fos = new FileOutputStream("C:\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi");

            // 最核心的：一边读，一边写
            byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）
            int readCount = 0;
            while((readCount = fis.read(bytes)) != -1) {
                fos.write(bytes, 0, readCount);
            }

            // 刷新，输出流最后要刷新
            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 分开try，不要一起try。
            // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

#### FileReader + FileWriter

```java
public class Copy02 {
    public static void main(String[] args) {
        FileReader in = null;
        FileWriter out = null;
        try {
            // 读
            in = new FileReader("chapter23/src/com/bjpowernode/java/io/Copy02.java");
            // 写
            out = new FileWriter("Copy02.java");

            // 一边读一边写：
            char[] chars = new char[1024 * 512]; // 1MB
            int readCount = 0;
            while((readCount = in.read(chars)) != -1){
                out.write(chars, 0, readCount);
            }

            // 刷新
            out.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
```

#### 目录拷贝

```java
/*
拷贝目录
 */
public class CopyAll {
    public static void main(String[] args) {
        // 拷贝源
        File srcFile = new File("D:\\course\\02-JavaSE\\document");
        // 拷贝目标
        File destFile = new File("C:\\a\\b\\c");
        // 调用方法拷贝
        copyDir(srcFile, destFile);
    }

    /**
     * 拷贝目录
     * @param srcFile 拷贝源
     * @param destFile 拷贝目标
     */
    private static void copyDir(File srcFile, File destFile) {
        if(srcFile.isFile()) {
            // srcFile如果是一个文件的话，递归结束。
            // 是文件的时候需要拷贝。
            // ....一边读一边写。
            FileInputStream in = null;
            FileOutputStream out = null;
            try {
                // 读这个文件
                // D:\course\02-JavaSE\document\JavaSE进阶讲义\JavaSE进阶-01-面向对象.pdf
                in = new FileInputStream(srcFile);
                // 写到这个文件中
                // C:\course\02-JavaSE\document\JavaSE进阶讲义\JavaSE进阶-01-面向对象.pdf
                String path = (destFile.getAbsolutePath().endsWith("\\") ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + "\\")  + srcFile.getAbsolutePath().substring(3);
                out = new FileOutputStream(path);
                // 一边读一边写
                byte[] bytes = new byte[1024 * 1024]; // 一次复制1MB
                int readCount = 0;
                while((readCount = in.read(bytes)) != -1){
                    out.write(bytes, 0, readCount);
                }
                out.flush();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            return;
        }
        // 获取源下面的子目录
        File[] files = srcFile.listFiles();
        for(File file : files){
            // 获取所有文件的（包括目录和文件）绝对路径
            //System.out.println(file.getAbsolutePath());
            if(file.isDirectory()){
                // 新建对应的目录
                //System.out.println(file.getAbsolutePath());
                //D:\course\02-JavaSE\document\JavaSE进阶讲义       源目录
                //C:\course\02-JavaSE\document\JavaSE进阶讲义       目标目录
                String srcDir = file.getAbsolutePath();
                String destDir = (destFile.getAbsolutePath().endsWith("\\") ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + "\\")  + srcDir.substring(3);
                File newFile = new File(destDir);
                if(!newFile.exists()){
                    newFile.mkdirs();
                }
            }
            // 递归调用
            copyDir(file, destFile);
        }
    }
}
```

### File类

File类和四大家族没有关系，所以File类不能完成文件的读和写。
File对象代表什么？

	- 文件和目录路径名的抽象表示形式。
	- C:\Drivers 这是一个File对象
	- C:\Drivers\Lan\Realtek\Readme.txt 也是File对象。
	- 一个File对象有可能对应的是目录，也可能是文件。
	- File只是一个路径名的抽象表示形式。


```java
public class FileTest01 {
    public static void main(String[] args) throws Exception {
        // 创建一个File对象
        File f1 = new File("D:\\file");

        // 判断是否存在！
        System.out.println(f1.exists());

        // 如果D:\file不存在，则以文件的形式创建出来
        if(!f1.exists()) {
            // 以文件形式新建
            f1.createNewFile();
        }

        // 如果D:\file不存在，则以目录的形式创建出来
        if(!f1.exists()) {
            // 以目录的形式新建。
            f1.mkdir();
        }

        // 可以创建多重目录吗？
        File f2 = new File("D:/a/b/c/d/e/f");
        if(!f2.exists()) {
            // 多重目录的形式新建。
            f2.mkdirs();
        }

        File f3 = new File("D:\\course\\01-开课\\学习方法.txt");
        // 获取文件的父路径
        String parentPath = f3.getParent();
        System.out.println(parentPath); //D:\course\01-开课
        File parentFile = f3.getParentFile();
        System.out.println("获取绝对路径：" + parentFile.getAbsolutePath());

        File f4 = new File("copy");
        System.out.println("绝对路径：" + f4.getAbsolutePath()); // C:\Users\Administrator\IdeaProjects\javase\copy

    }
}

public class FileTest02 {
    public static void main(String[] args) {

        File f1 = new File("D:\\course\\01-开课\\开学典礼.ppt");
        // 获取文件名
        System.out.println("文件名：" + f1.getName());

        // 判断是否是一个目录
        System.out.println(f1.isDirectory()); // false

        // 判断是否是一个文件
        System.out.println(f1.isFile()); // true

        // 获取文件最后一次修改时间
        long haoMiao = f1.lastModified(); // 这个毫秒是从1970年到现在的总毫秒数。
        // 将总毫秒数转换成日期?????
        Date time = new Date(haoMiao);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
        String strTime = sdf.format(time);
        System.out.println(strTime);

        // 获取文件大小
        System.out.println(f1.length()); //216064字节。
    }
}


/*
File中的listFiles方法。
 */
public class FileTest03 {
    public static void main(String[] args) {
        // File[] listFiles()
        // 获取当前目录下所有的子文件。
        File f = new File("D:\\course\\01-开课");
        File[] files = f.listFiles();
        // foreach
        for(File file : files){
            //System.out.println(file.getAbsolutePath());
            System.out.println(file.getName());
        }
    }
}
```


# Java注解

## 注解

Annotation

注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件。

怎么自定义注解呢？ [修饰符列表] @interface 注解类型名{ }

注解使用时的语法格式是：@注解类型名

注解可以出现在类上、属性上、方法上、变量上等....注解还可以出现在注解类型上。默认情况下，注解可以出现在任意位置。

### 内置注解

#### Override

关于JDK lang包下的Override注解
源代码：public @interface Override {}

- 标识性注解，给编译器做参考的。编译器看到方法上有这个注解的时候，编译器会自动检查该方法是否重写了父类的方法。如果没有重写，报错。
- 这个注解只是在编译阶段起作用，和运行期无关！
- @Override这个注解只能注解方法。
- @Override这个注解是给编译器参考的，和运行阶段没有关系。

凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。
Override 表示一个方法声明打算重写超类中的另一个方法声明。

#### Deprecated

作用：告诉其他程序员这个标记的元素已经过时了。

注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。

### 元注解

什么是元注解？用来标注“注解类型”的“注解”，称为元注解。

常见的元注解有哪些？Target/Retention

关于Target注解：这是一个元注解，用来标注“注解类型”的“注解”这个Target注解用来标注“被标注的注解”可以出现在哪些位置上。

@Target(ElementType.METHOD)：表示“被标注的注解”只能出现在方法上。
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})
表示该注解可以出现在：构造方法上/字段上/局部变量上/方法上/类上...


关于Retention注解：这是一个元注解，用来标注“注解类型”的“注解”这个Retention注解用来标注“被标注的注解”最终保存在哪里。

@Retention(RetentionPolicy.SOURCE)：表示该注解只被保留在java源文件中。
@Retention(RetentionPolicy.CLASS)：表示该注解被保存在class文件中。
@Retention(RetentionPolicy.RUNTIME)：表示该注解被保存在class文件中，并且可以被反射机制所读取。

### 注解中的属性

```java
public @interface MyAnnotation {
    /**
     * 我们通常在注解当中可以定义属性，以下这个是MyAnnotation的name属性。
     * 看着像1个方法，但实际上我们称之为属性name。
     * @return
     */
    String name();
    String color();
    int age() default 25; //属性指定默认值
}

public class MyAnnotationTest {
    //报错的原因：如果一个注解当中有属性，那么必须给属性赋值。（除非该属性使用default指定了默认值。）
    //@MyAnnotation(属性名=属性值,属性名=属性值,属性名=属性值)
    //指定name属性的值就好了。
    @MyAnnotation(name = "zhangsan", color = "红色")
    public void doSome(){
    }
}
```

```java
/*
如果一个注解的属性的名字是value(其他名字不行)，并且只有一个属性的话，在使用的时候，该属性名可以省略。
 */
public class MyAnnotationTest {

    // 报错原因：没有指定属性的值。
    /*@MyAnnotation
    public void doSome(){
    }*/

    @MyAnnotation(value = "hehe")
    public void doSome(){
    }

    @MyAnnotation("haha")
    public void doOther(){
    }
}
```

需求：
假设有这样一个注解，叫做：@Id

这个注解只能出现在类上面，当这个类上有这个注解的时候，要求这个类中必须有一个int类型的id属性。如果没有这个属性就报异常。如果有这个属性则正常执行！


# Java反射

## 反射机制

反射机制（比较简单，因为只要会查帮助文档，就可以了。）

反射机制有什么用？

- 通过java语言中的反射机制可以操作字节码文件。
- 类似于黑客。（可以读和修改字节码文件。）
- 通过反射机制可以操作代码片段。（class文件。）

- java.lang.reflect.*;

反射机制相关的重要的类有哪些？

- java.lang.Class：代表整个字节码，代表一个类型，代表整个类。
- java.lang.reflect.Method：代表字节码中的方法字节码。代表类中的方法。
- java.lang.reflect.Constructor：代表字节码中的构造方法字节码。代表类中的构造方法
- java.lang.reflect.Field：代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。

### 获取一个类的字节码

三种方式

- 第一种：Class c = Class.forName("完整类名带包名");
- 第二种：Class c = 对象.getClass();
- 第三种：Class c = 任何类型.class;

```java
public class ReflectTest01 {
    public static void main(String[] args) {
        /*
        Class.forName()
            1、静态方法
            2、方法的参数是一个字符串。
            3、字符串需要的是一个完整类名。
            4、完整类名必须带有包名。java.lang包也不能省略。
         */
        Class c1 = null;
        Class c2 = null;
        try {
            c1 = Class.forName("java.lang.String"); // c1代表String.class文件，或者说c1代表String类型。
            c2 = Class.forName("java.util.Date"); // c2代表Date类型
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        //第二种方式 java中任何一个对象都有一个方法：getClass()
        String s = "abc";
        Class x = s.getClass(); // x代表String.class字节码文件，x代表String类型。

        // 第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.class属性。
        Class z = String.class; // z代表String类型
        Class e = double.class; // e代表double类型
    }
}
```


3、关于JDK中自带的类加载器：（聊一聊，不需要掌握，知道当然最好！）
3.1、什么是类加载器？
专门负责加载类的命令/工具。
ClassLoader

3.2、JDK中自带了3个类加载器
启动类加载器:rt.jar
扩展类加载器:ext/*.jar
应用类加载器:classpath

3.3、假设有这样一段代码：
String s = "abc";

代码在开始执行之前，会将所需要类全部加载到JVM当中。
通过类加载器加载，看到以上代码类加载器会找String.class
文件，找到就加载，那么是怎么进行加载的呢？

首先通过“启动类加载器”加载。
注意：启动类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\rt.jar
rt.jar中都是JDK最核心的类库。

如果通过“启动类加载器”加载不到的时候，
会通过"扩展类加载器"加载。
注意：扩展类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\ext\*.jar


如果“扩展类加载器”没有加载到，那么
会通过“应用类加载器”加载。
注意：应用类加载器专门加载：classpath中的类。

3.4、java中为了保证类加载的安全，使用了双亲委派机制。
优先从启动类加载器中加载，这个称为“父”
“父”无法加载到，再从扩展类加载器中加载，
这个称为“母”。双亲委派。如果都加载不到，
才会考虑从应用类加载器中加载。直到加载
到为止。

1、回顾反射机制

1.1、什么是反射机制？反射机制有什么用？
反射机制：可以操作字节码文件
作用：可以让程序更加灵活。

1.2、反射机制相关的类在哪个包下？
java.lang.reflect.*;

1.3、反射机制相关的主要的类？
java.lang.Class
java.lang.reflect.Method;
java.lang.reflect.Constructor;
java.lang.reflect.Field;

1.4、在java中获取Class的三种方式？
第一种：
Class c = Class.forName("完整类名");
第二种：
Class c = 对象.getClass();
第三种：
Class c = int.class;
Class c = String.class;

1.5、获取了Class之后，可以调用无参数构造方法来实例化对象

//c代表的就是日期Date类型
Class c = Class.forName("java.util.Date");

//实例化一个Date日期类型的对象
Object obj = c.newInstance();

一定要注意：
newInstance()底层调用的是该类型的无参数构造方法。
如果没有这个无参数构造方法会出现"实例化"异常。

1.6、如果你只想让一个类的“静态代码块”执行的话，你可以怎么做？
Class.forName("该类的类名");
这样类就加载，类加载的时候，静态代码块执行！！！！
在这里，对该方法的返回值不感兴趣，主要是为了使用“类加载”这个动作。

1.7、关于路径问题？

String path = Thread.currentThread().getContextClassLoader()
  .getResource("写相对路径，但是这个相对路径从src出发开始找").getPath();

String path = Thread.currentThread().getContextClassLoader()
  .getResource("abc").getPath();//必须保证src下有abc文件。

String path = Thread.currentThread().getContextClassLoader()
  .getResource("a/db").getPath();//必须保证src下有a目录，a目录下有db文件。

String path = Thread.currentThread().getContextClassLoader()
  .getResource("com/bjpowernode/test.properties").getPath();
  //必须保证src下有com目录，com目录下有bjpowernode目录。
  //bjpowernode目录下有test.properties文件。

这种方式是为了获取一个文件的绝对路径。（通用方式，不会受到环境移植的影响。）
但是该文件要求放在类路径下，换句话说：也就是放到src下面。
src下是类的根路径。

直接以流的形式返回：
InputStream in = Thread.currentThread().getContextClassLoader()
.getResourceAsStream("com/bjpowernode/test.properties");

1.8、IO + Properties，怎么快速绑定属性资源文件？

//要求：第一这个文件必须在类路径下
//第二这个文件必须是以.properties结尾。
ResourceBundle bundle = ResourceBundle.getBundle("com/bjpowernode/test");
String value = bundle.getString(key);

2、今日反射机制的重点内容
2.1、通过反射机制访问对象的某个属性。
2.2、通过反射机制调用对象的某个方法。
2.3、通过反射机制调用某个构造方法实例化对象。
2.4、通过反射机制获取父类以及父类型接口。

# Java多线程基础

## 多线程

什么是进程？什么是线程？
- 进程是一个应用程序（1个进程是一个软件）。
- 线程是一个进程中的执行场景/执行单元。
- 一个进程可以启动多个线程。

对于java程序来说，当在DOS命令窗口中输入：java HelloWorld 回车之后。会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收线程，一个是执行main方法的主线程。

进程和线程是什么关系？举个例子
- 阿里巴巴：进程
	- 马云：阿里巴巴的一个线程
	- 童文红:阿里巴巴的一个线程
- 京东：进程
	+ 强东：京东的一个线程
	+ 妹妹：京东的一个线程
- 进程可以看做是现实生活当中的公司。
- 线程可以看做是公司当中的某个员工。

注意：

- 进程A和进程B的内存独立不共享。（阿里巴巴和京东资源不会共享的！）
- 魔兽游戏是一个进程
- 酷狗音乐是一个进程
- 这两个进程是独立的，不共享资源。

线程A和线程B呢？
在java语言中：线程A和线程B，**堆内存和方法区内存**共享。但是**栈内存**独立，一个线程一个栈。
假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。

火车站，可以看做是一个进程。火车站中的每一个售票窗口可以看做是一个线程。我在窗口1购票，你可以在窗口2购票，你不需要等我，我也不需要等你。所以多线程并发可以提高效率。

- java中之所以有多线程机制，目的就是为了提高程序的处理效率。

- 使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈。

对于多核的CPU电脑来说，真正的多线程并发是没问题的。4核CPU表示同一个时间点上，可以真正的有4个进程并发执行。

分析一个问题：对于单核的CPU来说，真的可以做到真正的多线程并发吗？

什么是真正的多线程并发？t1线程执行t1的。t2线程执行t2的。t1不会影响t2，t2也不会影响t1。这叫做真正的多线程并发。

单核的CPU表示只有一个大脑：
**不能**够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是：多个事情同时在做！
线程A：播放音乐
线程B：运行魔兽游戏
线程A和线程B频繁切换执行，人类会感觉音乐一直在播放，游戏一直在运行，给我们的感觉是同时并发的。

电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要“很长的”时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。

### 实现多线程的两种方式

#### 第一种方式

实现线程的第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。

- 怎么创建线程对象？ new就行了。
- 怎么启动线程呢？ 调用线程对象的start()方法。
- 注意：亘古不变的道理：方法体当中的代码永远都是自上而下的顺序依次逐行执行的。
- 以下程序的输出结果有这样的特点：有先有后。有多有少。这是咋回事？
```java
public class ThreadTest02 {
    public static void main(String[] args) {
        // 这里是main方法，这里的代码属于主线程，在主栈中运行。
        // 新建一个分支线程对象
        MyThread t = new MyThread();
        // 启动线程
        //t.run(); // 直接调用run方法不会启动另一个线程，不会分配新的分支栈。（这种方式就是单线程。）

        // start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。
        // run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。
        t.start();
        // 这里的代码还是运行在主线程中。
        for(int i = 0; i < 100; i++){
            System.out.println("主线程--->" + i);
        }
    }
}
class MyThread extends Thread {
    @Override
    public void run() {
        // 编写程序，这段程序运行在分支线程中（分支栈）。
        for(int i = 0; i < 100; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```

#### 第二种方式

实现线程的第二种方式，编写一个类实现java.lang.Runnable接口。

```java
public class ThreadTest03 {
    public static void main(String[] args) {
        // 创建一个可运行的对象
        // 将可运行的对象封装成一个线程对象
        Thread t = new Thread(new MyRunnable()); // 合并代码
        // 启动线程
        t.start();
        for(int i = 0; i < 100; i++)
            System.out.println("主线程--->" + i);
    }
}

// 这并不是一个线程类，是一个可运行的类。它还不是一个线程。
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 100; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```



匿名内部类

```java
public class ThreadTest04 {
    public static void main(String[] args) {
        // 创建线程对象，采用匿名内部类方式。
        // 这是通过一个没有名字的类，new出来的对象。
        Thread t = new Thread(new Runnable(){
            @Override
            public void run() {
                for(int i = 0; i < 100; i++){
                    System.out.println("t线程---> " + i);
                }
            }
        });

        // 启动线程
        t.start();

        for(int i = 0; i < 100; i++){
            System.out.println("main线程---> " + i);
        }
    }
}
```

#### 第三种方式


实现线程的第三种方式：实现Callable接口。（JDK8新特性。）
这种方式实现的线程可以获取线程的返回值。
之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

思考：
系统委派一个线程去执行一个任务，该线程执行完任务之后，可能
会有一个执行结果，我们怎么能拿到这个执行结果呢？
使用第三种方式：实现Callable接口方式。

实现线程的第三种方式：
- 实现Callable接口
- 这种方式的优点：可以获取到线程的执行结果。
- 这种方式的缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。

 ```java
public class ThreadTest15 {
    public static void main(String[] args) throws Exception {

        // 第一步：创建一个“未来任务类”对象。
        // 参数非常重要，需要给一个Callable接口实现类对象。
        FutureTask task = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception { // call()方法就相当于run方法。只不过这个有返回值
                // 线程执行一个任务，执行之后可能会有一个执行结果
                // 模拟执行
                System.out.println("call method begin");
                Thread.sleep(1000 * 10);
                System.out.println("call method end!");
                int a = 100;
                int b = 200;
                return a + b; //自动装箱(300结果变成Integer)
            }
        });

        // 创建线程对象
        Thread t = new Thread(task);

        // 启动线程
        t.start();

        // 这里是main方法，这是在主线程中。
        // 在主线程中，怎么获取t线程的返回结果？
        // get()方法的执行会导致“当前线程阻塞”
        // main方法这里的程序要想执行必须等待get()方法的结束
        // 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果
        // 另一个线程执行是需要时间的。
        Object obj = task.get();
        System.out.println("线程执行结果:" + obj);
    }
}
 ```

怎么获取当前线程对象？
- Thread t = Thread.currentThread();
- 返回值t就是当前线程，这个代码出现在main中，当前线程就是主线程

获取线程对象的名字
- String name = 线程对象.getName();

修改线程对象的名字
- 线程对象.setName("线程名字");

当线程没有设置名字的时候，默认的名字有什么规律？main/Thread-0/Thread-1/Thread-2/Thread-3/.....

### 睡眠与终止

#### sleep

关于线程的sleep方法： static void sleep(long millis)

1、静态方法：Thread.sleep(1000);
2、参数是毫秒
3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。
4、Thread.sleep()方法，可以做到这种效果：间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。

```java
public class ThreadTest06 {
    public static void main(String[] args) {

        for(int i = 0; i < 10; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);

            // 睡眠1秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

sleep睡眠太久了，如果希望半道上醒来，你应该怎么办？也就是说怎么叫醒一个正在睡眠的线程？？
注意：这个不是终断线程的执行，是终止线程的睡眠。

```java
public class ThreadTest08 {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable2());
        t.setName("t");
        t.start();

        // 希望5秒之后，t线程醒来（5秒之后主线程手里的活儿干完了。）
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）
        // 所以线程中必须对异常进行捕捉
        t.interrupt(); // 干扰，一盆冷水过去！
    }
}
```

#### 终止

不建议使用：线程名称.stop();  已过时，不建议使用，容易丢失数据！

合理方式：

打标记/改标记。

```java
public class ThreadTest10 {
    public static void main(String[] args) {
        MyRunable4 r = new MyRunable4();
        Thread t = new Thread(r);
        t.setName("t");
        t.start();

        // 模拟5秒
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 终止线程
        // 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。
        r.run = false;
    }
}

class MyRunable4 implements Runnable {
    // 打一个布尔标记
    boolean run = true;
    @Override
    public void run() {
        for (int i = 0; i < 10; i++){
            if(run){
                System.out.println(Thread.currentThread().getName() + "--->" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }else{
                // return就结束了，你在结束之前还有什么没保存的。
                // 在这里可以保存。
                //save....
                //终止当前线程
                return;
            }
        }
    }
}
```

### 调度/优先级/让位/合并

常见的线程调度模型有哪些？

- 抢占式调度模型：那个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。java采用的就是抢占式调度模型。
- 均分式调度模型：平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。平均分配，一切平等。有一些编程语言，线程调度模型采用的是这种方式。

#### 优先级：

实例方法：

- void setPriority(int newPriority) 设置线程的优先级
- int getPriority() 获取线程优先级
- 最低优先级1
- 默认优先级是5
- 最高优先级10
- 优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的。）

main线程的默认优先级是：5

- 优先级较高的，只是抢到的CPU时间片相对多一些。
- 大概率方向更偏向于优先级比较高的。

#### 让位

静态方法：
- static void yield()  让位方法
- Thread.yield(); 让位，当前线程暂停，回到就绪状态，让给其它线程。
- 暂停当前正在执行的线程对象，并执行其他线程
- yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。注意：在回到就绪之后，有可能还会再次抢到。

#### 合并

```java
public class ThreadTest13 {
    public static void main(String[] args) {
        System.out.println("main begin");
        Thread t = new Thread(new MyRunnable7());
        t.setName("t");
        t.start();
        //合并线程
        try {
            t.join(); // t合并到当前线程中，当前线程受阻塞，t线程执行直到结束。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main over");
    }
}

class MyRunnable7 implements Runnable {

    @Override
    public void run() {
        for(int i = 0; i < 10000; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```

### synchronized

#### 线程安全

为什么这个是重点？
- 以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编写。

最重要的是
- 你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。（重点）

什么时候数据在多线程并发的环境下会存在安全问题呢？

- 条件1：多线程并发。
- 条件2：有共享数据。
- 条件3：共享数据有修改的行为。
- 满足以上3个条件之后，就会存在线程安全问题。


当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？
- 线程排队执行。（不能并发）。
- 用排队执行解决线程安全问题。
- 这种机制被称为：线程同步机制。
- 专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。

怎么解决线程安全问题？ 使用“线程同步机制”。

线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。

说到线程同步这块，涉及到这两个专业术语：

- 异步编程模型：
	- 线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型。其实就是：多线程并发（效率较高。）
	- 异步就是并发。

- 同步编程模型：
	- 线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。
	效率较低。线程排队执行。
	- 同步就是排队。


实例变量：在堆中。
静态变量：在方法区。
局部变量：在栈中。

以上三大变量中：
局部变量永远都不会存在线程安全问题。因为局部变量不共享。（一个线程一个栈。）局部变量在栈中。所以局部变量永远都不会共享。

实例变量在堆中，堆只有1个。静态变量在方法区中，方法区只有1个。堆和方法区都是多线程共享的，所以可能存在线程安全问题。

局部变量+常量：不会有线程安全问题。
成员变量：可能会有线程安全问题。

如果使用局部变量的话：建议使用：StringBuilder。因为局部变量不存在线程安全问题。选择StringBuilder。StringBuffer效率比较低。

- ArrayList是非线程安全的。
- Vector是线程安全的。
- HashMap HashSet是非线程安全的。
- Hashtable是线程安全的。

#### 银行取钱模拟

存在问题的：

```java
public class Test{
    public static void main(String[] args) {
        //创建账户对象，只建一个
        Account act = new Account("act-001", 10000);
        //创建两个线程
        Thread t1 = new AccountThread(act);
        Thread t2 = new AccountThread(act);
        //设置name
        t1.setName("t1");
        t2.setName("t2");
        //启动线程取款
        t1.start();
        t2.start();
    }
}

class Account {
    private String actno; //账号
    private double balance; //余额

    public Account(String actno, double balance) {
        this.actno = actno;
        this.balance = balance;
    }

    public String getActno() {
        return actno;
    }

    public void setActno(String actno) {
        this.actno = actno;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void withdraw(double money){
        //取款之前的余额
        double before = this.getBalance();
        //取款之后的余额
        double after = before - money;

        // 在这里模拟一下网络延迟，一定会出问题-》两次的余额都是 5000
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //更新余额
        //t1执行到了这里，但是还没有来得及只从这行代码，t2线程进来withdraw方法了，此时一定出问题
        this.setBalance(after);
    }
}

class AccountThread extends Thread{
    //两个线程必须共享同一个账户对象
    private Account act;
    //通过构造方法传递过来账户对象
    public AccountThread(Account act){
        this.act = act;
    }
    //run 方法的执行标识取款操作
    public void run(){
        //取5000
        double money = 5000;
        act.withdraw(money);
        System.out.println( Thread.currentThread().getName() + "账户" + act.getActno() + "取款" + money + "成功， 余额为" + act.getBalance());
    }
}
```

使用了线程同步机制解决问题：

```java
public class Test{
    public static void main(String[] args) {
        //创建账户对象，只建一个
        Account act = new Account("act-001", 10000);
        //创建两个线程
        Thread t1 = new AccountThread(act);
        Thread t2 = new AccountThread(act);
        //设置name
        t1.setName("t1");
        t2.setName("t2");
        //启动线程取款
        t1.start();
        t2.start();
    }
}

class Account {
    private String actno; //账号
    private double balance; //余额

    public Account(String actno, double balance) {
        this.actno = actno;
        this.balance = balance;
    }

    public String getActno() {
        return actno;
    }

    public void setActno(String actno) {
        this.actno = actno;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void withdraw(double money){
        //以下这几行代码必须时县城排队的，不能并发
        //一个线程把这里的代码全部执行结束之后，另一个线程才能进来
        /*
        线程同步机制的语法：
        synchronized () {
            //线程同步代码块
        }
        synchronized 后面小括号中的数据时相当关键的，这个数据必须是多线程共享的数据才能达到多线程排队。
        ()中写什么，要看你想让哪些线程同步
            假设t1、t2、t3、t4、t5，有5个线程，你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办？你一定要在()中写一个t1 t2 t3共享的对象。而这个对象对于t4 t5来说不是共享的。

            这里的共享对象是：账户对象。
            账户对象是共享的，那么this就是账户对象吧！！！
            不一定是this，这里只要是多线程共享的那个对象就行。

            在java语言中，任何一个对象都有“一把锁”，其实这把锁就是标记。（只是把它叫做锁。）
            100个对象，100把锁。1个对象1把锁。

            以下代码的执行原理？
                1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。
                2、假设t1先执行了，遇到了synchronized，这个时候自动找“后面共享对象”的对象锁，
                找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是
                占有这把锁的。直到同步代码块代码结束，这把锁才会释放。
                3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面
                共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，
                直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后
                t2占有这把锁之后，进入同步代码块执行程序。

                这样就达到了线程排队执行。
                这里需要注意的是：这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共享的。

         */
        //synchronized (this){ //正确
        //synchronized (obj) { // 实例变量，只有一个，正确
        //synchronized ("abc") { // "abc"在字符串常量池当中。->所有线程都会同步，所以不行
        //synchronized (null) { // 报错：空指针。
        //synchronized (obj2) { // 这样编写就不安全了。因为obj2不是共享对象。是局部变量，不对

        synchronized (this) {
            double before = this.getBalance();
            double after = before - money;
            try { //模拟网络延迟
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        //更新余额
        //t1执行到了这里，但是还没有来得及只从这行代码，t2线程进来withdraw方法了，此时一定出问题
        this.setBalance(after);
        }
    }
}

class AccountThread extends Thread{
    //两个线程必须共享同一个账户对象
    private Account act;
    //通过构造方法传递过来账户对象
    public AccountThread(Account act){
        this.act = act;
    }
    //run 方法的执行标识取款操作
    public void run(){
        //取5000
        double money = 5000;
        act.withdraw(money);
        System.out.println( Thread.currentThread().getName() + "账户" + act.getActno() + "取款" + money + "成功， 余额为" + act.getBalance());
    }
}
```

- synchronized可以写在实例方法上，如果出现在实例方法上，一定锁的是this，不能有其他对象了，不灵活
- 另外还有一个缺点：它出现在实例方法上的时候表示整个方法体都要同步，可能会无故扩大同步的范围，导致程序的执行效率变低，所以这种方式不常用。
- 写在实例方法上有什么优点：代码下的少了，节俭了。
- 如果共享的对象就是this，并且需要同步的代码块是整个方法体，建议使用这种方式。
- 同步代码块越小，效率越高
- 第一种：同步代码块 灵活 synchronized(线程共享对象){同步代码块;}
- 第二种：在实例方法上使用synchronized表示共享对象一定是this并且同步代码块是整个方法体。
- 第三种：在静态方法上使用synchronized表示找类锁。类锁永远只有1把。就算创建了100个对象，那类锁也只有一把。
- 对象锁：1个对象1把锁，100个对象100把锁。类锁：100个对象，也可能只是1把类锁。


#### 面试题

##### 一

面试题：doOther方法执行的时候需要等待doSome方法的结束吗？

```java
public class Exam01 {
    public static void main(String[] args) throws InterruptedException {
        MyClass mc = new MyClass();

        Thread t1 = new MyThread(mc);
        Thread t2 = new MyThread(mc);

        t1.setName("t1");
        t2.setName("t2");

        t1.start();
        Thread.sleep(1000); //这个睡眠的作用是：为了保证t1线程先执行。
        t2.start();
    }
}

class MyThread extends Thread {
    private MyClass mc;
    public MyThread(MyClass mc){
        this.mc = mc;
    }
    public void run(){
        if(Thread.currentThread().getName().equals("t1")){
            mc.doSome();
        }
        if(Thread.currentThread().getName().equals("t2")){
            mc.doOther();
        }
    }
}

class MyClass {
    public synchronized void doSome(){
        System.out.println("doSome begin");
        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("doSome over");
    }
    public void doOther(){
        System.out.println("doOther begin");
        System.out.println("doOther over");
    }
}

```

不需要，因为doOther()方法没有synchronized

##### 二

面试题：doOther方法执行的时候需要等待doSome方法的结束吗？

```java
public class Exam01 {
    public static void main(String[] args) throws InterruptedException {
        MyClass mc = new MyClass();

        Thread t1 = new MyThread(mc);
        Thread t2 = new MyThread(mc);

        t1.setName("t1");
        t2.setName("t2");

        t1.start();
        Thread.sleep(1000); //这个睡眠的作用是：为了保证t1线程先执行。
        t2.start();
    }
}

class MyThread extends Thread {
    private MyClass mc;
    public MyThread(MyClass mc){
        this.mc = mc;
    }
    public void run(){
        if(Thread.currentThread().getName().equals("t1")){
            mc.doSome();
        }
        if(Thread.currentThread().getName().equals("t2")){
            mc.doOther();
        }
    }
}

class MyClass {
    public synchronized void doSome(){
        System.out.println("doSome begin");
        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("doSome over");
    }
    public synchronized void doOther(){
        System.out.println("doOther begin");
        System.out.println("doOther over");
    }
}

```

需要，因为doOther()方法有synchronized了

##### 三

面试题：doOther方法执行的时候需要等待doSome方法的结束吗？

```java
public class Exam01 {
    public static void main(String[] args) throws InterruptedException {
        MyClass mc1 = new MyClass();
        MyClass mc2 = new MyClass();

        Thread t1 = new MyThread(mc1);
        Thread t2 = new MyThread(mc2);

        t1.setName("t1");
        t2.setName("t2");

        t1.start();
        Thread.sleep(1000); //这个睡眠的作用是：为了保证t1线程先执行。
        t2.start();
    }
}

class MyThread extends Thread {
    private MyClass mc;
    public MyThread(MyClass mc){
        this.mc = mc;
    }
    public void run(){
        if(Thread.currentThread().getName().equals("t1")){
            mc.doSome();
        }
        if(Thread.currentThread().getName().equals("t2")){
            mc.doOther();
        }
    }
}

class MyClass {
    public synchronized void doSome(){
        System.out.println("doSome begin");
        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("doSome over");
    }
    public synchronized void doOther(){
        System.out.println("doOther begin");
        System.out.println("doOther over");
    }
}
```

不需要，因为MyClass对象是两个，两把锁。

##### 四

面试题：doOther方法执行的时候需要等待doSome方法的结束吗？

```java
public class Exam01 {
    public static void main(String[] args) throws InterruptedException {
        MyClass mc1 = new MyClass();
        MyClass mc2 = new MyClass();

        Thread t1 = new MyThread(mc1);
        Thread t2 = new MyThread(mc2);

        t1.setName("t1");
        t2.setName("t2");

        t1.start();
        Thread.sleep(1000); //这个睡眠的作用是：为了保证t1线程先执行。
        t2.start();
    }
}

class MyThread extends Thread {
    private MyClass mc;
    public MyThread(MyClass mc){
        this.mc = mc;
    }
    public void run(){
        if(Thread.currentThread().getName().equals("t1")){
            mc.doSome();
        }
        if(Thread.currentThread().getName().equals("t2")){
            mc.doOther();
        }
    }
}

class MyClass {
    public synchronized static void doSome(){
        System.out.println("doSome begin");
        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("doSome over");
    }
    public synchronized static void doOther(){
        System.out.println("doOther begin");
        System.out.println("doOther over");
    }
}
```
synchronized出现在静态方法上是找类锁。

需要，因为静态方法是类锁，不管创建了几个对象，类锁只有1把。

#### 死锁


死锁代码要会写。
一般面试官要求你会写。
只有会写的，才会在以后的开发中注意这个事儿。
因为死锁很难调试。

```java

public class DeadLock {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();

        // t1和t2两个线程共享o1,o2
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread2(o1,o2);

        t1.start();
        t2.start();
    }
}

class MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o1){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){

            }
        }
    }
}

class MyThread2 extends Thread {
    Object o1;
    Object o2;
    public MyThread2(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o2){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){

            }
        }
    }
}
```

synchronized 在开发过程中最好不要嵌套使用


#### 怎么解决线程安全问题

是一上来就选择线程同步吗？synchronized
不是，synchronized会让程序的执行效率降低，用户体验不好。系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步机制。

第一种方案：尽量使用局部变量代替“实例变量和静态变量”。

第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）

第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。


### 守护线程/定时器

#### 守护线程

java语言中线程分为两大类：
一类是：用户线程
一类是：守护线程（后台线程）
其中具有代表性的就是：垃圾回收线程（守护线程）。

守护线程的特点：
一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。

注意：主线程main方法是一个用户线程。

守护线程用在什么地方呢？
每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，每到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。

设置为守护线程 t.setDaemon(true);

```java
public class ThreadTest14 {
    public static void main(String[] args) {
        Thread t = new BakDataThread();
        t.setName("备份数据的线程");

        // 启动线程之前，将线程设置为守护线程
        t.setDaemon(true);
        t.start();

        // 主线程：主线程是用户线程
        for(int i = 0; i < 10; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class BakDataThread extends Thread {
    public void run(){
        int i = 0;
        // 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。
        while(true){
            System.out.println(Thread.currentThread().getName() + "--->" + (++i));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 定时器

定时器的作用：间隔特定的时间，执行特定的程序。

每周要进行银行账户的总账操作。每天要进行数据的备份操作。

在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现：可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。（比较low）

在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。

在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务。

```java
/*
使用定时器指定定时任务。
 */
public class TimerTest {
    public static void main(String[] args) throws Exception {

        // 创建定时器对象
        Timer timer = new Timer();
        //Timer timer = new Timer(true); //守护线程的方式

        // 指定定时任务
        //timer.schedule(定时任务, 第一次执行时间, 间隔多久执行一次);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date firstTime = sdf.parse("2020-03-14 09:34:30");
        //timer.schedule(new LogTimerTask() , firstTime, 1000 * 10);
        // 每年执行一次。
        //timer.schedule(new LogTimerTask() , firstTime, 1000 * 60 * 60 * 24 * 365);

        //匿名内部类方式
        timer.schedule(new TimerTask(){
            @Override
            public void run() {
                // code....
            }
        } , firstTime, 1000 * 10);

    }
}

// 编写一个定时任务类
// 假设这是一个记录日志的定时任务
class LogTimerTask extends TimerTask {

    @Override
    public void run() {
        // 编写你需要执行的任务就行了。
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String strTime = sdf.format(new Date());
        System.out.println(strTime + ":成功完成了一次数据备份！");
    }
}
```

### 生产者和消费者模式

关于Object类中的wait和notify方法

- 第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是Object类中自带的。wait方法和notify方法不是通过线程对象调用，不是这样的：t.wait()，也不是这样的：t.notify()..不对。
- 第二：wait()方法作用？Object o = new Object();o.wait();
	- 表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。o.wait();方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态。
- 第三：notify()方法作用？Object o = new Object(); o.notify();
	+ 表示：唤醒正在o对象上等待的线程。
	+ 还有一个notifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。

#### 实现

使用wait方法和notify方法实现“生产者和消费者模式”

什么是“生产者和消费者模式”？
- 生产线程负责生产，消费线程负责消费。
- 生产线程和消费线程要达到均衡。
- 这是一种特殊的业务需求，在这种特殊的情况下需要使用wait方法和notify方法。

- wait和notify方法不是线程对象的方法，是普通java对象都有的方法。
- wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。
- wait方法作用：o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。
- notify方法作用：o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。


模拟这样一个需求：

- 仓库我们采用List集合。List集合中假设只能存储1个元素。1个元素就表示仓库满了。如果List集合中元素个数是0，就表示仓库空了。保证List集合中永远都是最多存储1个元素。必须做到这种效果：生产1个消费1个。

```java
public class ThreadTest16 {
    public static void main(String[] args) {
        // 创建1个仓库对象，共享的。
        List list = new ArrayList();
        // 创建两个线程对象
        // 生产者线程
        Thread t1 = new Thread(new Producer(list));
        // 消费者线程
        Thread t2 = new Thread(new Consumer(list));

        t1.setName("生产者线程");
        t2.setName("消费者线程");

        t1.start();
        t2.start();
    }
}

// 生产线程
class Producer implements Runnable {
    // 仓库
    private List list;

    public Producer(List list) {
        this.list = list;
    }
    @Override
    public void run() {
        // 一直生产（使用死循环来模拟一直生产）
        while(true){
            // 给仓库对象list加锁。
            synchronized (list){
                if(list.size() > 0){ // 大于0，说明仓库中已经有1个元素了。
                    try {
                        // 当前线程进入等待状态，并且释放Producer之前占有的list集合的锁。
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 程序能够执行到这里说明仓库是空的，可以生产
                Object obj = new Object();
                list.add(obj);
                System.out.println(Thread.currentThread().getName() + "--->" + obj);
                // 唤醒消费者进行消费
                list.notifyAll();
            }
        }
    }
}

// 消费线程
class Consumer implements Runnable {
    // 仓库
    private List list;

    public Consumer(List list) {
        this.list = list;
    }

    @Override
    public void run() {
        // 一直消费
        while(true){
            synchronized (list) {
                if(list.size() == 0){
                    try {
                        // 仓库已经空了。
                        // 消费者线程等待，释放掉list集合的锁
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 程序能够执行到此处说明仓库中有数据，进行消费。
                Object obj = list.remove(0);
                System.out.println(Thread.currentThread().getName() + "--->" + obj);
                // 唤醒生产者生产。
                list.notifyAll();
            }
        }
    }
}
```




### 面试题

#### sleep

```java
/*
关于Thread.sleep()方法的一个面试题：
 */
public class ThreadTest07 {
    public static void main(String[] args) {
        // 创建线程对象
        Thread t = new MyThread3();
        t.setName("t");
        t.start();

        // 调用sleep方法
        try {
            // 问题：这行代码会让线程t进入休眠状态吗？
            t.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 5秒之后这里才会执行。
        System.out.println("hello World!");
    }
}

class MyThread3 extends Thread {
    public void run(){
        for(int i = 0; i < 10000; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}

```
答案：

- 在执行的时候还是会转换成：Thread.sleep(1000 * 5);
- 这行代码的作用是：让当前线程进入休眠，也就是说main线程进入休眠。
- 这样代码出现在main方法中，main线程睡眠。

# JDBC

## 介绍

JDBC是什么？
- Java Database Counnectivity（Java语言链接数据库）

本质是什么？
- SUN公司制定的一套接口（interface）
    + java.sql.* 这个包下的
- 接口都有调用者/实现者
- 面向接口调用/面向接口写实现类，都属于面向接口编程

为什么面向接口编程？
- 解耦合，降低程序的耦合度，提高程序的扩展力
- 多态就是非常典型的面向抽象编程（不要面向具体过程编程）

为什么制定这一套接口呢？
- 因为每一个数据可以的底层实现原理都不一样（oracle/mysql/ms sqlserver）
- 每一个数据库产品都有自己独特的实现原理。

开发的准备：如果是用文本编辑器开发，则需要配置classpath文件，用IDEA的时候，不需要

## API 主要成员变量



JDBC API 主要功能：三件事，具体是通过以下类/接口实现：

- DriverManager ： 管理jdbc驱动

- Connection： 连接（通过DriverManager产生）

- Statement（PreparedStatement） ：增删改查  （通过Connection产生 ）

- CallableStatement  ： 调用数据库中的 存储过程/存储函数  （通过Connection产生 ）

- Result ：返回的结果集  （上面的Statement等产生 ）



Connection产生操作数据库的对象：

- Connection产生Statement对象：createStatement()

- Connection产生PreparedStatement对象：prepareStatement()

- Connection产生CallableStatement对象：prepareCall();



Statement操作数据库：

- 增删改：executeUpdate()

- 查询：executeQuery();

- ResultSet：保存结果集 select * from xxx

- next():光标下移，判断是否有下一条数据；true/false

- previous():  true/false

- getXxx(字段名|位置):获取具体的字段值 



PreparedStatement操作数据库：

因为 public interface PreparedStatement extends Statement 

所以

- 增删改：executeUpdate()

- 查询：executeQuery();

- 赋值操作 setXxx();



PreparedStatement与Statement在使用时的区别：

1. Statement: sql executeUpdate(sql)
2. PreparedStatement: sql(可能存在占位符?) 在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql) executeUpdate() setXxx()替换占位符？



推荐使用PreparedStatement：原因如下：

1.编码更加简便（避免了字符串的拼接）

2.提高性能(因为 有预编译操作，预编译只需要执行一次)

3.安全（可以有效防止sql注入）



JDBC编程六步

1. 注册驱动（作用：告诉Java程序，即将链接的是哪个品牌的数据库）
2. 获取链接（表示JVM的进程和数据库进程之间的**通道打开**了，属于进程之间的通信，重量级的，使用完一定要关闭）
3. 获取数据库操作对象（专门执行sql语句的对象）
4. 执行SQL语句（DQL and DML）
5. 处理查询结果集（只有当4执行的是select语句的时候，才有这个处理查询结果集）
6. 释放资源（使用完资源之后一定要关闭资源）



---



## 普通数据增删改查实例

### 练习1

向dept中添加一个职位‘人事部’，no为50，地址为北京

```java
import java.sql.*;

public class Test{
    public static void main(String[] args){
        Statement stmt = null;
        Connection conn = null;
        try{
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            String url = "jdbc:mysql://127.0.0.1:3306/mytest";
            String user = "root";
            String password = "333";
            conn = DriverManager.getConnection(url, user, password);
            //3.获取数据库操作对象
            stmt = conn.createStatement();
            //4.执行sql
            String sql = "insert into dept(deptno, dname, loc) value(60, 'renshi2', 'beijing1')";
            //专门执行DML语句的(insert delete update)
            //返回值是“影响数据库中的记录条数”
            int count = stmt.executeUpdate(sql);
            System.out.print(count == 1 ? "success" : "fail");
            //5.处理结果集
            //不是select语句，不需要处理
            //6.释放资源，为了保证资源一定释放，在finally中关闭资源
            //从小到大依次关闭，分别对其try/catch
        }catch(SQLException e){
            e.printStackTrace();
        }finally{
            // 关闭数据库连接，此处省略
        }
    }
}
```

### 练习2

删除一条数据

```java
import java.sql.*;
import java.util.*;
/*
    实际开发中不建议把数据库的信息写死到java程序中
*/
public class Test{
    public static void main(String[] args){
        Connection conn = null;
        Statement stmt = null;
        try{
        //1. 注册驱动， 通过反射机制，这种方式常用
        //因为参数是一个字符串，自负床可以写到.properties文件中
        //以下方法不接受返回值，因为我们只用它的加载动作
        Class.forName("com.mysql.jdbc.Driver");
        //2. 获取链接
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
        //3. 获取数据库操作对象
        stmt = conn.createStatement();
        //4. 执行SQL语句
        String sql = "delete from dept where deptno = 50";
        int count = stmt.executeUpdate(sql);
        if(count == 1)
            System.out.print("yes");
        //5. 未使select语句，所以不用处理查询结果集
        }catch(ClassNotFoundException e){
            e.printStackTrace();
        }catch(SQLException e){
            e.printStackTrace();
        }finally{
            //6. 释放资源
           // 关闭数据库连接，此处省略
        }
    }
}
```

### 将链接数据库的所有信息配置到信息文件中



```java
import java.sql.*;
import java.util.*;
/*
    实际开发中不建议把数据库的信息写死到java程序中
*/
public class Test{
    public static void main(String[] args){
        //使用资源绑定器
        ResourceBundle bundle = ResourceBundle.getBundle("jdbc");
        //String driver = bundle.getString("Driver");
        String url = bundle.getString("url");
        String user = bundle.getString("user");
        String password = bundle.getString("password");
        Connection conn = null;
        Statement stmt = null;
        try{
        //1. 注册驱动， 通过反射机制，这种方式常用
        //因为参数是一个字符串，所以可以写到.properties文件中
        //以下方法不接受返回值，因为我们只用它的加载动作
        Class.forName("com.mysql.jdbc.Driver");
        //2. 获取链接
        conn = DriverManager.getConnection(url, user, password);
        //3. 获取数据库操作对象
        stmt = conn.createStatement();
        //4. 执行SQL语句
        String sql = "insert into dept(deptno, dname, loc) value(50,'HumanResource','Beijing')";
        int count = stmt.executeUpdate(sql);
        if(count == 1)
            System.out.print("yes");
        //5. 未使select语句，所以不用处理查询结果集
        }catch(ClassNotFoundException e){
            e.printStackTrace();
        }catch(SQLException e){
            e.printStackTrace();
        }finally{
            //6. 释放资源
   // 关闭数据库连接，此处省略
        }
    }
}
```

### 查询结果集的处理



```java
import java.sql.*;

public class Test{
    public static void main(String[] args){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try{
            //1. 注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2. 获取链接
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
            //3. 获取数据库操作对象
            stmt = conn.createStatement();
            //4. 执行sql
            String sql = "select ename name ,sal s from emp";
            /*
                (int) executeUpdate(insert/delete/update), 返回执行成功的数量
                (ResultSet) executeQuery(select), 返回查询结果集
            */
            rs = stmt.executeQuery(sql); //专门处理DQL语句的方法
            //5. 处理查询结果集
            while(rs.next()){
                //光标指向的 行 有数据，取数据
                String ename = rs.getString("name"); //引号里面是列名字，也可以是第几列（从1开始）
                // 不管数据库中的数据类型是什么，都以String类型取出来
                //这里的列名是查询结果集中的列名，也就是重命名之后的列名
                //JDBC 中所有的数据从1开始而不是从0开始
                Double sal = rs.getDouble("s");
                System.out.println(ename + " " + sal);
                //除了以String类型去除之外，也可以用其他类型取出
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            // 6. 释放资源
           // 关闭数据库连接，此处省略
        }
    }
}
```

### 用户登录功能实现

可以对sql脚本进行编辑

```sql

drop table if exists t_user;
/*==============================================================*/
/* Table: t_user                                                */
/*==============================================================*/
create table t_user
(
   id                   bigint auto_increment,
   loginName            varchar(255),
   loginPwd             varchar(255),
   realName             varchar(255),
   primary key (id)

);
INSERT INTO t_user
(
 loginName, loginPwd, realName
)
VALUES
(
 'zhangsan', '123', '张三'
),
(
 'jack','123','杰克'
),
(
 'lisi','123','李四'
);

```

#### 问题代码

```java
import java.sql.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        //初始化界面
        Map<String,String> userLoginInfo = initUI();
        // 验证用户名和密码
        boolean loginRst = login(userLoginInfo);
        //输出结果
        System.out.println(loginRst ? "登录成功" : "登录失败");
    }

    /**
     *用户登录
     * @param userLoginInfo 用户登录信息
     * @return 用户登录的结果 false失败，true成功
     */
    private static boolean login(Map<String, String> userLoginInfo) {
        boolean loginSuccess = false; //打标记
        //JDBC代码
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
            //3.获取数据操作对象
            stmt = conn.createStatement();
            //4.执行sql
            String sql = "select * from t_user where loginName = '" + userLoginInfo.get("loginName") + "' and loginPwd = '" + userLoginInfo.get("loginPwd") + "'";
            rs = stmt.executeQuery(sql);
            //5.处理结果集
            if(rs.next()){
                loginSuccess = true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
        //6.释放资源
            try {
            if(rs != null) {
                rs.close();
            }
            } catch (SQLException s) {
                s.printStackTrace();
            }

            try{
                if(stmt != null){
                    stmt.close();
                }
            }catch (SQLException s){
                s.printStackTrace();
            }

            try{
                if(conn != null){
                    conn.close();
                }
            }catch(SQLException s){
                s.printStackTrace();
            }
        }
        return loginSuccess;
    }

    /**
     * 初始化用户界面
     * @return 用户输入的用户名和密码等信息
     */
    private static Map<String, String> initUI() {
        Scanner s = new Scanner(System.in);
        System.out.println("用户名：");
        String username = s.next();
        System.out.println("密码：");
        String password = s.next();
        Map<String, String> userLoginInfo = new HashMap<>();
        userLoginInfo.put("loginName", username);
        userLoginInfo.put("loginPwd", password);
        return userLoginInfo;
    }
}
```


#### SQL注入

用户名：asd

密码：asd'or'1' = '1

原因：用户输入的信息中含有sql语句的关键字，并且这些关键字参与sql语句的编译过程，导致sql的原意被扭曲。

解决：

只要用户提供的信息不参与SQL语句的编译过程，问题就解决了。即使用户提供的信息中含有SQL语句的关键字，但是没有参与编译，不起作用，要想用户信息不参与SQL语句的编译，那么必须使用java.sql.PreparedStatement.
这个接口继承了java.sql.Statement,是预编译的数据库操作对象，原理：预先对SQL语句的框架进行编译，然后再给SQL语句传值。

对比Statement和PerparedStatement：
- Statement存在SQL注入问题，preparedstatement解决了SQL注入问题。
- Statement是编译一次执行一次。preparedstatement是编译一次，可执行多次。
- PreparedStatement效率较高一些。
- PreparedStatement会在编译阶段做类型的安全检查。

综上所述：Preparedstatement使用较多。只有极少数的情况下需要使用statement

什么情况下必须使用statement呢？
- 业务方面要求必须支持SQL注入的时候。需要进行SQL语句的拼接的时候。
- Statement支持SQL注入，凡是业务方面要求是需要进行SQL语句拼接的，必须使用Statement


#### 最终版本

```java
import java.sql.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        //初始化界面
        Map<String,String> userLoginInfo = initUI();
        // 验证用户名和密码
        boolean loginRst = login(userLoginInfo);
        //输出结果
        System.out.println(loginRst ? "登录成功" : "登录失败");
    }

    /**
     *用户登录
     * @param userLoginInfo 用户登录信息
     * @return 用户登录的结果 false失败，true成功
     */
    private static boolean login(Map<String, String> userLoginInfo) {
        boolean loginSuccess = false; //打标记
        //JDBC代码
        Connection conn = null;
        PreparedStatement ps = null; //这里使用PS预编译的数据库操作对象
        ResultSet rs = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
            //3.获取预编译的数据操作对象
            // ？ 不能用单引号括起来
            String sql = "select * from t_user where loginName = ? and loginPwd = ?"; // 先写上SQL语句的框架，其中一个？标识一个占位符
            //程序执行到这步，会发送SQL语句的框架给DBMS，然后DBMS进行sql语句的预编译
            ps = conn.prepareStatement(sql);//这里不用传入sql语句参数了
            // 给 ‘？’ 传值 第一个问号下标是1，第二个是2，JDBC所有下标从1开始
            ps.setString(1, userLoginInfo.get("loginName"));//自动添加上单引号
            ps.setString(2, userLoginInfo.get("loginPwd"));
            //4.执行ps对象的sql
            rs = ps.executeQuery(); //这里不用传入参数了
            //5.处理结果集
            if(rs.next()){
                loginSuccess = true; //登录成功
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
        //6.释放资源
            try {
            if(rs != null) {
                rs.close();
            }
            } catch (SQLException s) {
                s.printStackTrace();
            }

            try{
                if(ps != null){
                    ps.close();
                }
            }catch (SQLException s){
                s.printStackTrace();
            }

            try{
                if(conn != null){
                    conn.close();
                }
            }catch(SQLException s){
                s.printStackTrace();
            }
        }
        return loginSuccess;
    }

    /**
     * 初始化用户界面
     * @return 用户输入的用户名和密码等信息
     */
    private static Map<String, String> initUI() {
        Scanner s = new Scanner(System.in);
        System.out.println("用户名：");
        String username = s.next();
        System.out.println("密码：");
        String password = s.next();
        Map<String, String> userLoginInfo = new HashMap<>();
        userLoginInfo.put("loginName", username);
        userLoginInfo.put("loginPwd", password);
        return userLoginInfo;
    }
}
```

### PrepareStatement

```java
import java.sql.*;

public class Test{
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs =null;

        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
            //3.获取预编译的数据操作对象
            String sql = "insert into dept(dname, loc, deptno) values(?, ?, ?)";
            ps = conn.prepareStatement(sql);
            ps.setString(1, "HR");
            ps.setString(2, "Shanghai");
            ps.setInt(3, 70);
            //4.执行ps对象的sql
            int count = ps.executeUpdate();
            System.out.println(count);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            // 6.释放资源
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
    }
}
```

### 银行转账业务

JDBC事务默认自动提交，

关闭自动提交？  conn.setAutoCommit(false);

提交事务 conn.commit();

回滚事务 conn.rollback();

```java
import java.sql.*;

public class Test{
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs =null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
            //3.获取预编译的数据操作对象
            conn.setAutoCommit(false); //关闭自动提交
            String sql = "update t_account set balance = ? where act = ?";
            ps = conn.prepareStatement(sql);

            //4.执行ps对象的sql
            //给 ？ 传值
            ps.setDouble(1, 10000);
            ps.setString(2, "111");
            int count  = ps.executeUpdate();

            ps.setDouble(1, 10000);
            ps.setString(2, "222");
            count  += ps.executeUpdate();
            System.out.println(count == 2 ? "转账成功" : "转账失败");

            conn.commit(); //提交事务
        } catch (Exception e) {
            if(conn != null){
                try { //回滚事务
                    conn.rollback();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
            e.printStackTrace();
        }finally {
            // 6.释放资源
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
    }
}
```

### JDBC工具类的封装

```java
import java.sql.*;

public class DBUtil {
    /**
     * 工具类中的构造方法是私有的
     * 因为工具类中的方法都是静态的，不需要new对象，直接类名调用
     */
    private DBUtil(){}

    //静态代码块在类加载时执行，并且只执行一次
    static {
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取链接对象
     * @return 链接对象
     * @throws SQLException 连接异常
     */
    public static Connection getConnection() throws SQLException{
        return DriverManager.getConnection("jdbc:mysql://localhost:3306/mytest", "root", "333");
    }

    /**
     * 释放资源
     * @param conn 链接对象
     * @param ps 操作对象
     * @param rs 查询结果集
     */
    public static void close(Connection conn, Statement ps, ResultSet rs){
        if(rs != null){
            try {
                rs.close();
            } catch (SQLException s) {
                s.printStackTrace();
            }
        }
        if(ps != null){
            try {
                ps.close();
            } catch (SQLException s) {
                s.printStackTrace();
            }
        }
        if(conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

```

### 基于工具类的模糊查询

查询员工中名字有A的

```java
import java.sql.*;

public class Test{
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs =null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取链接
            conn = DBUtil.getConnection();
            //3.获取预编译的数据操作对象
            String sql = "select ename from emp where ename like ?";
            ps = conn.prepareStatement(sql);
            ps.setString(1, "_A%");
            //4.执行ps对象的sql
            rs = ps.executeQuery();
            while(rs.next()){
                System.out.println(rs.getString("ename"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            DBUtil.close(conn, ps, rs);
        }
    }
}
```



## 存储过程与存储函数调用

CallableStatement:调用 存储过程、存储函数

connection.prepareCall(参数：存储过程或存储函数名)

参数格式：

存储过程（无返回值return，用out参数替代）：

​	{ call  存储过程名(参数列表) }

存储函数（有返回值return）：

​	{ ? = call  存储函数名(参数列表) }

```plsql
create or replace procedure addTwoNum ( num1  in number,num2  in number,result out number )  as
begin
	result := num1+num2 ;
end ;
```

强调：

如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID

通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener

JDBC调用存储过程的步骤：

a. 产生 调用存储过程的对象（CallableStatement） cstmt = 	connection.prepareCall(   "..." ) ;

b. 通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);

c. 通过 registerOutParameter(...)处理输出参数类型

d.cstmt.execute()执行

e.接受 输出值（返回值）getXxx()

调存储函数：

```plsql
create or replace function addTwoNumfunction ( num1  in number,num2  in number)  -- 1 + 2 
return number
as
	result number ;	
begin
	result := num1+num2 ;
	return result ;
end ;
```

JDBC调用存储函数：与调存储过程的区别：
在调用时，注意参数："{? =  call addTwoNumfunction	(?,?) }"

### 存储过程

首先在数据库中创建存过程：

```sql
CREATE OR REPLACE PROCEDURE ADDNUM(num1 in number, num2 in number, rst out number) AS 
BEGIN -- 计算两个数的和，给第三个值
  rst := num1 + num2; 
END ADDNUM;
```

然后进行调用

```java
        // 数据库连接
        Connection conn = null;
        // 存储过程返回值的对象
        CallableStatement callableStatement = null;

        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:ORCL", "c##libmanager", "333");
            callableStatement = conn.prepareCall("{call addNum(?, ?, ?)}");

            // 设置第一个和第二个数
            callableStatement.setInt(1, 13);
            callableStatement.setInt(2, 10);
            // 设置第三个参数的输出类型
            callableStatement.registerOutParameter(3, Types.INTEGER);

            // 调用存储过程， 执行的是num1 + num2
            // 这句话之前处理的是输入值， 这句话之后是输出值
            callableStatement.execute();
            // 获取返回值
            int rst =  callableStatement.getInt(3);
            // 输出计算结果
            System.out.println(rst);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        
```

### 存储函数

在数据库中创建函数：

```sql
CREATE OR REPLACE FUNCTION addNum 
(
  NUM1 IN NUMBER  
, NUM2 IN NUMBER  
) RETURN NUMBER AS 
BEGIN
  RETURN num1 + num2;
END addNum;
```

```java
        // 数据库连接
        Connection conn = null;
        // 存储过程返回值的对象
        CallableStatement callableStatement = null;

        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:ORCL", "c##libmanager", "333");
            callableStatement = conn.prepareCall("{? = call addNum(?, ?)}");

            // 设置第一个和第二个数
            callableStatement.setInt(2, 13);
            callableStatement.setInt(3, 10);
            // 设置第三个参数的输出类型
            callableStatement.registerOutParameter(1, Types.INTEGER);

            // 调用函数， 执行的是num1 + num2
            // 这句话之前处理的是输入值， 这句话之后是输出值
            callableStatement.execute();
            // 获取返回值
            int rst = callableStatement.getInt(1);
            // 输出计算结果
            System.out.println(rst);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }

```

## 大类型数据存储与读取实例

处理CLOB/BLOB类型 - 处理稍大型数据：

a.存储路径	E:\JDK_API_zh_CN.CHM	通过JDBC存储文件路径，然后 根据IO操作处理

例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式 “E:\JDK_API_zh_CN.CHM” 存储到数据库中

获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO	

b.

CLOB：大文本数据 （小说->数据）

BLOB：二进制

clob:大文本数据   字符流 Reader Writer



存:

1. 先通过pstmt 的? 代替小说内容 （占位符）

2. 再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型

取：

1. 通过Reader reader = rs.getCharacterStream("NOVEL") ; 将cloc类型的数据  保存到Reader对象中
2. 将Reader通过Writer输出即可。

blob:二进制  字节流 InputStream OutputStream

与CLOB步骤基本一致，区别：setBinaryStream(...)  getBinaryStream(...)   

### 大文本存储

存储

```java
			String sql = "insert into mynovel values(?,?)";
			// c.发送sql，执行(增删改、查)
			pstmt = connection.prepareStatement(sql);
			pstmt.setInt(1, 1);
			File file = new File("E:\\all.txt");
			InputStream in = new FileInputStream( file) ;
			Reader reader = new InputStreamReader( in   ,"UTF-8") ;//转换流 可以设置编码
			pstmt.setCharacterStream(2, reader,  (int)file.length());
			int count =pstmt.executeUpdate() ;
			// d.处理结果
			if (count > 0) {  
				System.out.println("操作成功！");
			}
			
			reader.close();
```



读取

```java
			String sql = "select NOVEL from mynovel where id = ? ";
			// c.发送sql，执行(查)
			pstmt = connection.prepareStatement(sql);
			pstmt.setInt(1, 1);
			
			rs = pstmt.executeQuery() ;
			//setXxxx getXxxx      setInt  getInt
			if(rs.next())
			{
				Reader reader = rs.getCharacterStream("NOVEL") ;
				Writer writer = new FileWriter("src/小说.txt");
				
				char[] chs = new char[100] ;
				int len = -1;
				while(  (len = reader.read(chs)) !=-1 ) {
					writer.write( chs,0,len  );
				}
				writer.close();
				reader.close();
			}

```

### 音乐存储

存储

```java
			String sql = "insert into mymusic values(?,?)";
			// c.发送sql，执行(增删改、查)
			pstmt = connection.prepareStatement(sql);
			pstmt.setInt(1, 1);
			File file = new File("d:\\luna.mp3");
			
			InputStream in = new FileInputStream(file );
			pstmt.setBinaryStream(2,in ,(int)file.length()  );
			
			
			int count =pstmt.executeUpdate() ;
			// d.处理结果
			if (count > 0) {  
				System.out.println("操作成功！");
			}
			// 关闭流
			in.close();
```

读取：

```java
			String sql = "select music from mymusic where id = ? ";
			
			
			// c.发送sql，执行(查)
			pstmt = connection.prepareStatement(sql);
			pstmt.setInt(1, 1);
			
			rs = pstmt.executeQuery() ;
			if(rs.next())
			{
				InputStream in = rs.getBinaryStream("music") ;
				OutputStream out = new FileOutputStream("src/music.mp3") ;
				
				byte[] chs = new byte[100] ;
				int len = -1;
				while(  (len = in.read(chs)) !=-1 ) {
					out.write( chs,0,len  );
				}
				out.close();
				in.close();
			}
```
